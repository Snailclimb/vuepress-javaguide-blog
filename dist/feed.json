{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "JavaGuide",
  "home_page_url": "https://vuepress-theme-hope-demo.mrhope.site/",
  "feed_url": "https://vuepress-theme-hope-demo.mrhope.site/feed.json",
  "description": "Java学习&&面试指南",
  "author": {
    "name": "Guide哥"
  },
  "items": [
    {
      "title": "Statistic：项目代码统计",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/code-statistic/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/code-statistic/",
      "content_html": "<p>编程是一个很奇妙的事情，大部分的我们把大部分时间实际都花在了复制粘贴，而后修改代码上面。</p>\n<p>很多时候，我们并不关注代码质量，只要功能能实现，我才不管一个类的代码有多长、一个方法的代码有多长。</p>\n<p>因此，我们经常会碰到让自己想要骂街的项目，不过，说真的，你自己写的代码也有极大可能被后者 DISS。</p>\n<p>为了快速分析项目情况，判断这个项目是不是一个“垃圾”项目，有一个方法挺简单的。</p>\n<p>那就是<strong>对代码的总行数、单个文件的代码行数、注释行数等信息进行统计。</strong></p>\n<p><strong>怎么统计呢？</strong></p>\n<p>首先想到的是 Excel 。不过，显然太麻烦了。</p>\n<p><strong>有没有专门用于代码统计的工具呢？</strong></p>\n<p>基于Perl语言开发的cloc（count lines of code）或许可以满足你的要求。</p>\n<p><strong>有没有什么更简单的办法呢？</strong></p>\n<p>如果你使用的是 IDEA 进行开发的话，推荐你可以使用一下 <strong>Statistic</strong> 这个插件。</p>\n<p>有了这个插件之后你可以非常直观地看到你的项目中所有类型的文件的信息比如数量、大小等等，可以帮助你更好地了解你们的项目。</p>\n<p><img src=\"./pictures/Statistic1.png\" alt=\"\" /></p>\n<p>你还可以使用它看所有类的总行数、有效代码行数、注释行数、以及有效代码比重等等这些东西。</p>\n<p><img src=\"./pictures/Statistic2.png\" alt=\"\" /></p>\n<p>如果，你担心插件过多影响IDEA速度的话，可以只在有代码统计需求的时候开启这个插件，其他时间禁用它就完事了！</p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "Camel Case：命名之间快速切换",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/camel-case/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/camel-case/",
      "content_html": "<p>非常有用！这个插件可以实现包含6种常见命名格式之间的切换。并且，你还可以对转换格式进行相关配置（转换格式），如下图所示：</p>\n<p><img src=\"./pictures/camel-case/camel-case1.png\" alt=\"img\" /></p>\n<p>有了这个插件之后，你只需要使用快捷键 <code>shift+option+u(mac)</code> / <code>shift+alt+u</code> 对准你要修改的变量或者方法名字，就能实现在多种格式之间切换了，如下图所示：</p>\n<p><img src=\"./pictures/camel-case/camel-case2.gif\" alt=\"\" /></p>\n<p>如果你突然忘记快捷键的话，可以直接在IDEA的菜单栏的 Edit 部分找到。</p>\n<p><img src=\"./pictures/camel-case/camel-case3.png\" alt=\"\" /></p>\n<p>使用这个插件对开发效率提升高吗？拿我之前项目组的情况举个例子：</p>\n<p>我之前有一个项目组的测试名字是驼峰这种形式: <code>ShouldReturnTicketWhenRobotSaveBagGiven1LockersWith2FreeSpace</code> 。但是，使用驼峰形式命名测试方法的名字不太明显，一般建议用下划线_的形式： <code>should_return_ticket_when_robot_save_bag_given_1_lockers_with_2_free_space</code></p>\n<p>如果我们不用这个插件，而是手动去一个一个改的话，工作量想必会很大，而且正确率也会因为手工的原因降低。</p>\n<blockquote></blockquote>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "CodeGlance：代码微型地图",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/code-glance/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/code-glance/",
      "content_html": "<p>CodeGlance提供一个代码的微型地图，当你的类比较多的时候可以帮忙你快速定位到要去的位置。这个插件在我们日常做普通开发的时候用处不大，不过，在你阅读源码的时候还是很有用的，如下图所示：</p>\n<p><img src=\"./pictures/code-glance.png\" alt=\"\" /></p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "GsonFormat：JSON转对象",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/gson-format/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/gson-format/",
      "content_html": "<p>GsonFormat 这个插件可以根据Gson库使用的要求,将JSONObject格式的String 解析成实体类。</p>\n<blockquote>\n<p>说明：2021.x 版本以上的 IDEA 可以使用：GsonFormatPlus</p>\n</blockquote>\n<p>这个插件使用起来非常简单，我们新建一个类，然后在类中使用快捷键 <code>option + s</code>(Mac)或<code>alt + s</code> (win)调出操作窗口（<strong>必须在类中使用快捷键才有效</strong>），如下图所示。</p>\n<p><img src=\"./pictures/GsonFormat2.gif\" alt=\"\" /></p>\n<p>这个插件是一个国人几年前写的，不过已经很久没有更新了，可能会因为IDEA的版本问题有一些小Bug。而且，这个插件无法将JSON转换为Kotlin（这个其实无关痛痒，IDEA自带的就有Java转Kotlin的功能）。</p>\n<p><img src=\"./pictures/GsonFormat1.png\" alt=\"\" /></p>\n<p>另外一个与之相似的插件是 <strong>：RoboPOJOGenerator</strong> ，这个插件的更新频率比较快。</p>\n<p><code>File-&gt; new -&gt; Generate POJO from JSON</code></p>\n<p><img src=\"./pictures/RoboPOJOGenerator1.png\" alt=\"\" /></p>\n<p>然后将JSON格式的数据粘贴进去之后，配置相关属性之后选择“<em>Generate</em>”</p>\n<p><img src=\"./pictures/RoboPOJOGenerator2.png\" alt=\"\" /></p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "Git Commit Template：提交代码格式规范",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/git-commit-template/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/git-commit-template/",
      "content_html": "<p>没有安装这个插件之前，我们使用IDEA提供的Commit功能提交代码是下面这样的：</p>\n<p><img src=\"./pictures/git-commit-template/Git-Commit-Template1.png\" alt=\"\" /></p>\n<p>使用了这个插件之后是下面这样的，提供了一个commit信息模板的输入框：</p>\n<p><img src=\"./pictures/git-commit-template/Git-Commit-Template2.png\" alt=\"\" /></p>\n<p>完成之后的效果是这样的：</p>\n<p><img src=\"./pictures/git-commit-template/Git-Commit-Template3.png\" alt=\"\" /></p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "IDEA 界面美化插件推荐",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/interface-beautification/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/interface-beautification/",
      "content_html": "<h2 id=\"background-image-plus-背景图片\"> Background Image Plus:背景图片</h2>\n<p>我这里推荐使用国人 Jack Chu 基于 Background Image Plus 开发的最新版本，适用于 2021.x 版本的 IDEA。</p>\n<p>前面几个下载量比较高的，目前都还未支持 2021.x 版本的 IDEA。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/image-20211010174138279.png\" alt=\"Background Image Plus\" /></p>\n<p>通过这个插件，你可以将 IDEA 背景设置为指定的图片，支持随机背景。</p>\n<p>效果图如下：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/image-20211010173730828.png\" alt=\"Background Image Plus 设置背景效果图\" /></p>\n<p>如果你想要设置随机背景的话，可以通过 IDEA 设置页 <strong>Settings</strong> -&gt; <strong>Appearance &amp; Behaviour</strong> -&gt; <strong>Background Image Plus</strong> 自定义设置项，随机显示目录下的图片为背景图。</p>\n<h2 id=\"power-mode-ii-代码特效\"> Power Mode II : 代码特效</h2>\n<p>使用了这个插件之后，写代码会自带特效，适用于 2021.x 版本的 IDEA。 2021.x 版本之前，可以使用 <strong>activate-power-mode</strong> 。</p>\n<p><img src=\"./pictures/power-mode/Power-Mode-II.gif\" alt=\"Power Mode II 效果图\" /></p>\n<p>你可以通过 IDEA 设置页 <strong>Settings</strong> -&gt; <strong>Appearance &amp; Behaviour</strong> -&gt; <strong>Power Mode II</strong> 自定义设置项。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/image-20211010175304108.png\" alt=\"Power Mode II\" /></p>\n<h2 id=\"nyan-progress-bar-进度条美化\"> Nyan Progress Bar : 进度条美化</h2>\n<p>可以让你拥有更加漂亮的进度条。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/image-20211010175434133.png\" alt=\"\" /></p>\n<h2 id=\"grep-console-控制台输出处理\"> Grep Console:控制台输出处理</h2>\n<p>可以说是必备的一个 IDEA 插件，非常实用！</p>\n<p>这个插件主要的功能有两个：</p>\n<p><strong>1. 自定义设置控制台输出颜色</strong></p>\n<p>我们可以在设置中进行相关的配置:</p>\n<p><img src=\"./pictures/grep-console/grep-console2.png\" alt=\"\" /></p>\n<p>配置完成之后的 log warn 的效果对比图如下：</p>\n<p><img src=\"./pictures/grep-console/grep-console3.png\" alt=\"\" /></p>\n<p><strong>2. 过滤控制台输出</strong></p>\n<p><img src=\"./pictures/grep-console/grep-console.gif\" alt=\"\" /></p>\n<h2 id=\"rainbow-brackets-彩虹括号\"> Rainbow Brackets : 彩虹括号</h2>\n<p>使用各种鲜明的颜色来展示你的括号，效果图如下。可以看出代码层级变得更加清晰了，可以说非常实用友好了！</p>\n<p><img src=\"./pictures/rainbow-brackets.png\" alt=\"\" /></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/image-20211010174138279.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "IDE Features Trainer：IDEA 交互式教程",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/idea-features-trainer/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/idea-features-trainer/",
      "content_html": "<p><strong>有了这个插件之后，你可以在 IDE 中以交互方式学习IDEA最常用的快捷方式和最基本功能。</strong> 非常非常非常方便！强烈建议大家安装一个，尤其是刚开始使用IDEA的朋友。</p>\n<p>当我们安装了这个插件之后，你会发现我们的IDEA 编辑器的右边多了一个“<strong>Learn</strong>”的选项，我们点击这个选项就可以看到如下界面。</p>\n<p><img src=\"./pictures/IDE-Features-Trainer1.png?lastModify=1633856821\" alt=\"\" /></p>\n<p>我们选择“Editor Basics”进行，然后就可以看到如下界面，这样你就可以按照指示来练习了！非常不错！</p>\n<p><img src=\"./pictures/IDE-Features-Trainer2.png?lastModify=1633856821\" alt=\"\" /></p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "IDEA 代码优化插件推荐",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/improve-code/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/improve-code/",
      "content_html": "<h2 id=\"lombok-帮你简化代码\"> Lombok:帮你简化代码</h2>\n<p>之前没有推荐这个插件的原因是觉得已经是人手必备的了。如果你要使用 Lombok 的话，不光是要安装这个插件，你的项目也要引入相关的依赖。</p>\n<div><pre><code>        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.projectlombok<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>lombok<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>optional</span><span>></span></span>true<span><span><span>&lt;/</span>optional</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>使用 Lombok 能够帮助我们少写很多代码比如 Getter/Setter、Constructor等等。</p>\n<p>关于Lombok的使用，可以查看这篇文章：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485385&amp;idx=2&amp;sn=a7c3fb4485ffd8c019e5541e9b1580cd&amp;chksm=cea24802f9d5c1144eee0da52cfc0cc5e8ee3590990de3bb642df4d4b2a8cd07f12dd54947b9&amp;token=1667678311&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">《十分钟搞懂Java效率工具Lombok使用与原理》</a>。</p>\n<h2 id=\"codota-代码智能提示\"> Codota：代码智能提示</h2>\n<p>我一直在用的一个插件，可以说非常好用了（<em>我身边的很多大佬平时写代码也会用这个插件</em>）。</p>\n<p>Codota 这个插件用于智能代码补全，它基于数百万Java程序，能够根据程序上下文提示补全代码。相比于IDEA自带的智能提示来说，Codota 的提示更加全面一些。</p>\n<p>如果你觉得 IDEA 插件安装的太多比较卡顿的话，不用担心！Codota 插件还有一个对应的在线网站（<a href=\"https://www.codota.com/code\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.codota.com/code</a>），在这个网站上你可以根据代码关键字搜索相关代码示例，非常不错！</p>\n<p>我在工作中经常会用到，说实话确实给我带来了很大便利，比如我们搜索 <code>Files.readAllLines</code>相关的代码，搜索出来的结果如下图所示：</p>\n<p><img src=\"./pictures/Codota3.png\" alt=\"\" /></p>\n<p>另外，Codota 插件的基础功能都是免费的。你的代码也不会被泄露，这点你不用担心。</p>\n<p>简单来看看 Codota 插件的骚操作吧！</p>\n<h3 id=\"代码智能补全\"> 代码智能补全</h3>\n<p>我们使用<code>HttpUrlConnection</code> 建立一个网络连接是真的样的：</p>\n<p><img src=\"./pictures/Codota1.gif\" alt=\"\" /></p>\n<p>我们创建线程池现在变成下面这样：</p>\n<p><img src=\"./pictures/Codota4.gif\" alt=\"\" /></p>\n<p>上面只是为了演示这个插件的强大，实际上创建线程池不推荐使用这种方式， 推荐使用 <code>ThreadPoolExecutor</code> 构造函数创建线程池。我下面要介绍的一个阿里巴巴的插件-<strong>Alibaba Java Code Guidelines</strong> 就检测出来了这个问题，所以，<code>Executors</code>下面用波浪线标记了出来。</p>\n<h3 id=\"代码智能搜索\"> 代码智能搜索</h3>\n<p>除了，在写代码的时候智能提示之外。你还可以直接选中代码然后搜索相关代码示例。</p>\n<p><img src=\"./pictures/Codota2.png\" alt=\"\" /></p>\n<h2 id=\"alibaba-java-code-guidelines-阿里巴巴-java-代码规范\"> Alibaba Java Code Guidelines：阿里巴巴 Java 代码规范</h2>\n<p>阿里巴巴 Java 代码规范，对应的Github地址为：<a href=\"https://github.com/alibaba/p3c\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/alibaba/p3c</a> 。非常推荐安装！</p>\n<p>安装完成之后建议将与语言替换成中文，提示更加友好一点。</p>\n<p><img src=\"./pictures/p3c/Alibaba-Java-Code-Guidelines2.png\" alt=\"\" /></p>\n<p>根据官方描述：</p>\n<blockquote>\n<p>目前这个插件实现了开发手册中的的53条规则，大部分基于PMD实现，其中有4条规则基于IDEA实现，并且基于IDEA <a href=\"https://www.jetbrains.com/help/idea/code-inspection.html\" target=\"_blank\" rel=\"noopener noreferrer\">Inspection</a>实现了实时检测功能。部分规则实现了Quick Fix功能，对于可以提供Quick Fix但没有提供的，我们会尽快实现，也欢迎有兴趣的同学加入进来一起努力。 目前插件检测有两种模式：实时检测、手动触发。</p>\n</blockquote>\n<p>上述提到的开发手册也就是在Java开发领域赫赫有名的《阿里巴巴Java开发手册》。</p>\n<h3 id=\"手动配置检测规则\"> 手动配置检测规则</h3>\n<p>你还可以手动配置相关 inspection规则：</p>\n<p><img src=\"./pictures/p3c/Alibaba-Java-Code-Guidelines3.png\" alt=\"\" /></p>\n<h3 id=\"使用效果\"> 使用效果</h3>\n<p>这个插件会实时检测出我们的代码不匹配它的规则的地方，并且会给出修改建议。比如我们按照下面的方式去创建线程池的话，这个插件就会帮我们检测出来,如下图所示。</p>\n<p><img src=\"./pictures/p3c/Alibaba-Java-Code-Guidelines1.png\" alt=\"\" /></p>\n<p>这个可以对应上 《阿里巴巴Java开发手册》 这本书关于创建线程池的方式说明。</p>\n<p><img src=\"./pictures/p3c/阿里巴巴开发手册-线程池创建.png\" alt=\"\" /></p>\n<h2 id=\"checkstyle-java代码格式规范\"> CheckStyle: Java代码格式规范</h2>\n<h3 id=\"为何需要checkstyle插件\"> 为何需要CheckStyle插件？</h3>\n<p><strong>CheckStyle 几乎是 Java 项目开发必备的一个插件了，它会帮助我们检查 Java 代码的格式是否有问题比如变量命名格式是否有问题、某一行代码的长度是否过长等等。</strong></p>\n<p>在项目上，<strong>通过项目开发人员自我约束来规范代码格式必然是不靠谱的！</strong> 因此，我们非常需要这样一款工具来帮助我们规范代码格式。</p>\n<p>如果你看过我写的轮子的话，可以发现我为每一个项目都集成了 CheckStyle，并且设置了 <strong>Git Commit 钩子</strong>，保证在提交代码之前代码格式没有问题。</p>\n<blockquote>\n<p><strong>Guide哥造的轮子</strong>（<em>代码简洁，结构清晰，欢迎学习，欢迎一起完善</em>）：</p>\n<ol>\n<li><a href=\"https://github.com/Snailclimb/guide-rpc-framework\" target=\"_blank\" rel=\"noopener noreferrer\">guide-rpc-framework</a> ：A custom RPC framework implemented by Netty+Kyro+Zookeeper.（一款基于 Netty+Kyro+Zookeeper 实现的自定义 RPC 框架-附详细实现过程和相关教程）</li>\n<li><a href=\"https://github.com/Snailclimb/jsoncat\" target=\"_blank\" rel=\"noopener noreferrer\">jsoncat</a> ：仿 Spring Boot 但不同于 Spring Boot 的一个轻量级的 HTTP 框架</li>\n</ol>\n<p><strong>Git 钩子</strong>： Git 能在特定的重要动作比如commit、push发生时触发自定义脚本。 钩子都被存储在 Git 目录下的 <code>hooks</code> 子目录中。 也即绝大部分项目中的 <code>.git/hooks</code> 。</p>\n</blockquote>\n<h3 id=\"如何在maven-gradle项目中集成-checksytle\"> 如何在Maven/Gradle项目中集成 Checksytle?</h3>\n<p>一般情况下，我们都是将其集成在项目中，并设置相应的 Git 钩子。网上有相应的介绍文章，这里就不多提了。</p>\n<p>如果你觉得网上的文章不直观的话，可以参考我上面提到了两个轮子：</p>\n<ol>\n<li><a href=\"https://github.com/Snailclimb/guide-rpc-framework\" target=\"_blank\" rel=\"noopener noreferrer\">guide-rpc-framework</a> ：Maven项目集成 Checksytle。</li>\n<li><a href=\"https://github.com/Snailclimb/jsoncat\" target=\"_blank\" rel=\"noopener noreferrer\">jsoncat</a>  ：Gradle项目集成 Checksytle。</li>\n</ol>\n<p>如果你在项目中集成了 Checksytle 的话，每次检测会生成一个 HTML格式的文件告诉你哪里的代码格式不对，这样看着非常不直观。通过  Checksytle插件的话可以非常直观的将项目中存在格式问题的地方显示出来。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/IDEA插件/image-20201013135044410.png\" alt=\"\" /></p>\n<p>如果你只是自己在本地使用，并不想在项目中集成 Checksytle 的话也可以，只需要下载一个 Checksytle插件就足够了。</p>\n<h3 id=\"如何安装\"> 如何安装？</h3>\n<p>我们直接在 IDEA 的插件市场即可找到这个插件。我这里已经安装好了。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/IDEA插件/image-20201013103610557.png\" alt=\"\" /></p>\n<p>安装插件之后重启 IDEA，你会发现就可以在底部菜单栏找到 CheckStyle 了。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/IDEA插件/image-20201013134644991.png\" alt=\"\" /></p>\n<h3 id=\"如何自定义检测规则\"> 如何自定义检测规则？</h3>\n<p>如果你需要自定义代码格式检测规则的话，可以按照如下方式进行配置（你可以导入用于自定义检测规则的<code>CheckStyle.xml</code>文件）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/IDEA插件/setting-check-style.png\" alt=\"\" /></p>\n<h3 id=\"使用效果-2\"> 使用效果</h3>\n<p>配置完成之后，按照如下方式使用这个插件！</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/IDEA插件/run-check-style.png\" alt=\"run-check-style\" /></p>\n<p>可以非常清晰的看到：CheckStyle 插件已经根据我们自定义的规则将项目中的代码存在格式问题的地方都检测了出来。</p>\n<h2 id=\"sonarlint-帮你优化代码\"> SonarLint:帮你优化代码</h2>\n<p>SonarLint 帮助你发现代码的错误和漏洞，就像是代码拼写检查器一样，SonarLint 可以实时显示出代码的问题，并提供清晰的修复指导，以便你提交代码之前就可以解决它们。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-2@main/系统设计/image-20201019222817359.png\" alt=\"\" /></p>\n<p>并且，很多项目都集成了 SonarQube,SonarLint 可以很方便地与 SonarQube 集成。</p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "IDEA主题推荐",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/idea-themes/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/idea-themes/",
      "content_html": "<p>经常有小伙伴问我：“Guide哥，你的IDEA 主题怎么这么好看，能推荐一下不？”。就实在有点不耐烦了，才索性写了这篇文章。</p>\n<p>在这篇文章中，我精选了几个比较是和 Java 编码的 IDEA 主题供小伙伴们选择。另外，我自己用的是 One Dark theme 这款。</p>\n<p><strong>注意：以下主题按照使用人数降序排序。</strong></p>\n<h2 id=\"material-theme-ui\"> <a href=\"https://plugins.jetbrains.com/plugin/8006-material-theme-ui\" target=\"_blank\" rel=\"noopener noreferrer\">Material Theme UI</a></h2>\n<p><strong>推荐指数</strong> ：⭐⭐⭐⭐</p>\n<p>这是 IDEA 中使用人数最多的一款主题。</p>\n<p>当你安装完这个插件之后，你会发现这个主题本身又提供了多种相关的主题供你选择。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20/image-20201119182935201.png\" alt=\"\" /></p>\n<p><strong>Material Deep Ocean</strong> 这款的效果图如下。默认的字体是真的小，小伙伴们需要自行调整一下。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20/image-20201119183044068.png\" alt=\"\" /></p>\n<h2 id=\"one-dark-theme\"> <a href=\"https://plugins.jetbrains.com/plugin/11938-one-dark-theme\" target=\"_blank\" rel=\"noopener noreferrer\">One Dark theme</a></h2>\n<p><strong>推荐指数</strong> ：⭐⭐⭐⭐⭐</p>\n<p>我比较喜欢的一款（<em>黄色比较多？</em>）。 没有花里花哨，简单大气，看起来比较舒服。颜色搭配也很棒，适合编码！</p>\n<p>这款主题的效果图如下。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20-11/image-20201119180300975.png\" alt=\"\" /></p>\n<h2 id=\"gradianto\"> <a href=\"https://plugins.jetbrains.com/plugin/12334-gradianto\" target=\"_blank\" rel=\"noopener noreferrer\">Gradianto</a></h2>\n<p><strong>推荐指数</strong> ：⭐⭐⭐⭐⭐</p>\n<p>Gradianto这个主题的目标是在保持页面色彩比较层次分明的情况下，让我们因为代码而疲惫的双眼更加轻松。</p>\n<p>Gradianto附带了自然界的渐变色，看着挺舒服的。另外，这个主题本身也提供了多种相关的主题供你选择。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20/image-20201119183825753.png\" alt=\"\" /></p>\n<p><strong>Gradianto Nature Green</strong> 的效果图如下。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20/image-20201119183920889.png\" alt=\"\" /></p>\n<h2 id=\"dark-purple-theme\"> <a href=\"https://plugins.jetbrains.com/plugin/12100-dark-purple-theme\" target=\"_blank\" rel=\"noopener noreferrer\">Dark Purple Theme</a></h2>\n<p><strong>推荐指数</strong> ：⭐⭐⭐⭐⭐</p>\n<p>这是一款紫色色调的深色主题，喜欢紫色的小伙伴不要错过。</p>\n<p>这个主题的效果图如下。个人觉得整体颜色搭配的是比较不错的，适合编码！</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20-11/image-20201119184654132.png\" alt=\"\" /></p>\n<h2 id=\"hiberbee-theme\"> <a href=\"https://plugins.jetbrains.com/plugin/12118-hiberbee-theme\" target=\"_blank\" rel=\"noopener noreferrer\">Hiberbee Theme</a></h2>\n<p><strong>推荐指数</strong> ：⭐⭐⭐⭐⭐</p>\n<p>一款受到了  Monokai Pro 和 MacOS Mojave启发的主题，是一款色彩层次分明的深色主题。</p>\n<p>这个主题的效果图如下。看着也是非常赞！适合编码！</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20-11/image-20201119191441248.png\" alt=\"\" /></p>\n<p>上面推荐的都是偏暗色系的主题，这里我再推荐两款浅色系的主题。</p>\n<h2 id=\"gray-theme\"> <a href=\"https://plugins.jetbrains.com/plugin/12103-gray-theme\" target=\"_blank\" rel=\"noopener noreferrer\">Gray Theme</a></h2>\n<p><strong>推荐指数</strong> ：⭐⭐⭐</p>\n<p>这是一款对比度比较低的一款浅色主题，不太适合代码阅读，毕竟这款主题是专门为在IntelliJ IDE中使用Markdown而设计的。</p>\n<p>这个主题的效果图如下。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20-11/image-20201119194512164.png\" alt=\"\" /></p>\n<h2 id=\"roboticket-light-theme\"> <a href=\"https://plugins.jetbrains.com/plugin/12191-roboticket-light-theme\" target=\"_blank\" rel=\"noopener noreferrer\">Roboticket Light Theme</a></h2>\n<p><strong>推荐指数</strong> ：⭐⭐⭐</p>\n<p>这是一款对比度比较低的浅色主题，不太适合代码阅读。</p>\n<p>这个主题的效果图如下。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/194581c7b72d49b512b12814340f00c8.png\" alt=\"\" /></p>\n<h2 id=\"后记\"> 后记</h2>\n<p>我个人还是比较偏爱深色系的主题。</p>\n<p>小伙伴们比较喜欢哪款主题呢？可以在评论区简单聊聊不？如果你还有其他比较喜欢的主题也可以在评论区说出来供大家参考哦！</p>\n",
      "image": "https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images-3@main/11-20/image-20201119182935201.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "jclasslib ：一款IDEA字节码查看神器",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/jclasslib/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/jclasslib/",
      "content_html": "<p>由于后面要分享的一篇文章中用到了这篇文章要推荐的一个插件，所以这里分享一下。非常实用！你会爱上它的！</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/计算机专业学习指南/image-20201013084919965.png\" alt=\"\" /></p>\n<p><strong>开始推荐 IDEA 字节码查看神器之前，先来回顾一下 Java 字节码是啥。</strong></p>\n<h2 id=\"何为-java-字节码\"> 何为 Java 字节码?</h2>\n<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>\n<p><strong>什么是字节码?采用字节码的好处是什么?</strong></p>\n<blockquote>\n<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>\n</blockquote>\n<p><strong>Java 程序从源代码到运行一般有下面 3 步：</strong></p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java 程序运行过程.png\" alt=\"Java程序运行过程\" /></p>\n<h2 id=\"为什么要查看-java-字节码\"> 为什么要查看 Java 字节码？</h2>\n<p>我们在平时学习的时候，经常需要查看某个 java 类的字节码文件。查看字节码文件更容易让我们搞懂 java 代码背后的原理比如搞懂 java 中的各种语法糖的本质。</p>\n<h2 id=\"如何查看-java-字节码\"> 如何查看 Java 字节码?</h2>\n<p>如果我们通过命令行来查看某个 class 的字节码文件的话，可以直接通过 <code>javap</code> 命令，不过这种方式太原始了，效率十分低，并且看起来不直观。</p>\n<p>下面介绍两种使用 IDEA 查看类对应字节码文件的方式（<em><code>javap</code>这种方式就不提了</em>）。</p>\n<p>我们以这段代码作为案例:</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Integer</span> i <span>=</span> <span>null</span><span>;</span>\n        <span>Boolean</span> flag <span>=</span> <span>false</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>flag <span>?</span> <span>0</span> <span>:</span> i<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面这段代码由于使用三目运算符不当导致诡异了 NPE 异常。为了搞清楚事情的原因，我们来看其对应的字节码。</p>\n<h3 id=\"使用-idea-自带功能\"> 使用 IDEA 自带功能</h3>\n<p>我们点击 <code>View -&gt; Show Bytecode</code> 即可通过 IDEA 查看某个类对应的字节码文件。</p>\n<blockquote>\n<p>需要注意的是：<strong>查看某个类对应的字节码文件之前确保它已经被编译过。</strong></p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/IDEA插件/image-20201012143530226.png\" alt=\"使用IDEA自带功能查看Java字节码\" /></p>\n<p>稍等几秒钟之后，你就可以直观到看到对应的类的字节码内容了。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/2020-10/image-20201012145127465.png\" alt=\"\" /></p>\n<p>从字节码中可以看出，我圈出来的位置发生了 <strong>拆箱操作</strong> 。</p>\n<blockquote>\n<ul>\n<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>\n<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>\n</ul>\n</blockquote>\n<p>详细解释下就是：<code>flag ? 0 : i</code> 这行代码中，0 是基本数据类型 int，返回数据的时候 i 会被强制拆箱成 int 类型，由于 i 的值是 null，因此就抛出了 NPE 异常。</p>\n<div><pre><code><span>Integer</span> i <span>=</span> <span>null</span><span>;</span>\n<span>Boolean</span> flag <span>=</span> <span>false</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>flag <span>?</span> <span>0</span> <span>:</span> i<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果，我们把代码中 <code>flag</code> 变量的值修改为 true 的话，就不会存在 NPE 问题了，因为会直接返回 0，不会进行拆箱操作。</p>\n<h3 id=\"使用-idea-插件-jclasslib-推荐\"> 使用 IDEA 插件 jclasslib(推荐)</h3>\n<p>相比于 IDEA 自带的查看类字节的功能，我更推荐 <code>jclasslib</code> 这个插件，非常棒！</p>\n<p><strong>使用 <code>jclasslib</code> 不光可以直观地查看某个类对应的字节码文件，还可以查看类的基本信息、常量池、接口、属性、函数等信息。</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/2020-10/image-20201012145646086.png\" alt=\"\" /></p>\n<p>我们直接在 IDEA 的插件市场即可找到这个插件。我这里已经安装好了。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/2020-10-12/image-20201012145900911.png\" alt=\"\" /></p>\n<p>安装完成之后，重启 IDEA。点击<code>View -&gt; Show Bytecode With jclasslib</code> 即可通过<code>jclasslib</code> 查看某个类对应的字节码文件。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/计算机专业学习指南/image-20201012150252106.png\" alt=\"使用IDEA插件jclasslib查看类的字节码\" /></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/image-20201013084919965.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "RestfulToolkit：RESTful Web 服务辅助开发工具",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/rest-devlop/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/rest-devlop/",
      "content_html": "<p>开始推荐这个 IDEA 插件之前，我觉得有必要花一小会时间简单聊聊 <strong>REST</strong> 这个我们经常打交道的概念。</p>\n<h2 id=\"rest-相关概念解读\"> REST 相关概念解读</h2>\n<h3 id=\"何为-rest\"> 何为 REST？</h3>\n<p>REST 即 <strong>REpresentational State Transfer</strong> 的缩写。这个词组的翻译过来就是&quot;<strong>表现层状态转化</strong>&quot;。</p>\n<p>这样理解起来甚是晦涩，实际上 REST 的全称是 <strong>Resource Representational State Transfer</strong> ，直白地翻译过来就是 <strong>“资源”在网络传输中以某种“表现形式”进行“状态转移”</strong> 。</p>\n<p><strong>有没有感觉很难理解？</strong></p>\n<p>没关系，看了我对 REST 涉及到的一些概念的解读之后你没准就能理解了！</p>\n<ul>\n<li><strong>资源（Resource）</strong> ：我们可以把真实的对象数据称为资源。一个资源既可以是一个集合，也可以是单个个体。比如我们的班级 classes 是代表一个集合形式的资源，而特定的 class 代表单个个体资源。每一种资源都有特定的 URI（统一资源定位符）与之对应，如果我们需要获取这个资源，访问这个 URI 就可以了，比如获取特定的班级：<code>/class/12</code>。另外，资源也可以包含子资源，比如 <code>/classes/classId/teachers</code>：列出某个指定班级的所有老师的信息</li>\n<li><strong>表现形式（Representational）</strong>：&quot;资源&quot;是一种信息实体，它可以有多种外在表现形式。我们把&quot;资源&quot;具体呈现出来的形式比如 json，xml，image,txt 等等叫做它的&quot;表现层/表现形式&quot;。</li>\n<li><strong>状态转移（State Transfer）</strong> ：大家第一眼看到这个词语一定会很懵逼？内心 BB：这尼玛是啥啊？ <strong>大白话来说 REST 中的状态转移更多地描述的服务器端资源的状态，比如你通过增删改查（通过 HTTP 动词实现）引起资源状态的改变。</strong> （HTTP 协议是一个无状态的，所有的资源状态都保存在服务器端）</li>\n</ul>\n<h3 id=\"何为-restful-架构\"> 何为 RESTful 架构？</h3>\n<p>满足 REST 风格的架构设计就可以称为 RESTful 架构：</p>\n<ol>\n<li>每一个 URI 代表一种资源；</li>\n<li>客户端和服务器之间，传递这种资源的某种表现形式比如 json，xml，image,txt 等等；</li>\n<li>客户端通过特定的 HTTP 动词，对服务器端资源进行操作，实现&quot;表现层状态转化&quot;。</li>\n</ol>\n<h3 id=\"何为-restful-web-服务\"> 何为 RESTful Web 服务？</h3>\n<p>基于 REST 架构的 Web 服务就被称为 RESTful Web 服务。</p>\n<h2 id=\"restful-web-服务辅助开发工具\"> RESTful Web 服务辅助开发工具</h2>\n<h3 id=\"安装\"> 安装</h3>\n<p>这个插件的名字叫做 “<strong>RestfulToolkit</strong>” 。我们直接在 IDEA 的插件市场即可找到这个插件。如下图所示。</p>\n<blockquote>\n<p>如果你因为网络问题没办法使用 IDEA 自带的插件市场的话，也可以通过<a href=\"https://plugins.jetbrains.com/idea\" target=\"_blank\" rel=\"noopener noreferrer\">IDEA 插件市场的官网</a>手动下载安装。</p>\n</blockquote>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41a9bfa18920403ba4db83e324f8621e~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" /></p>\n<h3 id=\"简单使用\"> 简单使用</h3>\n<h4 id=\"url-跳转到对应方法\"> URL 跳转到对应方法</h4>\n<p>根据 URL 直接跳转到对应的方法定义 (Windows: <code>ctrl+\\</code> or <code>ctrl+alt+n</code> Mac:<code>command+\\</code> or <code>command+alt+n</code> )并且提供了一个服务的树形可视化显示窗口。 如下图所示。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c26ea05ad472488fbf9eb21627964bee~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\" /></p>\n<h4 id=\"作为-http-请求工具\"> 作为 HTTP 请求工具</h4>\n<p>这个插件还可以作为一个简单的 http 请求工具来使用。如下图所示。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/RestfulToolkit2.png\" alt=\"\" /></p>\n<h4 id=\"复制生成-url、复制方法参数\"> 复制生成 URL、复制方法参数...</h4>\n<p>这个插件还提供了生成 URL、查询参数、请求体（RequestBody）等功能。</p>\n<p>举个例子。我们选中 <code>Controller</code> 中的某个请求对应的方法右击，你会发现多了几个可选项。当你选择<code>Generate &amp; Copy Full URL</code>的话，就可以把整个请求的路径直接复制下来。eg：<code>http://localhost:9333/api/users?pageNum=1&amp;pageSize=1</code> 。</p>\n<p><img src=\"./pictures/RestfulToolkit3.png\" alt=\"\" /></p>\n<h4 id=\"将-java-类转换为对应的-json-格式\"> 将 Java 类转换为对应的 JSON 格式</h4>\n<p>这个插件还为 Java 类上添加了 <strong>Convert to JSON</strong> 功能 。</p>\n<p>我们选中的某个类对应的方法然后右击，你会发现多了几个可选项。</p>\n<p><img src=\"./pictures/RestfulToolkit4.png\" alt=\"\" /></p>\n<p>当我们选择<code>Convert to JSON</code>的话，你会得到如下 json 类型的数据：</p>\n<div><pre><code><span>{</span>\n  <span>\"username\"</span><span>:</span> <span>\"demoData\"</span><span>,</span>\n  <span>\"password\"</span><span>:</span> <span>\"demoData\"</span><span>,</span>\n  <span>\"rememberMe\"</span><span>:</span> <span>true</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"后记\"> 后记</h2>\n<p>RESTFulToolkit 原作者不更新了，IDEA.201 及以上版本不再适配。</p>\n<p>因此，国内就有一个大佬参考 RESTFulToolkit 开发了一款类似的插件——RestfulTool（功能较少一些，不过够用了）。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20210830112030237.png\" alt=\"\" /></p>\n",
      "image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41a9bfa18920403ba4db83e324f8621e~tplv-k3u1fbpfcp-zoom-1.image",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "Maven Helper：解决 Maven 依赖冲突问题",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/maven-helper/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/maven-helper/",
      "content_html": "<p><strong>Maven Helper</strong> 主要用来分析 Maven 项目的相关依赖，可以帮助我们解决 Maven 依赖冲突问题。</p>\n<p><img src=\"./pictures/maver-helper.png\" alt=\"\" /></p>\n<p><strong>何为依赖冲突？</strong></p>\n<p>说白了就是你的项目使用的 2 个 jar 包引用了同一个依赖 h，并且 h 的版本还不一样,这个时候你的项目就存在两个不同版本的 h。这时 Maven 会依据依赖路径最短优先原则，来决定使用哪个版本的 Jar 包，而另一个无用的 Jar 包则未被使用，这就是所谓的依赖冲突。</p>\n<p>大部分情况下，依赖冲突可能并不会对系统造成什么异常，因为 Maven 始终选择了一个 Jar 包来使用。但是，不排除在某些特定条件下，会出现类似找不到类的异常，所以，只要存在依赖冲突，在我看来，最好还是解决掉，不要给系统留下隐患。</p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "Save Actions：优化文件保存",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/save-actions/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/save-actions/",
      "content_html": "<p>真必备插件！可以帮助我们在保存文件的时候：</p>\n<ol>\n<li>优化导入；</li>\n<li>格式化代码；</li>\n<li>执行一些quick fix</li>\n<li>......</li>\n</ol>\n<p>这个插件是支持可配置的，我的配置如下：</p>\n<p><img src=\"./pictures/save-actions/save-actions.png\" alt=\"\" /></p>\n<p>实际使用效果如下：</p>\n<p><img src=\"./pictures/save-actions/save-actions2.gif\" alt=\"\" /></p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "SequenceDiagram：一键可以生成时序图",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/sequence-diagram/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/sequence-diagram/",
      "content_html": "<p>在平时的学习/工作中，我们会经常面临如下场景：</p>\n<ol>\n<li>阅读别人的代码</li>\n<li>阅读框架源码</li>\n<li>阅读自己很久之前写的代码。</li>\n</ol>\n<p>千万不要觉得工作就是单纯写代码，实际工作中，你会发现你的大部分时间实际都花在了阅读和理解已有代码上。</p>\n<p>为了能够更快更清晰地搞清对象之间的调用关系，我经常需要用到序列图。手动画序列图还是很麻烦费时间的，不过 IDEA 提供了一个叫做<strong>SequenceDiagram</strong> 的插件帮助我们解决这个问题。通过 SequenceDiagram 这个插件，我们一键可以生成时序图。</p>\n<h2 id=\"何为序列图\"> 何为序列图？</h2>\n<p>网上对于序列图的定义有很多，我觉得都不太好理解，太抽象了。最神奇的是，大部分文章对于序列图的定义竟然都是一模一样，看来大家是充分发挥了写代码的“精髓”啊！</p>\n<p>我还是简单说一说我的理解吧！不过，说实话，我自己对于 Sequence Diagram 也不是很明朗。下面的描述如有问题和需要完善的地方，还请指出。</p>\n<blockquote>\n<p><strong>序列图</strong>（Sequence Diagram），亦称为<strong>循序图</strong>，是一种<a href=\"https://zh.m.wikipedia.org/wiki/UML\" target=\"_blank\" rel=\"noopener noreferrer\">UML</a>行为图。表示系统执行某个方法/操作（如登录操作）时，对象之间的顺序调用关系。</p>\n<p>这个顺序调用关系可以这样理解：你需要执行系统中某个对象 a 提供的方法/操作 login（登录），但是这个对象又依赖了对象 b 提供的方法 getUser(获取用户)。因此，这里就有了 a -&gt; b 调用关系之说。</p>\n</blockquote>\n<p>再举两个例子来说一下！</p>\n<p>下图是微信支付的业务流程时序图。这个图描述了微信支付相关角色（顾客，商家...）在微信支付场景下，基础支付和支付的的顺序调用关系。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3a48c8d17aea2064ff11b6d3fd1fb2cb.png\" alt=\"\" /></p>\n<p>下图是我写的一个 HTTP 框架中的执行某个方法的序列图。这个图描述了我们在调用 <code>InterceptorFactory</code>类的 <code>loadInterceptors()</code> 方法的时候，所涉及到的类之间的调用关系。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70.png\" alt=\"\" /></p>\n<p>另外，国内一般更喜欢称呼序列图为&quot;时序图&quot;。</p>\n<ul>\n<li>如果你按照纯翻译的角度来说， sequence 这个单词并无&quot;时间&quot;的意思，只有序列，顺序等意思，因此也有人说“时序图”的说法是不准确的。</li>\n<li>如果从定义角度来说，时序图这个描述是没问题的。因为 Sequence Diagram 中每条消息的触发时机确实是按照时间顺序执行的。</li>\n</ul>\n<p>我觉得称呼 Sequence Diagram 为时序图或者序列图都是没问题的，不用太纠结。</p>\n<h2 id=\"哪些场景下需要查看类的时序图\"> 哪些场景下需要查看类的时序图?</h2>\n<p>我们在很多场景下都需要时序图，比如说：</p>\n<ol>\n<li><strong>阅读源码</strong> ：阅读源码的时候，你可能需要查看调用目标方法涉及的相关类的调用关系。特别是在代码的调用层级比较多的时候，对于我们理解源码非常有用。（<em>题外话：实际工作中，大部分时间实际我们都花在了阅读理解已有代码上。</em>）</li>\n<li><strong>技术文档编写</strong> ：我们在写项目介绍文档的时候，为了让别人更容易理解你的代码，你需要根据核心方法为相关的类生成时序图来展示他们之间的调用关系。</li>\n<li><strong>梳理业务流程</strong> ：当我们的系统业务流程比较复杂的时候，我们可以通过序列图将系统中涉及的重要的角色和对象的之间关系可视化出来。</li>\n<li>......</li>\n</ol>\n<h2 id=\"如何使用-idea-根据类中方法生成时序图\"> 如何使用 IDEA 根据类中方法生成时序图？</h2>\n<p><strong>通过 SequenceDiagram 这个插件，我们一键可以生成时序图。</strong></p>\n<p>并且，你还可以：</p>\n<ol>\n<li>点击时序图中的类/方法即可跳转到对应的地方。</li>\n<li>从时序图中删除对应的类或者方法。</li>\n<li>将生成的时序图导出为 PNG 图片格式。</li>\n</ol>\n<h3 id=\"安装\"> 安装</h3>\n<p>我们直接在 IDEA 的插件市场即可找到这个插件。我这里已经安装好了。</p>\n<blockquote>\n<p>如果你因为网络问题没办法使用 IDEA 自带的插件市场的话，也可以通过<a href=\"https://plugins.jetbrains.com/idea\" target=\"_blank\" rel=\"noopener noreferrer\">IDEA 插件市场的官网</a>手动下载安装。</p>\n</blockquote>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20201021165654262.png\" alt=\"\" /></p>\n<h3 id=\"简单使用\"> 简单使用</h3>\n<ol>\n<li>选中方法名（注意不要选类名），然后点击鼠标右键，选择 <strong>Sequence Diagram</strong> 选项即可！</li>\n</ol>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20201021170110697-20211010211819042.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>配置生成的序列图的一些基本的参数比如调用深度之后，我们点击 ok 即可！</li>\n</ol>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/c5040f1105c762ddf8689892913bc02d-20211010211823985.png\" alt=\"\" /></p>\n<p>你还可以通过生成的时序图来定位到相关的代码，这对于我们阅读源码的时候尤其有帮助！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20201021171623809-20211010211828759.png\" alt=\"\" /></p>\n<p>时序图生成完成之后，你还可以选择将其导出为图片。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20201021170228723-20211010211832965.png\" alt=\"\" /></p>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/3a48c8d17aea2064ff11b6d3fd1fb2cb.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "IDEA 快捷键相关插件",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/shortcut-key/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/shortcut-key/",
      "content_html": "<p>相信我！下面这两个一定是IDEA必备的插件。</p>\n<h2 id=\"key-promoter-x-快捷键提示\"> Key Promoter X:快捷键提示</h2>\n<p>这个插件的功能主要是<strong>在你本可以使用快捷键操作的地方提醒你用快捷键操作。</strong></p>\n<p>举个例子。我直接点击tab栏下的菜单打开 Version Control(版本控制) 的话，这个插件就会提示你可以用快捷键 <code>command+9</code>或者<code>shift+command+9</code>打开。如下图所示。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/source-code/dubbo/Key-Promoter-X1.png\" alt=\"\" /></p>\n<p>除了这个很棒的功能之外，这个插件还有一个功能我觉得非常棒。</p>\n<p>它可以展示出哪些快捷键你忘记使用的次数最多！这样的话，你可以给予你忘记次数最多的那些快捷键更多的关注。</p>\n<p>我忘记最多的快捷键是debug的时候经常使用的 F8（Step Over）。如下图所示。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/source-code/dubbo/Key-Promoter-X2.png\" alt=\"\" /></p>\n<p>关于快捷键，很多人不愿意去记，觉得单纯靠鼠标就完全够了。</p>\n<p>让我来说的话！我觉得如果你偶尔使用一两次 IDEA 的话，你完全没有必要纠结快捷键。</p>\n<p>但是，如果 IDEA 是你开发的主力，你经常需要使用的话，相信我，掌握常用的一些快捷键真的很重要！</p>\n<p>不说多的，<strong>熟练掌握IDEA的一些最常见的快捷键，你的工作效率至少提升 30 %。</strong></p>\n<p><strong>除了工作效率的提升之外，使用快捷键会让我们显得更加专业。</strong></p>\n<p>你在使用快捷键进行操作的时候，是很帅，很酷啊！但是，当你用 IDEA 给别人演示一些操作的时候，你使用了快捷键的话，别人可能根本不知道你进行了什么快捷键操作。</p>\n<p><strong>怎么解决这个问题呢？</strong></p>\n<p>很简单！这个时候就轮到 <strong>Presentation Assistant</strong> 这个插件上场了！</p>\n<h2 id=\"presentation-assistant-快捷键展示\"> Presentation Assistant:快捷键展示</h2>\n<p>安装这个插件之后，你使用的快捷键操作都会被可视化地展示出来，非常适合自己在录制视频或者给别人展示代码的时候使用。</p>\n<p>举个例子。我使用快捷键 <code>command+9</code>打开 Version Control ，使用了这个插件之后的效果如下图所示。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/source-code/dubbo/Presentation-Assistant.gif\" alt=\"\" /></p>\n<p>从上图可以很清晰地看到，IDEA 的底部中间的位置将我刚刚所使用的快捷键给展示了出来。</p>\n<p>并且，<strong>这个插件会展示出 Mac 和 Win/Linux 两种不同的版本的快捷键。</strong></p>\n<p>因此，不论你的操作系统是 Mac 还是 Win/Linux ，这款插件都能满足你的需求。</p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/source-code/dubbo/Key-Promoter-X1.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "Translation：翻译",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/translation/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-plugins/translation/",
      "content_html": "<p>有了这个插件之后，你再也不用在编码的时候打开浏览器查找某个单词怎么拼写、某句英文注释什么意思了。</p>\n<p>并且，这个插件支持多种翻译源：</p>\n<ol>\n<li>Google 翻译</li>\n<li>Youdao 翻译</li>\n<li>Baidu 翻译</li>\n</ol>\n<p>除了翻译功能之外还提供了语音朗读、单词本等实用功能。这个插件的Github地址是：<a href=\"https://github.com/YiiGuxing/TranslationPlugin\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/YiiGuxing/TranslationPlugin</a> （貌似是国人开发的，很赞）。</p>\n<p><strong>使用方法很简单！选中你要翻译的单词或者句子，使用快捷键 <code>command+ctrl+u(mac)</code> / <code>shift+ctrl+y(win/linux)</code></strong> （如果你忘记了快捷的话，鼠标右键操作即可！）</p>\n<p><img src=\"./pictures/translation/translation1.jpg\" alt=\"\" /></p>\n<p><strong>如果需要快速打开翻译框，使用快捷键<code>command+ctrl+i(mac)</code>/<code>ctrl + shift + o(win/linux)</code></strong></p>\n<p><img src=\"./pictures/translation/translation2.png\" alt=\"\" /></p>\n<p>如果你需要将某个重要的单词添加到生词本的话，只需要点击单词旁边的收藏按钮即可！</p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "IDEA 重构入门",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-tips/idea-refractor-intro/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-tips/idea-refractor-intro/",
      "content_html": "<h1 id=\"idea-重构入门\"> IDEA 重构入门</h1>\n<p>我们在使用 IDEA 进行重构之前，先介绍一个方便我们进行重构的快捷键：<code>ctrl+t(mac)/ctrl+shift+alt+t</code>（如果忘记快捷键的话，鼠标右键也能找到重构选项），使用这个快捷键可以快速调出常用重构的选项，如下图所示：</p>\n<p><img src=\"./pictures/refractor-help.png\" alt=\"\" /></p>\n<h3 id=\"重命名-rename\"> 重命名(rename)</h3>\n<p>快捷键：<strong>Shift + F6(mac) / Shift + F6(windows/Linux)：</strong> 对类、变量或者方法名重命名。</p>\n<p><img src=\"./pictures/rename.gif\" alt=\"重命名\" /></p>\n<h3 id=\"提取相关重构手段\"> 提取相关重构手段</h3>\n<p>这部分的快捷键实际很好记忆，我是这样记忆的:</p>\n<p>前面两个键位是  <code>command + option(mac) / ctrl + alt (Windows/Linux)</code> 是固定的，只有后面一个键位会变比如Extract constant (提取变量)就是 c（constant）、Extract variable (提取变量)就是 v(variable)。</p>\n<h4 id=\"提取常量-extract-constant\"> 提取常量(extract constant)</h4>\n<ol>\n<li><strong>使用场景</strong> ：提取未经过定义就直接出现的常量。提取常量使得你的编码更易读，避免硬编码。</li>\n<li><strong>快捷键：</strong>  <code>command + option+ c(mac)/ ctrl + alt + c(Windows/Linux)</code></li>\n</ol>\n<p><strong>示例：</strong></p>\n<p><img src=\"./pictures/exact/extract-constant.gif\" alt=\"\" /></p>\n<h4 id=\"提取参数-exact-parameter\"> 提取参数(exact parameter﻿)</h4>\n<ol>\n<li><strong>使用场景</strong> ：提取参数到方法中。</li>\n<li><strong>快捷键：</strong>  <code>command + option+ p(mac)/ ctrl + alt + p(Windows/Linux)</code></li>\n</ol>\n<p><img src=\"./pictures/exact/exact-parameter.gif\" alt=\"\" /></p>\n<h4 id=\"提取变量-exact-variable\"> 提取变量(exact variable)</h4>\n<ol>\n<li><strong>使用场景</strong> ：提取多次出现的表达式。</li>\n<li><strong>快捷键：</strong> <code>command + option+ v(mac) / ctrl + alt + v(Windows/Linux)</code></li>\n</ol>\n<p><strong>示例：</strong></p>\n<p><img src=\"./pictures/exact/exact-variable.gif\" alt=\"\" /></p>\n<h4 id=\"提取属性-exact-field\"> 提取属性(exact field)</h4>\n<ol>\n<li><strong>使用场景</strong> ：把当前表达式提取成为类的一个属性。</li>\n<li><strong>快捷键：</strong> <code>command + option+ f(mac) / ctrl + alt + f(Windows/Linux)</code></li>\n</ol>\n<p><strong>示例：</strong></p>\n<p><img src=\"./pictures/exact/exact-field.gif\" alt=\"\" /></p>\n<p><strong>示例：</strong></p>\n<p><img src=\"./pictures/exact/exact-variable.gif\" alt=\"\" /></p>\n<h4 id=\"提取方法-exact-method\"> 提取方法(exact method)</h4>\n<ol>\n<li><strong>使用场景</strong> ：1个或者多个表达式可以提取为一个方法。 提取方法也能使得你的编码更易读，更加语义化。</li>\n<li><strong>快捷键：</strong>  <code>command + option+ m(mac)/ ctrl + alt + m(Windows/Linux)</code></li>\n</ol>\n<p><strong>示例：</strong></p>\n<p><img src=\"./pictures/exact/exact-method.gif\" alt=\"\" /></p>\n<h4 id=\"提取接口-exact-interface\"> 提取接口(exact interface)</h4>\n<ol>\n<li><strong>使用场景</strong> ：想要把一个类中的1个或多个方法提取到一个接口中的时候。</li>\n<li><strong>快捷键：</strong>  <code>command + option+ m(mac)/ ctrl + alt + m(Windows/Linux)</code></li>\n</ol>\n<p><strong>示例：</strong></p>\n<p><img src=\"./pictures/exact/exact-interface.gif\" alt=\"\" /></p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": []
    },
    {
      "title": "IntelliJ IDEA 使用指南 | 必备插件推荐 | 插件开发入门 | 重构小技巧 | 源码阅读技巧",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/",
      "content_html": "<h1 id=\"intellij-idea-使用指南-必备插件推荐-插件开发入门-重构小技巧-源码阅读技巧\"> IntelliJ IDEA 使用指南 | 必备插件推荐 | 插件开发入门 | 重构小技巧 | 源码阅读技巧</h1>\n<p>分享一下自己使用 IDEA 的一些经验，希望对大家有帮助！</p>\n<ul>\n<li>Github 地址：https://github.com/CodingDocs/awesome-idea-tutorial</li>\n<li>码云地址：https://gitee.com/SnailClimb/awesome-idea-tutorial （Github 无法访问或者访问速度比较慢的小伙伴可以看码云上的对应内容）</li>\n</ul>\n<h2 id=\"技巧\"> 技巧</h2>\n<ul>\n<li><a href=\"./IDEA源码阅读技巧.html\">IDEA源码阅读技巧</a></li>\n<li><a href=\"./idea-refractor/使用IDEA进行重构.html\">IDEA重构小技巧</a></li>\n<li><a href=\"./IDEA插件开发入门.html\">IDEA插件开发入门</a></li>\n</ul>\n<h2 id=\"必备插件\"> 必备插件</h2>\n<p>安利一些好用的 IDEA 插件。</p>\n<h2 id=\"效率\"> 效率</h2>\n<ul>\n<li><a href=\"./idea-plugins/快捷键.html\">Key Promoter X:快捷键提示</a></li>\n<li><a href=\"./idea-plugins/快捷键.html\">Presentation Assistant:快捷键展示</a></li>\n<li><a href=\"./idea-plugins/Translation.html\">Translation：翻译</a></li>\n<li><a href=\"./idea-plugins/SaveActions.html\">Save Actions:优化保存操作</a></li>\n</ul>\n<h3 id=\"开发\"> 开发</h3>\n<ul>\n<li><a href=\"./idea-plugins/CamelCase.html\">CamelCase：多种命名格式之间切换</a></li>\n<li><a href=\"./idea-plugins/GitCommitTemplate.html\">Git Commit Template:使用模板创建commit信息</a></li>\n<li><a href=\"./idea-plugins/MavenHelper.html\">Maven Helper:分析Maven项目的相关依赖</a></li>\n<li><a href=\"./idea-plugins/GsonFormat.html\">GsonFormat：JSON转类对象</a></li>\n</ul>\n<h3 id=\"代码优化\"> 代码优化</h3>\n<ul>\n<li><a href=\"./idea-plugins/帮助你写好代码的IDEA插件.html\">Lombok:帮你简化代码</a></li>\n<li><a href=\"./idea-plugins/帮助你写好代码的IDEA插件.html\">Codota：代码智能提示</a></li>\n<li><a href=\"./idea-plugins/帮助你写好代码的IDEA插件.html\">Alibaba Java Code Guidelines：阿里巴巴 Java 代码规范</a></li>\n<li><a href=\"./idea-plugins/帮助你写好代码的IDEA插件.html\">CheckStyle: Java代码格式规范</a></li>\n<li><a href=\"./idea-plugins/帮助你写好代码的IDEA插件.html\">SonarLint:帮你优化代码</a></li>\n</ul>\n<h3 id=\"界面美化\"> 界面美化</h3>\n<ul>\n<li><a href=\"./idea-plugins/IDEA主题推荐.html\">IDEA 主题推荐</a></li>\n<li><a href=\"./idea-plugins/界面美化.html\">Background Image Plus:背景图片</a></li>\n<li><a href=\"./idea-plugins/界面美化.html\">Power Mode II : 代码特效</a></li>\n<li><a href=\"./idea-plugins/界面美化.html\">Nyan Progress Bar : 进度条美化</a></li>\n<li><a href=\"./idea-plugins/界面美化.html\">Grep Console:控制台输出处理</a></li>\n<li><a href=\"./idea-plugins/界面美化.html\">Rainbow Brackets : 彩虹括号</a></li>\n</ul>\n<h3 id=\"源码阅读\"> 源码阅读</h3>\n<ul>\n<li><a href=\"./idea-plugins/一款IDEA字节码查看神器.html\">jclasslib：一款快速查看Java字节码的神器!力荐！</a></li>\n<li><a href=\"./idea-plugins/SequenceDiagram.html\">SequenceDiagram：一键生成方法的时序图</a></li>\n<li><a href=\"./idea-plugins/项目代码统计.html\">Statistic：项目代码统计</a></li>\n<li><a href=\"./idea-plugins/CodeGlance.html\">CodeGlance:代码微型地图</a></li>\n</ul>\n<h3 id=\"其他\"> 其他</h3>\n<ol>\n<li><strong>leetcode editor</strong> :提供在线 Leetcode 刷题功能，比较方便我们刷题，不过我试用之后发现有一些小 bug，个人感觉还是直接在网站找题目刷来的痛快一些。</li>\n<li><strong>​A Search with Github</strong> ：直接通过 Github搜索相关代码。</li>\n<li><strong>stackoverflow</strong> : 选中相关内容后单击右键即可快速跳转到 stackoverflow 。</li>\n<li><strong>CodeStream</strong> ：让code review变得更加容易。</li>\n<li><strong>Code screenshots</strong> ：代码片段保存为图片。</li>\n<li><strong>GitToolBox</strong> :Git工具箱</li>\n<li><strong>OK,​ Gradle!</strong> ：搜索Java库用于Gradle项目</li>\n<li><strong>Java Stream Debugger</strong> : Java8 Stream调试器</li>\n<li><strong>EasyCode</strong> : Easycode 可以直接对数据的表生成entity、controller、service、dao、mapper无需任何编码，简单而强大。更多内容可以查看这篇文章：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486205&amp;idx=1&amp;sn=0ff2f87f0d82a1bd9c0c44328ef69435&amp;chksm=cea24536f9d5cc20c6cc7669f0d4167d747fe8b8c05a64546c0162d694aa96044a2862e24b57&amp;token=1862674725&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">《懒人 IDEA 插件插件:EasyCode 一键帮你生成所需代码~》</a></li>\n<li><strong>JFormDesigner</strong> ：Swing GUI 在线编辑器。</li>\n<li><strong>VisualVM Launcher</strong> ： Java性能分析神器。</li>\n<li>......</li>\n</ol>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "IDEA指南"
      ]
    },
    {
      "title": "IDEA 插件开发入门",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-tips/idea-plug-in-development-intro/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-tips/idea-plug-in-development-intro/",
      "content_html": "<h1 id=\"idea-插件开发入门\"> IDEA 插件开发入门</h1>\n<p>我这个人没事就喜欢推荐一些好用的 <a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1319419426898329600&amp;__biz=Mzg2OTA0Njk0OA==#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">IDEA 插件</a>给大家。这些插件极大程度上提高了我们的生产效率以及编码舒适度。</p>\n<p><strong>不知道大家有没有想过自己开发一款 IDEA 插件呢？</strong></p>\n<p>我自己想过，但是没去尝试过。刚好有一位读者想让我写一篇入门 IDEA 开发的文章，所以，我在周末就花了一会时间简单了解一下。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201118071711216.png\" alt=\"\" /></p>\n<p>不过，<strong>这篇文章只是简单带各位小伙伴入门一下 IDEA 插件开发</strong>，个人精力有限，暂时不会深入探讨太多。如果你已经有 IDEA 插件开发的相关经验的话，这篇文章就可以不用看了，因为会浪费你 3 分钟的时间。</p>\n<p>好的废话不多说！咱们直接开始!</p>\n<h2 id=\"_01-新建一个基于-gradle-的插件项目\"> 01 新建一个基于 Gradle 的插件项目</h2>\n<p>这里我们基于 Gradle 进行插件开发，这也是 IntelliJ 官方的推荐的插件开发解决方案。</p>\n<p><strong>第一步，选择 Gradle 项目类型并勾选上相应的依赖。</strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/1.png\" alt=\"选择 Gradle 项目类型并勾选上相应的依赖\" /></p>\n<p><strong>第二步，填写项目相关的属性比如 GroupId、ArtifactId。</strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/2.png\" alt=\"填写项目相关的属性\" /></p>\n<p><strong>第三步，静静等待项目下载相关依赖。</strong></p>\n<p>第一次创建 IDEA 插件项目的话，这一步会比较慢。因为要下载 IDEA 插件开发所需的 SDK 。</p>\n<h2 id=\"_02-插件项目结构概览\"> 02 插件项目结构概览</h2>\n<p>新建完成的项目结构如下图所示。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/插件项目结构概览.png\" alt=\"插件项目结构概览\" /></p>\n<p>这里需要额外注意的是下面这两个配置文件。</p>\n<p><strong><code>plugin.xml</code> ：插件的核心配置文件。通过它可以配置插件名称、插件介绍、插件作者信息、Action 等信息。</strong></p>\n<div><pre><code><span><span><span>&lt;</span>idea-plugin</span><span>></span></span>\n    <span><span><span>&lt;</span>id</span><span>></span></span>github.javaguide.my-first-idea-plugin<span><span><span>&lt;/</span>id</span><span>></span></span>\n    <span>&lt;!--插件的名称--></span>\n    <span><span><span>&lt;</span>name</span><span>></span></span>Beauty<span><span><span>&lt;/</span>name</span><span>></span></span>\n    <span>&lt;!--插件的作者相关信息--></span>\n    <span><span><span>&lt;</span>vendor</span> <span>email</span><span><span>=</span><span>\"</span>koushuangbwcx@163.com<span>\"</span></span> <span>url</span><span><span>=</span><span>\"</span>https://github.com/Snailclimb<span>\"</span></span><span>></span></span>JavaGuide<span><span><span>&lt;/</span>vendor</span><span>></span></span>\n    <span>&lt;!--插件的介绍--></span>\n    <span><span><span>&lt;</span>description</span><span>></span></span><span>&lt;![CDATA[\n     Guide哥代码开发的第一款IDEA插件&lt;br>\n    &lt;em>这尼玛是什么垃圾插件！！！&lt;/em>\n    ]]></span><span><span><span>&lt;/</span>description</span><span>></span></span>\n\n    <span>&lt;!-- please see https://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/plugin_compatibility.html\n         on how to target different products --></span>\n    <span><span><span>&lt;</span>depends</span><span>></span></span>com.intellij.modules.platform<span><span><span>&lt;/</span>depends</span><span>></span></span>\n\n    <span><span><span>&lt;</span>extensions</span> <span>defaultExtensionNs</span><span><span>=</span><span>\"</span>com.intellij<span>\"</span></span><span>></span></span>\n        <span>&lt;!-- Add your extensions here --></span>\n    <span><span><span>&lt;/</span>extensions</span><span>></span></span>\n\n    <span><span><span>&lt;</span>actions</span><span>></span></span>\n        <span>&lt;!-- Add your actions here --></span>\n    <span><span><span>&lt;/</span>actions</span><span>></span></span>\n<span><span><span>&lt;/</span>idea-plugin</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong><code>build.gradle</code> ：项目依赖配置文件。通过它可以配置项目第三方依赖、插件版本、插件版本更新记录等信息。</strong></p>\n<div><pre><code>plugins <span>{</span>\n    id <span>'java'</span>\n    id <span>'org.jetbrains.intellij'</span> version <span>'0.6.3'</span>\n<span>}</span>\n\ngroup <span>'github.javaguide'</span>\n<span>// 当前插件版本</span>\nversion <span>'1.0-SNAPSHOT'</span>\n\nrepositories <span>{</span>\n    <span>mavenCentral</span><span>(</span><span>)</span>\n<span>}</span>\n\n<span>// 项目依赖</span>\ndependencies <span>{</span>\n    testCompile group<span>:</span> <span>'junit'</span><span>,</span> name<span>:</span> <span>'junit'</span><span>,</span> version<span>:</span> <span>'4.12'</span>\n<span>}</span>\n\n<span>// See https://github.com/JetBrains/gradle-intellij-plugin/</span>\n<span>// 当前开发该插件的 IDEA 版本</span>\nintellij <span>{</span>\n    version <span>'2020.1.2'</span>\n<span>}</span>\npatchPluginXml <span>{</span>\n    <span>// 版本更新记录</span>\n    changeNotes <span>\"\"\"\n      Add change notes here.&lt;br>\n      &lt;em>most HTML tags may be used&lt;/em>\"\"\"</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>没有开发过 IDEA 插件的小伙伴直接看这两个配置文件内容可能会有点蒙。所以，我专门找了一个 IDEA 插件市场提供的现成插件来说明一下。小伙伴们对照下面这张图来看下面的配置文件内容就非常非常清晰了。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/iShot2020-11-13 16.15.53.png\" alt=\"插件信息\" /></p>\n<p>这就非常贴心了！如果这都不能让你点赞，我要这文章有何用!</p>\n<p><img src=\"http://wx1.sinaimg.cn/large/006BkP2Hly1fsxxff7zd9g304g0480td.gif\" alt=\"\" /></p>\n<h2 id=\"_03-手动创建-action\"> 03 手动创建 Action</h2>\n<p>我们可以把 Action 看作是 IDEA 提高的事件响应处理器，通过 Action 我们可以自定义一些事件处理逻辑/动作。比如说你点击某个菜单的时候，我们进行一个展示对话框的操作。</p>\n<p><strong>第一步，右键<code>java</code>目录并选择 new 一个 Action</strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/新建action (1).png\" alt=\"\" /></p>\n<p><strong>第二步，配置 Action 相关信息比如展示名称。</strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/配置动作属性 (1).png\" alt=\"配置动作属性 (1)\" /></p>\n<p>创建完成之后，我们的 <code>plugin.xml</code> 的 <code>&lt;actions&gt;</code>节点下会自动生成我们刚刚创建的 Action 信息：</p>\n<div><pre><code><span><span><span>&lt;</span>actions</span><span>></span></span>\n    <span>&lt;!-- Add your actions here --></span>\n    <span><span><span>&lt;</span>action</span> <span>id</span><span><span>=</span><span>\"</span>test.hello<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>HelloAction<span>\"</span></span> <span>text</span><span><span>=</span><span>\"</span>Hello<span>\"</span></span> <span>description</span><span><span>=</span><span>\"</span>IDEA插件入门<span>\"</span></span><span>></span></span>\n      <span><span><span>&lt;</span>add-to-group</span> <span>group-id</span><span><span>=</span><span>\"</span>ToolsMenu<span>\"</span></span> <span>anchor</span><span><span>=</span><span>\"</span>first<span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;/</span>action</span><span>></span></span>\n<span><span><span>&lt;/</span>actions</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>并且 <code>java</code> 目录下为生成一个叫做 <code>HelloAction</code> 的类。并且，这个类继承了 <code>AnAction</code> ，并覆盖了 <code>actionPerformed()</code> 方法。这个 <code>actionPerformed</code> 方法就好比 JS 中的 <code>onClick</code> 方法，会在你点击的时候被触发对应的动作。</p>\n<p>我简单对<code>actionPerformed</code> 方法进行了修改，添加了一行代码。这行代码很简单，就是显示 1 个对话框并展示一些信息。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>HelloAction</span> <span>extends</span> <span>AnAction</span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>actionPerformed</span><span>(</span><span>AnActionEvent</span> e<span>)</span> <span>{</span>\n        <span>//显示对话框并展示对应的信息</span>\n        <span>Messages</span><span>.</span><span>showInfoMessage</span><span>(</span><span>\"素材不够，插件来凑！\"</span><span>,</span> <span>\"Hello\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>另外，我们上面也说了，每个动作都会归属到一个 Group 中，这个 Group 可以简单看作 IDEA 中已经存在的菜单。</p>\n<p>举个例子。我上面创建的 Action 的所属 Group 是 <strong>ToolsMenu(Tools)</strong> 。这样的话，我们创建的 Action 所在的位置就在 Tools 这个菜单下。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201113192255689.png\" alt=\"\" /></p>\n<p>再举个例子。加入我上面创建的 Action 所属的 Group 是<strong>MainMenu</strong> （IDEA 最上方的主菜单栏）下的 <strong>FileMenu(File)</strong> 的话。</p>\n<div><pre><code><span><span><span>&lt;</span>actions</span><span>></span></span>\n    <span>&lt;!-- Add your actions here --></span>\n    <span><span><span>&lt;</span>action</span> <span>id</span><span><span>=</span><span>\"</span>test.hello<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>HelloAction<span>\"</span></span> <span>text</span><span><span>=</span><span>\"</span>Hello<span>\"</span></span> <span>description</span><span><span>=</span><span>\"</span>IDEA插件入门<span>\"</span></span><span>></span></span>\n      <span><span><span>&lt;</span>add-to-group</span> <span>group-id</span><span><span>=</span><span>\"</span>FileMenu<span>\"</span></span> <span>anchor</span><span><span>=</span><span>\"</span>first<span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;/</span>action</span><span>></span></span>\n<span><span><span>&lt;/</span>actions</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们创建的 Action 所在的位置就在 File 这个菜单下。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201113201634643.png\" alt=\"\" /></p>\n<h2 id=\"_04-验收成果\"> 04 验收成果</h2>\n<p>点击 <code>Gradle -&gt; runIde</code> 就会启动一个默认了这个插件的 IDEA。然后，你可以在这个 IDEA 上实际使用这个插件了。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201118075912490.png\" alt=\"点击 runIde 就会启动一个默认了这个插件的 IDEA\" /></p>\n<p>效果如下：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201118080358764.png\" alt=\"点击 runIde 就会启动一个默认了这个插件的 IDEA\" /></p>\n<p>我们点击自定义的 Hello Action 的话就会弹出一个对话框并展示出我们自定义的信息。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/IDEA插件HelloWorld.png\" alt=\"IDEA插件HelloWorld\" /></p>\n<h2 id=\"_05-完善一下\"> 05 完善一下</h2>\n<p>想要弄点界面花里胡哨一下， 我们还可以通过 Swing 来写一个界面。</p>\n<p>这里我们简单实现一个聊天机器人。代码的话，我是直接参考的我大二刚学 Java 那会写的一个小项目（<em>当时写的代码实在太烂了！就很菜！</em>）。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201114100213337.png\" alt=\"\" /></p>\n<p>首先，你需要在<a href=\"http://www.tuling123.com/\" title=\"图灵机器人官网\" target=\"_blank\" rel=\"noopener noreferrer\">图灵机器人官网</a>申请一个机器人。（<em>其他机器人也一样，感觉这个图灵机器人没有原来好用了，并且免费调用次数也不多</em>）</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201118075453172.png\" alt=\"\" /></p>\n<p>然后，简单写一个方法来请求调用机器人。由于代码比较简单，我这里就不放出来了，大家简单看一下效果就好。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201118075803163.png\" alt=\"\" /></p>\n<h2 id=\"_06-深入学习\"> 06 深入学习</h2>\n<p>如果你想要深入学习的 IDEA 插件的话，可以看一下官网文档：<a href=\"https://jetbrains.org/intellij/sdk/docs/basics/basics.html\" title=\"https://jetbrains.org/intellij/sdk/docs/basics/basics.html \" target=\"_blank\" rel=\"noopener noreferrer\">https://jetbrains.org/intellij/sdk/docs/basics/basics.html </a> 。</p>\n<p>这方面的资料还是比较少的。除了官方文档的话，你还可以简单看看下面这几篇文章：</p>\n<ul>\n<li><a href=\"https://developer.aliyun.com/article/777850?spm=a2c6h.12873581.0.dArticle777850.118d6446r096V4&amp;groupCode=alitech\" title=\"8 条经验轻松上手 IDEA 插件开发\" target=\"_blank\" rel=\"noopener noreferrer\">8 条经验轻松上手 IDEA 插件开发</a></li>\n<li><a href=\"https://blog.xiaohansong.com/idea-plugin-development.html\" title=\"IDEA 插件开发入门教程\" target=\"_blank\" rel=\"noopener noreferrer\">IDEA 插件开发入门教程</a></li>\n</ul>\n<h2 id=\"_07-后记\"> 07 后记</h2>\n<p>我们开发 IDEA 插件主要是为了让 IDEA 更加好用，比如有些框架使用之后可以减少重复代码的编写、有些主题类型的插件可以让你的 IDEA 更好看。</p>\n<p>我这篇文章的这个案例说实话只是为了让大家简单入门一下 IDEA 开发，没有任何实际应用意义。<strong>如果你想要开发一个不错的 IDEA 插件的话，还要充分发挥想象，利用 IDEA 插件平台的能力。</strong></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/image-20201118071711216.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": []
    },
    {
      "title": "IDEA源码阅读技巧",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-tips/idea-source-code-reading-skills/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/idea-tutorial/idea-tips/idea-source-code-reading-skills/",
      "content_html": "<h1 id=\"idea源码阅读技巧\"> IDEA源码阅读技巧</h1>\n<p>项目有个新来了一个小伙伴，他看我查看项目源代码的时候，各种骚操作“花里胡哨”的。于是他向我请教，想让我分享一下我平时使用 IDEA 看源码的小技巧。</p>\n<h2 id=\"基本操作\"> 基本操作</h2>\n<p>这一部分的内容主要是一些我平时看源码的时候常用的快捷键/小技巧！非常好用！</p>\n<p>掌握这些快捷键/小技巧，看源码的效率提升一个等级！</p>\n<h3 id=\"查看当前类的层次结构\"> 查看当前类的层次结构</h3>\n<table>\n<thead>\n<tr>\n<th>使用频率</th>\n<th>相关快捷键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>⭐⭐⭐⭐⭐</td>\n<td><code>Ctrl + H</code></td>\n</tr>\n</tbody>\n</table>\n<p>平时，我们阅读源码的时候，经常需要查看类的层次结构。就比如我们遇到抽象类或者接口的时候，经常需要查看其被哪些类实现。</p>\n<p>拿 Spring 源码为例，<code>BeanDefinition</code> 是一个关于 Bean 属性/定义的接口。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>BeanDefinition</span> <span>extends</span> <span>AttributeAccessor</span><span>,</span> <span>BeanMetadataElement</span> <span>{</span>\n  <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果我们需要查看 <code>BeanDefinition</code> 被哪些类实现的话，只需要把鼠标移动到 <code>BeanDefinition</code> 类名上，然后使用快捷键 <code>Ctrl + H</code> 即可。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135533686.png\" alt=\"\" /></p>\n<p>同理，如果你想查看接口 <code>BeanDefinition</code> 继承的接口 <code>AttributeAccessor</code> 被哪些类实现的话，只需要把鼠标移动到 <code>AttributeAccessor</code> 类名上，然后使用快捷键 <code>Ctrl + H</code> 即可。</p>\n<h3 id=\"查看类结构\"> 查看类结构</h3>\n<table>\n<thead>\n<tr>\n<th>使用频率</th>\n<th>相关快捷键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>⭐⭐⭐⭐</td>\n<td><code>Alt + 7</code>(Win) / <code>Command +7</code> （Mac）</td>\n</tr>\n</tbody>\n</table>\n<p>类结构可以让我们快速了解到当前类的方法、变量/常量，非常使用！</p>\n<p>我们在对应的类的任意位置使用快捷键 <code>Alt + 7</code>(Win) / <code>Command +7</code> （Mac）即可。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135552183.png\" alt=\"\" /></p>\n<h3 id=\"快速检索类\"> 快速检索类</h3>\n<table>\n<thead>\n<tr>\n<th>使用频率</th>\n<th>相关快捷键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>⭐⭐⭐⭐⭐</td>\n<td><code>Ctrl + N</code> (Win) / <code>Command + O</code> （Mac）</td>\n</tr>\n</tbody>\n</table>\n<p>使用快捷键 <code>Ctrl + N</code> (Win) / <code>Command + O</code> （Mac）可以快速检索类/文件。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135629367.png\" alt=\"\" /></p>\n<h3 id=\"关键字检索\"> 关键字检索</h3>\n<table>\n<thead>\n<tr>\n<th>使用频率</th>\n<th>相关快捷键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>⭐⭐⭐⭐⭐</td>\n<td>见下文</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>当前文件下检索 ： <code>Ctrl + F</code> (Win) / <code>Command + F</code> （Mac）</li>\n<li>全局的文本检索 : <code>Ctrl + Shift + F</code> (Win) / <code>Command + Shift + F</code> （Mac）</li>\n</ul>\n<h3 id=\"查看方法-类的实现类\"> 查看方法/类的实现类</h3>\n<table>\n<thead>\n<tr>\n<th>使用频率</th>\n<th>相关快捷键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>⭐⭐⭐⭐</td>\n<td><code>Ctrl + Alt + B</code> (Win) / <code>Command + Alt + B</code> (Mac)</td>\n</tr>\n</tbody>\n</table>\n<p>如果我们想直接跳转到某个方法/类的实现类，直接在方法名或者类名上使用快捷键 <code>Ctrl + Alt + B/鼠标左键</code> (Win) / <code>Command + Alt + B/鼠标左键</code> (Mac) 即可。</p>\n<p>如果对应的方法/类只有一个实现类的话，会直接跳转到对应的实现类。</p>\n<p>比如 <code>BeanDefinition</code> 接口的 <code>getBeanClassName()</code> 方法只被 <code>AbstractBeanDefinition</code> 抽象类实现，我们对这个方法使用快捷键就可以直接跳转到 <code>AbstractBeanDefinition</code> 抽象类中对应的实现方法。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>BeanDefinition</span> <span>extends</span> <span>AttributeAccessor</span><span>,</span> <span>BeanMetadataElement</span> <span>{</span>\n  <span>@Nullable</span>\n\t<span>String</span> <span>getBeanClassName</span><span>(</span><span>)</span><span>;</span>\n  <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果对应的方法/类有多个实现类的话，IDEA 会弹出一个选择框让你选择。</p>\n<p>比如 <code>BeanDefinition</code> 接口的 <code>getParentName()</code> 方法就有多个不同的实现。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135703164.png\" alt=\"\" /></p>\n<h3 id=\"查看方法被使用的情况\"> 查看方法被使用的情况</h3>\n<table>\n<thead>\n<tr>\n<th>使用频率</th>\n<th>相关快捷键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>⭐⭐⭐⭐</td>\n<td><code>Alt + F7</code></td>\n</tr>\n</tbody>\n</table>\n<p>我们可以通过直接在方法名上使用快捷键 <code>Alt + F7</code> 来查看这个方法在哪些地方被调用过。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135712962.png\" alt=\"\" /></p>\n<h3 id=\"查看最近使用的文件\"> 查看最近使用的文件</h3>\n<table>\n<thead>\n<tr>\n<th>使用频率</th>\n<th>相关快捷键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>⭐⭐⭐⭐⭐</td>\n<td><code>Ctrl + E</code>(Win) / <code>Command +E</code> （Mac）</td>\n</tr>\n</tbody>\n</table>\n<p>你可以通过快捷键 <code>Ctrl + E</code>(Win) / <code>Command +E</code> （Mac）来显示 IDEA 最近使用的一些文件。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135733816.png\" alt=\"\" /></p>\n<h3 id=\"查看图表形式的类继承链\"> 查看图表形式的类继承链</h3>\n<table>\n<thead>\n<tr>\n<th>使用频率</th>\n<th>相关快捷键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>⭐⭐⭐⭐</td>\n<td>相关快捷键较多，不建议记</td>\n</tr>\n</tbody>\n</table>\n<p>点击类名 <strong>右键</strong> ，选择 <strong>Shw Diagrams</strong> 即可查看图表形式的类继承链。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135745518.png\" alt=\"\" /></p>\n<p>你还可以对图表进行一些操作。比如，你可以点击图表中具体的类 <strong>右键</strong>，然后选择显示它的实现类或者父类。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135757163.png\" alt=\"\" /></p>\n<p>再比如你还可以选择是否显示类中的属性、方法、内部类等等信息。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135902827.png\" alt=\"\" /></p>\n<p>如果你想跳转到对应类的源码的话，直接点击图表中具体的类 <strong>右键</strong> ，然后选择 <strong>Jump to Source</strong> 。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135807668.png\" alt=\"\" /></p>\n<h2 id=\"插件推荐\"> 插件推荐</h2>\n<h3 id=\"一键生成方法的序列图\"> 一键生成方法的序列图</h3>\n<p><strong>序列图</strong>（Sequence Diagram），亦称为<strong>循序图</strong>，是一种 UML 行为图。表示系统执行某个方法/操作（如登录操作）时，对象之间的顺序调用关系。</p>\n<p>这个顺序调用关系可以这样理解：你需要执行系统中某个对象 a 提供的方法/操作 login（登录），但是这个对象又依赖了对象 b 提供的方法 getUser(获取用户)。因此，这里就有了 a -&gt; b 调用关系之说。</p>\n<p>我们可以通过 <strong>SequenceDiagram</strong> 这个插件一键生成方法的序列图。</p>\n<blockquote>\n<p>如果你因为网络问题没办法使用 IDEA 自带的插件市场的话，也可以通过 IDEA 插件市场的官网手动下载安装。</p>\n</blockquote>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/2021052218304014.png\" alt=\"\" /></p>\n<p><strong>如何使用呢？</strong></p>\n<p>1、选中方法名（注意不要选类名），然后点击鼠标右键，选择 <strong>Sequence Diagram</strong> 选项即可！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20201021170110697.png\" alt=\"\" /></p>\n<p>2、配置生成的序列图的一些基本的参数比如调用深度之后，我们点击 ok 即可！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/c5040f1105c762ddf8689892913bc02d.png\" alt=\"\" /></p>\n<p>3、你还可以通过生成的时序图来定位到相关的代码，这对于我们阅读源码的时候尤其有帮助！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20201021171623809.png\" alt=\"\" /></p>\n<p>4、时序图生成完成之后，你还可以选择将其导出为图片。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20201021170228723.png\" alt=\"\" /></p>\n<p>相关阅读：<a href=\"https://mp.weixin.qq.com/s/SG1twZczqdup_EQAOmNERg\" target=\"_blank\" rel=\"noopener noreferrer\">《安利一个 IDEA 骚操作:一键生成方法的序列图》</a> 。</p>\n<h3 id=\"项目代码统计\"> 项目代码统计</h3>\n<p>为了快速分析项目情况，我们可以对项目的 <strong>代码的总行数、单个文件的代码行数、注释行数等信息进行统计。</strong></p>\n<p><strong>Statistic</strong> 这个插件来帮助我们实现这一需求。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210522183550110.png\" alt=\"\" /></p>\n<p>有了这个插件之后你可以非常直观地看到你的项目中所有类型的文件的信息比如数量、大小等等，可以帮助你更好地了解你们的项目。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210522183616310.png\" alt=\"\" /></p>\n<p>你还可以使用它看所有类的总行数、有效代码行数、注释行数、以及有效代码比重等等这些东西。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210522183630459.png\" alt=\"\" /></p>\n<p>如果，你担心插件过多影响 IDEA 速度的话，可以只在有代码统计需求的时候开启这个插件，其他时间禁用它就完事了！</p>\n<p>相关阅读：<a href=\"https://mp.weixin.qq.com/s/fVEeMW6elhu79I-rTZB40A\" target=\"_blank\" rel=\"noopener noreferrer\">快速识别烂项目！试试这款项目代码统计 IDEA 插件</a></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/idea/20210527135533686.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": []
    },
    {
      "title": "Intro Page",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/intro/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/intro/",
      "content_html": "<h1 id=\"intro-page\"> Intro Page</h1>\n<p>Place your introducation and profile here.</p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": []
    },
    {
      "title": "一 斐波那契数列",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/algorithms/%E5%89%91%E6%8C%87offer%E9%83%A8%E5%88%86%E7%BC%96%E7%A8%8B%E9%A2%98/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/algorithms/%E5%89%91%E6%8C%87offer%E9%83%A8%E5%88%86%E7%BC%96%E7%A8%8B%E9%A2%98/",
      "content_html": "<h3 id=\"一-斐波那契数列\"> 一 斐波那契数列</h3>\n<h4 id=\"题目描述\"> <strong>题目描述：</strong></h4>\n<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。\nn&lt;=39</p>\n<h4 id=\"问题分析\"> <strong>问题分析：</strong></h4>\n<p>可以肯定的是这一题通过递归的方式是肯定能做出来，但是这样会有一个很大的问题，那就是递归大量的重复计算会导致内存溢出。另外可以使用迭代法，用fn1和fn2保存计算过程中的结果，并复用起来。下面我会把两个方法示例代码都给出来并给出两个方法的运行时间对比。</p>\n<h4 id=\"示例代码\"> <strong>示例代码：</strong></h4>\n<p><strong>采用迭代法：</strong></p>\n<div><pre><code><span>int</span> <span>Fibonacci</span><span>(</span><span>int</span> number<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>number <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>\n        <span>return</span> <span>0</span><span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span>number <span>==</span> <span>1</span> <span>||</span> number <span>==</span> <span>2</span><span>)</span> <span>{</span>\n        <span>return</span> <span>1</span><span>;</span>\n    <span>}</span>\n    <span>int</span> first <span>=</span> <span>1</span><span>,</span> second <span>=</span> <span>1</span><span>,</span> third <span>=</span> <span>0</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>3</span><span>;</span> i <span>&lt;=</span> number<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        third <span>=</span> first <span>+</span> second<span>;</span>\n        first <span>=</span> second<span>;</span>\n        second <span>=</span> third<span>;</span>\n    <span>}</span>\n    <span>return</span> third<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>采用递归：</strong></p>\n<div><pre><code><span>public</span> <span>int</span> <span>Fibonacci</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>n <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>\n        <span>return</span> <span>0</span><span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span>n <span>==</span> <span>1</span><span>||</span>n<span>==</span><span>2</span><span>)</span> <span>{</span>\n        <span>return</span> <span>1</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> <span>Fibonacci</span><span>(</span>n <span>-</span> <span>2</span><span>)</span> <span>+</span> <span>Fibonacci</span><span>(</span>n <span>-</span> <span>1</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"二-跳台阶问题\"> 二 跳台阶问题</h3>\n<h4 id=\"题目描述-2\"> <strong>题目描述：</strong></h4>\n<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>\n<h4 id=\"问题分析-2\"> <strong>问题分析：</strong></h4>\n<p><strong>正常分析法：</strong>\na.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);\nb.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)\nc.由a，b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)\nd.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2\n<strong>找规律分析法：</strong>\nf(1) = 1, f(2) = 2, f(3) = 3, f(4) = 5，  可以总结出f(n) = f(n-1) + f(n-2)的规律。\n但是为什么会出现这样的规律呢？假设现在6个台阶，我们可以从第5跳一步到6，这样的话有多少种方案跳到5就有多少种方案跳到6，另外我们也可以从4跳两步跳到6，跳到4有多少种方案的话，就有多少种方案跳到6，其他的不能从3跳到6什么的啦，所以最后就是f(6) = f(5) + f(4)；这样子也很好理解变态跳台阶的问题了。</p>\n<p><strong>所以这道题其实就是斐波那契数列的问题。</strong>\n代码只需要在上一题的代码稍做修改即可。和上一题唯一不同的就是这一题的初始元素变为 1 2 3 5 8.....而上一题为1 1 2  3 5 .......。另外这一题也可以用递归做，但是递归效率太低，所以我这里只给出了迭代方式的代码。</p>\n<h4 id=\"示例代码-2\"> <strong>示例代码：</strong></h4>\n<div><pre><code><span>int</span> <span>jumpFloor</span><span>(</span><span>int</span> number<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>number <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>\n        <span>return</span> <span>0</span><span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span>number <span>==</span> <span>1</span><span>)</span> <span>{</span>\n        <span>return</span> <span>1</span><span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span>number <span>==</span> <span>2</span><span>)</span> <span>{</span>\n        <span>return</span> <span>2</span><span>;</span>\n    <span>}</span>\n    <span>int</span> first <span>=</span> <span>1</span><span>,</span> second <span>=</span> <span>2</span><span>,</span> third <span>=</span> <span>0</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>3</span><span>;</span> i <span>&lt;=</span> number<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        third <span>=</span> first <span>+</span> second<span>;</span>\n        first <span>=</span> second<span>;</span>\n        second <span>=</span> third<span>;</span>\n    <span>}</span>\n    <span>return</span> third<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"三-变态跳台阶问题\"> 三 变态跳台阶问题</h3>\n<h4 id=\"题目描述-3\"> <strong>题目描述：</strong></h4>\n<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>\n<h4 id=\"问题分析-3\"> <strong>问题分析：</strong></h4>\n<p>假设n&gt;=2，第一步有n种跳法：跳1级、跳2级、到跳n级\n跳1级，剩下n-1级，则剩下跳法是f(n-1)\n跳2级，剩下n-2级，则剩下跳法是f(n-2)\n......\n跳n-1级，剩下1级，则剩下跳法是f(1)\n跳n级，剩下0级，则剩下跳法是f(0)\n所以在n&gt;=2的情况下：\nf(n)=f(n-1)+f(n-2)+...+f(1)\n因为f(n-1)=f(n-2)+f(n-3)+...+f(1)\n所以f(n)=2*f(n-1) 又f(1)=1,所以可得<strong>f(n)=2^(number-1)</strong></p>\n<h4 id=\"示例代码-3\"> <strong>示例代码：</strong></h4>\n<div><pre><code><span>int</span> <span>JumpFloorII</span><span>(</span><span>int</span> number<span>)</span> <span>{</span>\n    <span>return</span> <span>1</span> <span>&lt;&lt;</span> <span>--</span>number<span>;</span><span>//2^(number-1)用位移操作进行，更快</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"补充\"> <strong>补充：</strong></h4>\n<p><strong>java中有三种移位运算符：</strong></p>\n<ol>\n<li>“&lt;&lt;” :     <strong>左移运算符</strong>，等同于乘2的n次方</li>\n<li>“&gt;&gt;”:     <strong>右移运算符</strong>，等同于除2的n次方</li>\n<li>“&gt;&gt;&gt;” :  <strong>无符号右移运算符</strong>，不管移动前最高位是0还是1，右移后左侧产生的空位部分都以0来填充。与&gt;&gt;类似。\n例：\nint a = 16;\nint b = a &lt;&lt; 2;//左移2，等同于16 * 2的2次方，也就是16 * 4\nint c = a &gt;&gt; 2;//右移2，等同于16 / 2的2次方，也就是16 / 4</li>\n</ol>\n<h3 id=\"四-二维数组查找\"> 四 二维数组查找</h3>\n<h4 id=\"题目描述-4\"> <strong>题目描述：</strong></h4>\n<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<h4 id=\"问题解析\"> <strong>问题解析：</strong></h4>\n<p>这一道题还是比较简单的，我们需要考虑的是如何做，效率最快。这里有一种很好理解的思路：</p>\n<blockquote>\n<p>矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，\n因此从左下角开始查找，当要查找数字比左下角数字大时。右移\n要查找数字比左下角数字小时，上移。这样找的速度最快。</p>\n</blockquote>\n<h4 id=\"示例代码-4\"> <strong>示例代码：</strong></h4>\n<div><pre><code><span>public</span> <span>boolean</span> <span>Find</span><span>(</span><span>int</span> target<span>,</span> <span>int</span> <span>[</span><span>]</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>\n    <span>//基本思路从左下角开始找，这样速度最快</span>\n    <span>int</span> row <span>=</span> array<span>.</span>length<span>-</span><span>1</span><span>;</span><span>//行</span>\n    <span>int</span> column <span>=</span> <span>0</span><span>;</span><span>//列</span>\n    <span>//当行数大于0，当前列数小于总列数时循环条件成立</span>\n    <span>while</span><span>(</span><span>(</span>row <span>>=</span> <span>0</span><span>)</span><span>&amp;&amp;</span> <span>(</span>column<span>&lt;</span> array<span>[</span><span>0</span><span>]</span><span>.</span>length<span>)</span><span>)</span><span>{</span>\n        <span>if</span><span>(</span>array<span>[</span>row<span>]</span><span>[</span>column<span>]</span> <span>></span> target<span>)</span><span>{</span>\n            row<span>--</span><span>;</span>\n        <span>}</span><span>else</span> <span>if</span><span>(</span>array<span>[</span>row<span>]</span><span>[</span>column<span>]</span> <span>&lt;</span> target<span>)</span><span>{</span>\n            column<span>++</span><span>;</span>\n        <span>}</span><span>else</span><span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"五-替换空格\"> 五 替换空格</h3>\n<h4 id=\"题目描述-5\"> <strong>题目描述：</strong></h4>\n<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>\n<h4 id=\"问题分析-4\"> <strong>问题分析：</strong></h4>\n<p>这道题不难，我们可以通过循环判断字符串的字符是否为空格，是的话就利用append()方法添加追加“%20”，否则还是追加原字符。</p>\n<p>或者最简单的方法就是利用：replaceAll(String regex,String replacement)方法了，一行代码就可以解决。</p>\n<h4 id=\"示例代码-5\"> <strong>示例代码：</strong></h4>\n<p><strong>常规做法：</strong></p>\n<div><pre><code><span>public</span> <span>String</span> <span>replaceSpace</span><span>(</span><span>StringBuffer</span> str<span>)</span> <span>{</span>\n    <span>StringBuffer</span> out <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> str<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>char</span> b <span>=</span> str<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>\n        <span>if</span><span>(</span><span>String</span><span>.</span><span>valueOf</span><span>(</span>b<span>)</span><span>.</span><span>equals</span><span>(</span><span>\" \"</span><span>)</span><span>)</span><span>{</span>\n            out<span>.</span><span>append</span><span>(</span><span>\"%20\"</span><span>)</span><span>;</span>\n        <span>}</span><span>else</span><span>{</span>\n            out<span>.</span><span>append</span><span>(</span>b<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> out<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>     \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>一行代码解决：</strong></p>\n<div><pre><code><span>public</span> <span>String</span> <span>replaceSpace</span><span>(</span><span>StringBuffer</span> str<span>)</span> <span>{</span>\n    <span>//return str.toString().replaceAll(\" \", \"%20\");</span>\n    <span>//public String replaceAll(String regex,String replacement)</span>\n    <span>//用给定的替换替换与给定的regular expression匹配的此字符串的每个子字符串。 </span>\n    <span>//\\ 转义字符. 如果你要使用 \"\\\" 本身, 则应该使用 \"\\\\\". String类型中的空格用“\\s”表示，所以我这里猜测\"\\\\s\"就是代表空格的意思</span>\n    <span>return</span> str<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>replaceAll</span><span>(</span><span>\"\\\\s\"</span><span>,</span> <span>\"%20\"</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"六-数值的整数次方\"> 六 数值的整数次方</h3>\n<h4 id=\"题目描述-6\"> <strong>题目描述：</strong></h4>\n<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>\n<h4 id=\"问题解析-2\"> <strong>问题解析：</strong></h4>\n<p>这道题算是比较麻烦和难一点的一个了。我这里采用的是<strong>二分幂</strong>思想，当然也可以采用<strong>快速幂</strong>。\n更具剑指offer书中细节，该题的解题思路如下：\n1.当底数为0且指数&lt;0时，会出现对0求倒数的情况，需进行错误处理，设置一个全局变量；\n2.判断底数是否等于0，由于base为double型，所以不能直接用==判断\n3.优化求幂函数（二分幂）。\n当n为偶数，a^n =（a<sup>n/2）*（a</sup>n/2）；\n当n为奇数，a^n = a<sup></sup> * a<sup></sup> * a。时间复杂度O(logn)</p>\n<p><strong>时间复杂度</strong>：O(logn)</p>\n<h4 id=\"示例代码-6\"> <strong>示例代码：</strong></h4>\n<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span> \n      <span>boolean</span> invalidInput<span>=</span><span>false</span><span>;</span>    \n      <span>public</span> <span>double</span> <span>Power</span><span>(</span><span>double</span> base<span>,</span> <span>int</span> exponent<span>)</span> <span>{</span>\n          <span>//如果底数等于0并且指数小于0</span>\n          <span>//由于base为double型，不能直接用==判断</span>\n        <span>if</span><span>(</span><span>equal</span><span>(</span>base<span>,</span><span>0.0</span><span>)</span><span>&amp;&amp;</span>exponent<span>&lt;</span><span>0</span><span>)</span><span>{</span>\n            invalidInput<span>=</span><span>true</span><span>;</span>\n            <span>return</span> <span>0.0</span><span>;</span>\n        <span>}</span>\n        <span>int</span> absexponent<span>=</span>exponent<span>;</span>\n         <span>//如果指数小于0，将指数转正</span>\n        <span>if</span><span>(</span>exponent<span>&lt;</span><span>0</span><span>)</span>\n            absexponent<span>=</span><span>-</span>exponent<span>;</span>\n         <span>//getPower方法求出base的exponent次方。</span>\n        <span>double</span> res<span>=</span><span>getPower</span><span>(</span>base<span>,</span>absexponent<span>)</span><span>;</span>\n         <span>//如果指数小于0，所得结果为上面求的结果的倒数</span>\n        <span>if</span><span>(</span>exponent<span>&lt;</span><span>0</span><span>)</span>\n            res<span>=</span><span>1.0</span><span>/</span>res<span>;</span>\n        <span>return</span> res<span>;</span>\n  <span>}</span>\n    <span>//比较两个double型变量是否相等的方法</span>\n    <span>boolean</span> <span>equal</span><span>(</span><span>double</span> num1<span>,</span><span>double</span> num2<span>)</span><span>{</span>\n        <span>if</span><span>(</span>num1<span>-</span>num2<span>></span><span>-</span><span>0.000001</span><span>&amp;&amp;</span>num1<span>-</span>num2<span>&lt;</span><span>0.000001</span><span>)</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>else</span>\n            <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n    <span>//求出b的e次方的方法</span>\n    <span>double</span> <span>getPower</span><span>(</span><span>double</span> b<span>,</span><span>int</span> e<span>)</span><span>{</span>\n        <span>//如果指数为0，返回1</span>\n        <span>if</span><span>(</span>e<span>==</span><span>0</span><span>)</span>\n            <span>return</span> <span>1.0</span><span>;</span>\n        <span>//如果指数为1，返回b</span>\n        <span>if</span><span>(</span>e<span>==</span><span>1</span><span>)</span>\n            <span>return</span> b<span>;</span>\n        <span>//e>>1相等于e/2，这里就是求a^n =（a^n/2）*（a^n/2）</span>\n        <span>double</span> result<span>=</span><span>getPower</span><span>(</span>b<span>,</span>e<span>>></span><span>1</span><span>)</span><span>;</span>\n        result<span>*=</span>result<span>;</span>\n        <span>//如果指数n为奇数，则要再乘一次底数base</span>\n        <span>if</span><span>(</span><span>(</span>e<span>&amp;</span><span>1</span><span>)</span><span>==</span><span>1</span><span>)</span>\n            result<span>*=</span>b<span>;</span>\n        <span>return</span> result<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p>当然这一题也可以采用笨方法：累乘。不过这种方法的时间复杂度为O（n），这样没有前一种方法效率高。</p>\n<div><pre><code><span>// 使用累乘</span>\n<span>public</span> <span>double</span> <span>powerAnother</span><span>(</span><span>double</span> base<span>,</span> <span>int</span> exponent<span>)</span> <span>{</span>\n    <span>double</span> result <span>=</span> <span>1.0</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>Math</span><span>.</span><span>abs</span><span>(</span>exponent<span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        result <span>*=</span> base<span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span>exponent <span>>=</span> <span>0</span><span>)</span>\n        <span>return</span> result<span>;</span>\n    <span>else</span>\n        <span>return</span> <span>1</span> <span>/</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"七-调整数组顺序使奇数位于偶数前面\"> 七 调整数组顺序使奇数位于偶数前面</h3>\n<h4 id=\"题目描述-7\"> <strong>题目描述：</strong></h4>\n<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>\n<h4 id=\"问题解析-3\"> <strong>问题解析：</strong></h4>\n<p>这道题有挺多种解法的，给大家介绍一种我觉得挺好理解的方法：\n我们首先统计奇数的个数假设为n,然后新建一个等长数组，然后通过循环判断原数组中的元素为偶数还是奇数。如果是则从数组下标0的元素开始，把该奇数添加到新数组；如果是偶数则从数组下标为n的元素开始把该偶数添加到新数组中。</p>\n<h4 id=\"示例代码-7\"> <strong>示例代码：</strong></h4>\n<p>时间复杂度为O（n），空间复杂度为O（n）的算法</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>reOrderArray</span><span>(</span><span>int</span> <span>[</span><span>]</span> array<span>)</span> <span>{</span>\n        <span>//如果数组长度等于0或者等于1，什么都不做直接返回</span>\n        <span>if</span><span>(</span>array<span>.</span>length<span>==</span><span>0</span><span>||</span>array<span>.</span>length<span>==</span><span>1</span><span>)</span> \n            <span>return</span><span>;</span>\n        <span>//oddCount：保存奇数个数</span>\n        <span>//oddBegin：奇数从数组头部开始添加</span>\n        <span>int</span> oddCount<span>=</span><span>0</span><span>,</span>oddBegin<span>=</span><span>0</span><span>;</span>\n        <span>//新建一个数组</span>\n        <span>int</span><span>[</span><span>]</span> newArray<span>=</span><span>new</span> <span>int</span><span>[</span>array<span>.</span>length<span>]</span><span>;</span>\n        <span>//计算出（数组中的奇数个数）开始添加元素</span>\n        <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>array<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>\n            <span>if</span><span>(</span><span>(</span>array<span>[</span>i<span>]</span><span>&amp;</span><span>1</span><span>)</span><span>==</span><span>1</span><span>)</span> oddCount<span>++</span><span>;</span>\n        <span>}</span>\n        <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>array<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>\n            <span>//如果数为基数新数组从头开始添加元素</span>\n            <span>//如果为偶数就从oddCount（数组中的奇数个数）开始添加元素</span>\n            <span>if</span><span>(</span><span>(</span>array<span>[</span>i<span>]</span><span>&amp;</span><span>1</span><span>)</span><span>==</span><span>1</span><span>)</span> \n                newArray<span>[</span>oddBegin<span>++</span><span>]</span><span>=</span>array<span>[</span>i<span>]</span><span>;</span>\n            <span>else</span> newArray<span>[</span>oddCount<span>++</span><span>]</span><span>=</span>array<span>[</span>i<span>]</span><span>;</span>\n        <span>}</span>\n        <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>array<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>\n            array<span>[</span>i<span>]</span><span>=</span>newArray<span>[</span>i<span>]</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id=\"八-链表中倒数第k个节点\"> 八 链表中倒数第k个节点</h3>\n<h4 id=\"题目描述-8\"> <strong>题目描述：</strong></h4>\n<p>输入一个链表，输出该链表中倒数第k个结点</p>\n<h4 id=\"问题分析-5\"> <strong>问题分析：</strong></h4>\n<p><strong>一句话概括：</strong>\n两个指针一个指针p1先开始跑，指针p1跑到k-1个节点后，另一个节点p2开始跑，当p1跑到最后时，p2所指的指针就是倒数第k个节点。</p>\n<p><strong>思想的简单理解：</strong>\n前提假设：链表的结点个数(长度)为n。\n规律一：要找到倒数第k个结点，需要向前走多少步呢？比如倒数第一个结点，需要走n步，那倒数第二个结点呢？很明显是向前走了n-1步，所以可以找到规律是找到倒数第k个结点，需要向前走n-k+1步。\n<strong>算法开始：</strong></p>\n<ol>\n<li>设两个都指向head的指针p1和p2，当p1走了k-1步的时候，停下来。p2之前一直不动。</li>\n<li>p1的下一步是走第k步，这个时候，p2开始一起动了。至于为什么p2这个时候动呢？看下面的分析。</li>\n<li>当p1走到链表的尾部时，即p1走了n步。由于我们知道p2是在p1走了k-1步才开始动的，也就是说p1和p2永远差k-1步。所以当p1走了n步时，p2走的应该是在n-(k-1)步。即p2走了n-k+1步，此时巧妙的是p2正好指向的是规律一的倒数第k个结点处。\n这样是不是很好理解了呢？</li>\n</ol>\n<h4 id=\"考察内容\"> <strong>考察内容：</strong></h4>\n<p>链表+代码的鲁棒性</p>\n<h4 id=\"示例代码-8\"> <strong>示例代码：</strong></h4>\n<div><pre><code><span>/*\n//链表类\npublic class ListNode {\n    int val;\n    ListNode next = null;\n\n    ListNode(int val) {\n        this.val = val;\n    }\n}*/</span>\n\n<span>//时间复杂度O(n),一次遍历即可</span>\n<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>ListNode</span> <span>FindKthToTail</span><span>(</span><span>ListNode</span> head<span>,</span><span>int</span> k<span>)</span> <span>{</span>\n        <span>ListNode</span> pre<span>=</span><span>null</span><span>,</span>p<span>=</span><span>null</span><span>;</span>\n        <span>//两个指针都指向头结点</span>\n        p<span>=</span>head<span>;</span>\n        pre<span>=</span>head<span>;</span>\n        <span>//记录k值</span>\n        <span>int</span> a<span>=</span>k<span>;</span>\n        <span>//记录节点的个数</span>\n        <span>int</span> count<span>=</span><span>0</span><span>;</span>\n        <span>//p指针先跑，并且记录节点数，当p指针跑了k-1个节点后，pre指针开始跑，</span>\n        <span>//当p指针跑到最后时，pre所指指针就是倒数第k个节点</span>\n        <span>while</span><span>(</span>p<span>!=</span><span>null</span><span>)</span><span>{</span>\n            p<span>=</span>p<span>.</span>next<span>;</span>\n            count<span>++</span><span>;</span>\n            <span>if</span><span>(</span>k<span>&lt;</span><span>1</span><span>)</span><span>{</span>\n                pre<span>=</span>pre<span>.</span>next<span>;</span>\n            <span>}</span>\n            k<span>--</span><span>;</span>\n        <span>}</span>\n        <span>//如果节点个数小于所求的倒数第k个节点，则返回空</span>\n        <span>if</span><span>(</span>count<span>&lt;</span>a<span>)</span> <span>return</span> <span>null</span><span>;</span>\n        <span>return</span> pre<span>;</span>\n            \n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h3 id=\"九-反转链表\"> 九 反转链表</h3>\n<h4 id=\"题目描述-9\"> <strong>题目描述：</strong></h4>\n<p>输入一个链表，反转链表后，输出链表的所有元素。</p>\n<h4 id=\"问题分析-6\"> <strong>问题分析：</strong></h4>\n<p>链表的很常规的一道题，这一道题思路不算难，但自己实现起来真的可能会感觉无从下手，我是参考了别人的代码。\n思路就是我们根据链表的特点，前一个节点指向下一个节点的特点，把后面的节点移到前面来。\n就比如下图：我们把1节点和2节点互换位置，然后再将3节点指向2节点，4节点指向3节点，这样以来下面的链表就被反转了。\n<img src=\"https://img-blog.csdn.net/20160420134000174\" alt=\"链表\" /></p>\n<h4 id=\"考察内容-2\"> <strong>考察内容：</strong></h4>\n<p>链表+代码的鲁棒性</p>\n<h4 id=\"示例代码-9\"> <strong>示例代码：</strong></h4>\n<div><pre><code><span>/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n\n    ListNode(int val) {\n        this.val = val;\n    }\n}*/</span>\n<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>ListNode</span> <span>ReverseList</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>\n       <span>ListNode</span> next <span>=</span> <span>null</span><span>;</span>\n       <span>ListNode</span> pre <span>=</span> <span>null</span><span>;</span>\n        <span>while</span> <span>(</span>head <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n              <span>//保存要反转到头来的那个节点</span>\n               next <span>=</span> head<span>.</span>next<span>;</span>\n               <span>//要反转的那个节点指向已经反转的上一个节点</span>\n               head<span>.</span>next <span>=</span> pre<span>;</span>\n               <span>//上一个已经反转到头部的节点</span>\n               pre <span>=</span> head<span>;</span>\n               <span>//一直向链表尾走</span>\n               head <span>=</span> next<span>;</span>\n        <span>}</span>\n        <span>return</span> pre<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id=\"十-合并两个排序的链表\"> 十 合并两个排序的链表</h3>\n<h4 id=\"题目描述-10\"> <strong>题目描述：</strong></h4>\n<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>\n<h4 id=\"问题分析-7\"> <strong>问题分析：</strong></h4>\n<p>我们可以这样分析:</p>\n<ol>\n<li>假设我们有两个链表 A,B；</li>\n<li>A的头节点A1的值与B的头结点B1的值比较，假设A1小，则A1为头节点；</li>\n<li>A2再和B1比较，假设B1小,则，A1指向B1；</li>\n<li>A2再和B2比较。。。。。。。\n就这样循环往复就行了，应该还算好理解。</li>\n</ol>\n<h4 id=\"考察内容-3\"> <strong>考察内容：</strong></h4>\n<p>链表+代码的鲁棒性</p>\n<h4 id=\"示例代码-10\"> <strong>示例代码：</strong></h4>\n<p><strong>非递归版本：</strong></p>\n<div><pre><code><span>/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n\n    ListNode(int val) {\n        this.val = val;\n    }\n}*/</span>\n<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>ListNode</span> <span>Merge</span><span>(</span><span>ListNode</span> list1<span>,</span><span>ListNode</span> list2<span>)</span> <span>{</span>\n       <span>//list1为空，直接返回list2</span>\n       <span>if</span><span>(</span>list1 <span>==</span> <span>null</span><span>)</span><span>{</span>\n            <span>return</span> list2<span>;</span>\n        <span>}</span>\n        <span>//list2为空，直接返回list1</span>\n        <span>if</span><span>(</span>list2 <span>==</span> <span>null</span><span>)</span><span>{</span>\n            <span>return</span> list1<span>;</span>\n        <span>}</span>\n        <span>ListNode</span> mergeHead <span>=</span> <span>null</span><span>;</span>\n        <span>ListNode</span> current <span>=</span> <span>null</span><span>;</span>   \n        <span>//当list1和list2不为空时</span>\n        <span>while</span><span>(</span>list1<span>!=</span><span>null</span> <span>&amp;&amp;</span> list2<span>!=</span><span>null</span><span>)</span><span>{</span>\n            <span>//取较小值作头结点 </span>\n            <span>if</span><span>(</span>list1<span>.</span>val <span>&lt;=</span> list2<span>.</span>val<span>)</span><span>{</span>\n                <span>if</span><span>(</span>mergeHead <span>==</span> <span>null</span><span>)</span><span>{</span>\n                   mergeHead <span>=</span> current <span>=</span> list1<span>;</span>\n                <span>}</span><span>else</span><span>{</span>\n                   current<span>.</span>next <span>=</span> list1<span>;</span>\n                    <span>//current节点保存list1节点的值因为下一次还要用</span>\n                   current <span>=</span> list1<span>;</span>\n                <span>}</span>\n                <span>//list1指向下一个节点</span>\n                list1 <span>=</span> list1<span>.</span>next<span>;</span>\n            <span>}</span><span>else</span><span>{</span>\n                <span>if</span><span>(</span>mergeHead <span>==</span> <span>null</span><span>)</span><span>{</span>\n                   mergeHead <span>=</span> current <span>=</span> list2<span>;</span>\n                <span>}</span><span>else</span><span>{</span>\n                   current<span>.</span>next <span>=</span> list2<span>;</span>\n                     <span>//current节点保存list2节点的值因为下一次还要用</span>\n                   current <span>=</span> list2<span>;</span>\n                <span>}</span>\n                <span>//list2指向下一个节点</span>\n                list2 <span>=</span> list2<span>.</span>next<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>if</span><span>(</span>list1 <span>==</span> <span>null</span><span>)</span><span>{</span>\n            current<span>.</span>next <span>=</span> list2<span>;</span>\n        <span>}</span><span>else</span><span>{</span>\n            current<span>.</span>next <span>=</span> list1<span>;</span>\n        <span>}</span>\n        <span>return</span> mergeHead<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><p><strong>递归版本：</strong></p>\n<div><pre><code><span>public</span> <span>ListNode</span> <span>Merge</span><span>(</span><span>ListNode</span> list1<span>,</span><span>ListNode</span> list2<span>)</span> <span>{</span>\n    <span>if</span><span>(</span>list1 <span>==</span> <span>null</span><span>)</span><span>{</span>\n        <span>return</span> list2<span>;</span>\n    <span>}</span>\n    <span>if</span><span>(</span>list2 <span>==</span> <span>null</span><span>)</span><span>{</span>\n        <span>return</span> list1<span>;</span>\n    <span>}</span>\n    <span>if</span><span>(</span>list1<span>.</span>val <span>&lt;=</span> list2<span>.</span>val<span>)</span><span>{</span>\n        list1<span>.</span>next <span>=</span> <span>Merge</span><span>(</span>list1<span>.</span>next<span>,</span> list2<span>)</span><span>;</span>\n        <span>return</span> list1<span>;</span>\n    <span>}</span><span>else</span><span>{</span>\n        list2<span>.</span>next <span>=</span> <span>Merge</span><span>(</span>list1<span>,</span> list2<span>.</span>next<span>)</span><span>;</span>\n        <span>return</span> list2<span>;</span>\n    <span>}</span>       \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"十一-用两个栈实现队列\"> 十一 用两个栈实现队列</h3>\n<h4 id=\"题目描述-11\"> <strong>题目描述：</strong></h4>\n<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>\n<h4 id=\"问题分析-8\"> 问题分析：</h4>\n<p>先来回顾一下栈和队列的基本特点：\n**栈：**后进先出（LIFO）\n<strong>队列：</strong> 先进先出\n很明显我们需要根据JDK给我们提供的栈的一些基本方法来实现。先来看一下Stack类的一些基本方法：\n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-4-4/5985000.jpg\" alt=\"Stack类的一些常见方法\" /></p>\n<p>既然题目给了我们两个栈，我们可以这样考虑当push的时候将元素push进stack1，pop的时候我们先把stack1的元素pop到stack2，然后再对stack2执行pop操作，这样就可以保证是先进先出的。（负[pop]负[pop]得正[先进先出]）</p>\n<h4 id=\"考察内容-4\"> 考察内容：</h4>\n<p>队列+栈</p>\n<h4 id=\"示例代码-11\"> 示例代码：</h4>\n<div><pre><code><span>//左程云的《程序员代码面试指南》的答案</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Stack</span><span>;</span>\n \n<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>\n    <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stack1 <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stack2 <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n     \n    <span>//当执行push操作时，将元素添加到stack1</span>\n    <span>public</span> <span>void</span> <span>push</span><span>(</span><span>int</span> node<span>)</span> <span>{</span>\n        stack1<span>.</span><span>push</span><span>(</span>node<span>)</span><span>;</span>\n    <span>}</span>\n     \n    <span>public</span> <span>int</span> <span>pop</span><span>(</span><span>)</span> <span>{</span>\n        <span>//如果两个队列都为空则抛出异常,说明用户没有push进任何元素</span>\n        <span>if</span><span>(</span>stack1<span>.</span><span>empty</span><span>(</span><span>)</span><span>&amp;&amp;</span>stack2<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"Queue is empty!\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>//如果stack2不为空直接对stack2执行pop操作，</span>\n        <span>if</span><span>(</span>stack2<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>while</span><span>(</span><span>!</span>stack1<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span><span>{</span>\n                <span>//将stack1的元素按后进先出push进stack2里面</span>\n                stack2<span>.</span><span>push</span><span>(</span>stack1<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n          <span>return</span> stack2<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id=\"十二-栈的压入-弹出序列\"> 十二 栈的压入,弹出序列</h3>\n<h4 id=\"题目描述-12\"> <strong>题目描述：</strong></h4>\n<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>\n<h4 id=\"题目分析\"> <strong>题目分析：</strong></h4>\n<p>这道题想了半天没有思路，参考了Alias的答案，他的思路写的也很详细应该很容易看懂。\n作者：Alias\nhttps://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106\n来源：牛客网</p>\n<p>【思路】借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p>\n<p>举例：</p>\n<p>入栈1,2,3,4,5</p>\n<p>出栈4,5,3,2,1</p>\n<p>首先1入辅助栈，此时栈顶1≠4，继续入栈2</p>\n<p>此时栈顶2≠4，继续入栈3</p>\n<p>此时栈顶3≠4，继续入栈4</p>\n<p>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3</p>\n<p>此时栈顶3≠5，继续入栈5</p>\n<p>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</p>\n<p>….\n依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。</p>\n<h4 id=\"考察内容-5\"> <strong>考察内容：</strong></h4>\n<p>栈</p>\n<h4 id=\"示例代码-12\"> <strong>示例代码：</strong></h4>\n<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>ArrayList</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Stack</span><span>;</span>\n<span>//这道题没想出来，参考了Alias同学的答案：https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106</span>\n<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>boolean</span> <span>IsPopOrder</span><span>(</span><span>int</span> <span>[</span><span>]</span> pushA<span>,</span><span>int</span> <span>[</span><span>]</span> popA<span>)</span> <span>{</span>\n        <span>if</span><span>(</span>pushA<span>.</span>length <span>==</span> <span>0</span> <span>||</span> popA<span>.</span>length <span>==</span> <span>0</span><span>)</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> s <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>//用于标识弹出序列的位置</span>\n        <span>int</span> popIndex <span>=</span> <span>0</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i<span>&lt;</span> pushA<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>\n            s<span>.</span><span>push</span><span>(</span>pushA<span>[</span>i<span>]</span><span>)</span><span>;</span>\n            <span>//如果栈不为空，且栈顶元素等于弹出序列</span>\n            <span>while</span><span>(</span><span>!</span>s<span>.</span><span>empty</span><span>(</span><span>)</span> <span>&amp;&amp;</span>s<span>.</span><span>peek</span><span>(</span><span>)</span> <span>==</span> popA<span>[</span>popIndex<span>]</span><span>)</span><span>{</span>\n                <span>//出栈</span>\n                s<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>\n                <span>//弹出序列向后一位</span>\n                popIndex<span>++</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> s<span>.</span><span>empty</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><hr>\n<section>\n<ol>\n<li id=\"footnote1\"><p>(n-1)/2 </p>\n</li>\n<li id=\"footnote2\"><p>(n-1)/2 </p>\n</li>\n</ol>\n</section>\n",
      "image": "https://img-blog.csdn.net/20160420134000174",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": []
    },
    {
      "title": "图",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/data-structure/%E5%9B%BE/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/data-structure/%E5%9B%BE/",
      "content_html": "<h1 id=\"图\"> 图</h1>\n<blockquote>\n<p>开头还是求点赞，求转发！原创优质公众号，希望大家能让更多人看到我们的文章。</p>\n<p>图片都是我们手绘的，可以说非常用心了！</p>\n</blockquote>\n<p>图是一种较为复杂的非线性结构。 <strong>为啥说其较为复杂呢？</strong></p>\n<p>根据前面的内容，我们知道：</p>\n<ul>\n<li>线性数据结构的元素满足唯一的线性关系，每个元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继。</li>\n<li>树形数据结构的元素之间有着明显的层次关系。</li>\n</ul>\n<p>但是，图形结构的元素之间的关系是任意的。</p>\n<p><strong>何为图呢？</strong> 简单来说，图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：<strong>G(V,E)</strong>，其中，G表示一个图，V表示顶点的集合，E表示边的集合。</p>\n<p>下图所展示的就是图这种数据结构，并且还是一张有向图。</p>\n<p><img src=\"./pictures/图/图.png\" alt=\"图\" /></p>\n<p>图在我们日常生活中的例子很多！比如我们在社交软件上好友关系就可以用图来表示。</p>\n<h2 id=\"图的基本概念\"> 图的基本概念</h2>\n<h3 id=\"顶点\"> 顶点</h3>\n<p>图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）</p>\n<p>对应到好友关系图，每一个用户就代表一个顶点。</p>\n<h3 id=\"边\"> 边</h3>\n<p>顶点之间的关系用边表示。</p>\n<p>对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。</p>\n<h3 id=\"度\"> 度</h3>\n<p>度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。</p>\n<p>对应到好友关系图，度就代表了某个人的好友数量。</p>\n<h3 id=\"无向图和有向图\"> 无向图和有向图</h3>\n<p>边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。</p>\n<p>有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图。</p>\n<h3 id=\"无权图和带权图\"> 无权图和带权图</h3>\n<p>对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。</p>\n<p>对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/数据结构/1*FvCzzcpYVwyB759QKoDCOQ.png\" alt=\"\" /></p>\n<h2 id=\"图的存储\"> 图的存储</h2>\n<h3 id=\"邻接矩阵存储\"> 邻接矩阵存储</h3>\n<p>邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。</p>\n<p>如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 <code>A[i][j]=n</code> 。</p>\n<p>在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，<code>A[i][j]</code>=1，当顶点i和顶点j没有关系时，<code>A[i][j]</code>=0。如下图所示：</p>\n<p><img src=\"./pictures/图/无向图的邻接矩阵存储.png\" alt=\"无向图的邻接矩阵存储\" /></p>\n<p>值得注意的是：<strong>无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。</strong></p>\n<p><img src=\"./pictures/图/有向图的邻接矩阵存储.png\" alt=\"有向图的邻接矩阵存储\" /></p>\n<p>邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间，</p>\n<h3 id=\"邻接表存储\"> 邻接表存储</h3>\n<p>针对上面邻接矩阵比较浪费内存空间的问题，诞生了图的另外一种存储方法—<strong>邻接表</strong> 。</p>\n<p>邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 <strong>邻接表</strong>。如下图所示：</p>\n<p><img src=\"./pictures/图/无向图的邻接表存储.png\" alt=\"无向图的邻接表存储\" /></p>\n<p><img src=\"./pictures/图/有向图的邻接表存储.png\" alt=\"有向图的邻接表存储\" /></p>\n<p>大家可以数一数邻接表中所存储的元素的个数以及图中边的条数，你会发现：</p>\n<ul>\n<li>在无向图中，邻接表元素个数等于边的条数的两倍，如左图所示的无向图中，边的条数为7，邻接表存储的元素个数为14。</li>\n<li>在有向图中，邻接表元素个数等于边的条数，如右图所示的有向图中，边的条数为8，邻接表存储的元素个数为8。</li>\n</ul>\n<h2 id=\"图的搜索\"> 图的搜索</h2>\n<h3 id=\"广度优先搜索\"> 广度优先搜索</h3>\n<p>广度优先搜索就像水面上的波纹一样一层一层向外扩展，如下图所示：</p>\n<p><img src=\"./pictures/图/广度优先搜索图示.png\" alt=\"广度优先搜索图示\" /></p>\n<p><strong>广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列</strong> 。具体过程如下图所示：</p>\n<p><strong>第1步：</strong></p>\n<p><img src=\"./pictures/图/广度优先搜索1.png\" alt=\"广度优先搜索1\" /></p>\n<p><strong>第2步：</strong></p>\n<p><img src=\"./pictures/图/广度优先搜索2.png\" alt=\"广度优先搜索2\" /></p>\n<p><strong>第3步：</strong></p>\n<p><img src=\"./pictures/图/广度优先搜索3.png\" alt=\"广度优先搜索3\" /></p>\n<p><strong>第4步：</strong></p>\n<p><img src=\"./pictures/图/广度优先搜索4.png\" alt=\"广度优先搜索4\" /></p>\n<p><strong>第5步：</strong></p>\n<p><img src=\"./pictures/图/广度优先搜索5.png\" alt=\"广度优先搜索5\" /></p>\n<p><strong>第6步：</strong></p>\n<p><img src=\"./pictures/图/广度优先搜索6.png\" alt=\"广度优先搜索6\" /></p>\n<h3 id=\"深度优先搜索\"> 深度优先搜索</h3>\n<p>深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”，如下图所示：</p>\n<p><img src=\"./pictures/图/深度优先搜索图示.png\" alt=\"深度优先搜索图示\" /></p>\n<p><strong>和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——栈</strong> 。具体过程如下图所示：</p>\n<p><strong>第1步：</strong></p>\n<p><img src=\"./pictures/图/深度优先搜索1.png\" alt=\"深度优先搜索1\" /></p>\n<p><strong>第2步：</strong></p>\n<p><img src=\"./pictures/图/深度优先搜索2.png\" alt=\"深度优先搜索1\" /></p>\n<p><strong>第3步：</strong></p>\n<p><img src=\"./pictures/图/深度优先搜索3.png\" alt=\"深度优先搜索1\" /></p>\n<p><strong>第4步：</strong></p>\n<p><img src=\"./pictures/图/深度优先搜索4.png\" alt=\"深度优先搜索1\" /></p>\n<p><strong>第5步：</strong></p>\n<p><img src=\"./pictures/图/深度优先搜索5.png\" alt=\"深度优先搜索1\" /></p>\n<p><strong>第6步：</strong></p>\n<p><img src=\"./pictures/图/深度优先搜索6.png\" alt=\"深度优先搜索1\" /></p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": []
    },
    {
      "title": "树",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/data-structure/%E6%A0%91/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/data-structure/%E6%A0%91/",
      "content_html": "<h1 id=\"树\"> 树</h1>\n<p>树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。</p>\n<p>一棵树具有以下特点：</p>\n<ol>\n<li>一棵树中的任意两个结点有且仅有唯一的一条路径连通。</li>\n<li>一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。</li>\n<li>一棵树不包含回路。</li>\n</ol>\n<p>下图就是一颗树，并且是一颗二叉树。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/二叉树-2.png\" alt=\"二叉树\" /></p>\n<p>如上图所示，通过上面这张图说明一下树中的常用概念：</p>\n<ul>\n<li><strong>节点</strong> ：树中的每个元素都可以统称为节点。</li>\n<li><strong>根节点</strong> ：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。</li>\n<li><strong>父节点</strong> ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。</li>\n<li><strong>子节点</strong> ：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。</li>\n<li><strong>兄弟节点</strong> ：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。</li>\n<li><strong>叶子节点</strong> ：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。</li>\n<li><strong>节点的高度</strong> ：该节点到叶子节点的最长路径所包含的边数。</li>\n<li><strong>节点的深度</strong> ：根节点到该节点的路径所包含的边数</li>\n<li><strong>节点的层数</strong> ：节点的深度+1。</li>\n<li><strong>树的高度</strong> ：根节点的高度。</li>\n</ul>\n<h2 id=\"二叉树的分类\"> 二叉树的分类</h2>\n<p><strong>二叉树</strong>（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。</p>\n<p><strong>二叉树</strong> 的分支通常被称作“<strong>左子树</strong>”或“<strong>右子树</strong>”。并且，<strong>二叉树</strong> 的分支具有左右次序，不能随意颠倒。</p>\n<p><strong>二叉树</strong> 的第 i 层至多拥有 <code>2^(i-1)</code> 个节点，深度为 k 的二叉树至多总共有 <code>2^k-1</code> 个节点</p>\n<h3 id=\"满二叉树\"> 满二叉树</h3>\n<p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 <strong>满二叉树</strong>。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 <strong>满二叉树</strong>。如下图所示：</p>\n<p><img src=\"./pictures/树/满二叉树.png\" alt=\"\" /></p>\n<h3 id=\"完全二叉树\"> 完全二叉树</h3>\n<p>除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 <strong>完全二叉树</strong> 。</p>\n<p>大家可以想象为一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层。如下图所示：</p>\n<p><img src=\"./pictures/树/完全二叉树.png\" alt=\"\" /></p>\n<p>完全二叉树有一个很好的性质：<strong>父结点和子节点的序号有着对应关系。</strong></p>\n<p>细心的小伙伴可能发现了，当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点，后续二叉树的存储会详细介绍。</p>\n<h3 id=\"平衡二叉树\"> 平衡二叉树</h3>\n<p><strong>平衡二叉树</strong> 是一棵二叉排序树，且具有以下性质：</p>\n<ol>\n<li>可以是一棵空树</li>\n<li>如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</li>\n</ol>\n<p>平衡二叉树的常用实现方法有 <strong>红黑树</strong>、<strong>AVL 树</strong>、<strong>替罪羊树</strong>、<strong>加权平衡树</strong>、<strong>伸展树</strong> 等。</p>\n<p>在给大家展示平衡二叉树之前，先给大家看一棵树：</p>\n<p><img src=\"./pictures/树/斜树.png\" alt=\"\" /></p>\n<p><strong>你管这玩意儿叫树？？？</strong></p>\n<p>没错，这玩意儿还真叫树，只不过这棵树已经退化为一个链表了，我们管它叫 <strong>斜树</strong>。</p>\n<p><strong>如果这样，那我为啥不直接用链表呢?</strong></p>\n<p>谁说不是呢？</p>\n<p>二叉树相比于链表，由于父子节点以及兄弟节点之间往往具有某种特殊的关系，这种关系使得我们在树中对数据进行<strong>搜索</strong>和<strong>修改</strong>时，相对于链表更加快捷便利。</p>\n<p>但是，如果二叉树退化为一个链表了，那么那么树所具有的优秀性质就难以表现出来，效率也会大打折，为了避免这样的情况，我们希望每个做 “家长”（父结点） 的，都 <strong>一碗水端平</strong>，分给左儿子和分给右儿子的尽可能一样多，相差最多不超过一层，如下图所示：</p>\n<p><img src=\"./pictures/树/平衡二叉树.png\" alt=\"\" /></p>\n<h2 id=\"二叉树的存储\"> 二叉树的存储</h2>\n<p>二叉树的存储主要分为 <strong>链式存储</strong> 和 <strong>顺序存储</strong> 两种：</p>\n<h3 id=\"链式存储\"> 链式存储</h3>\n<p>和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。</p>\n<p>每个节点包括三个属性：</p>\n<ul>\n<li>数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。</li>\n<li>左节点指针 left</li>\n<li>右节点指针 right。</li>\n</ul>\n<p>可是 JAVA 没有指针啊！</p>\n<p>那就直接引用对象呗（别问我对象哪里找）</p>\n<p><img src=\"./pictures/树/链式存储二叉树.png\" alt=\"\" /></p>\n<h3 id=\"顺序存储\"> 顺序存储</h3>\n<p>顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2 _ i 的位置，它的右子节点存储在下标为 2 _ i+1 的位置。</p>\n<p>一棵完全二叉树的数组顺序存储如下图所示：</p>\n<p><img src=\"./pictures/树/顺序存储.png\" alt=\"\" /></p>\n<p>大家可以试着填写一下存储如下二叉树的数组，比较一下和完全二叉树的顺序存储有何区别：</p>\n<p><img src=\"./pictures/树/顺序存储2.png\" alt=\"\" /></p>\n<p>可以看到，如果我们要存储的二叉树不是完全二叉树，在数组中就会出现空隙，导致内存利用率降低</p>\n<h2 id=\"二叉树的遍历\"> 二叉树的遍历</h2>\n<h3 id=\"先序遍历\"> 先序遍历</h3>\n<p><img src=\"./pictures/树/先序遍历.png\" alt=\"\" /></p>\n<p>二叉树的先序遍历，就是先输出根结点，再遍历左子树，最后遍历右子树，遍历左子树和右子树的时候，同样遵循先序遍历的规则，也就是说，我们可以递归实现先序遍历。</p>\n<p>代码如下：</p>\n<div><pre><code><span>public</span> <span>void</span> <span>preOrder</span><span>(</span><span>TreeNode</span> root<span>)</span><span>{</span>\n\t<span>if</span><span>(</span>root <span>==</span> <span>null</span><span>)</span><span>{</span>\n\t\t<span>return</span><span>;</span>\n\t<span>}</span>\n\tsystem<span>.</span>out<span>.</span><span>println</span><span>(</span>root<span>.</span>data<span>)</span><span>;</span>\n\t<span>preOrder</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>\n\t<span>preOrder</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"中序遍历\"> 中序遍历</h3>\n<p><img src=\"./pictures/树/中序遍历.png\" alt=\"\" /></p>\n<p>二叉树的中序遍历，就是先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树，大家可以想象成一巴掌把树压扁，父结点被拍到了左子节点和右子节点的中间，如下图所示：</p>\n<p><img src=\"./pictures/树/中序遍历2.png\" alt=\"\" /></p>\n<p>代码如下：</p>\n<div><pre><code><span>public</span> <span>void</span> <span>inOrder</span><span>(</span><span>TreeNode</span> root<span>)</span><span>{</span>\n\t<span>if</span><span>(</span>root <span>==</span> <span>null</span><span>)</span><span>{</span>\n\t\t<span>return</span><span>;</span>\n\t<span>}</span>\n\t<span>inOrder</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>\n\tsystem<span>.</span>out<span>.</span><span>println</span><span>(</span>root<span>.</span>data<span>)</span><span>;</span>\n\t<span>inOrder</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"后序遍历\"> 后序遍历</h3>\n<p><img src=\"./pictures/树/后序遍历.png\" alt=\"\" /></p>\n<p>二叉树的后序遍历，就是先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值</p>\n<p>代码如下：</p>\n<div><pre><code><span>public</span> <span>void</span> <span>postOrder</span><span>(</span><span>TreeNode</span> root<span>)</span><span>{</span>\n\t<span>if</span><span>(</span>root <span>==</span> <span>null</span><span>)</span><span>{</span>\n\t\t<span>return</span><span>;</span>\n\t<span>}</span>\n\t<span>postOrder</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>\n\t<span>postOrder</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>\n\tsystem<span>.</span>out<span>.</span><span>println</span><span>(</span>root<span>.</span>data<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/二叉树-2.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": []
    },
    {
      "title": "堆",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/data-structure/%E5%A0%86/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/data-structure/%E5%A0%86/",
      "content_html": "<h1 id=\"堆\"> 堆</h1>\n<h2 id=\"什么是堆\"> 什么是堆</h2>\n<p>堆是一种满足以下条件的树：</p>\n<p>堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p>\n<blockquote>\n<p>大家可以把堆(最大堆)理解为一个公司,这个公司很公平,谁能力强谁就当老大,不存在弱的人当老大,老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。</p>\n</blockquote>\n<p><strong>!!!特别提示：</strong></p>\n<ul>\n<li>很多博客说堆是完全二叉树，其实并非如此，<strong>堆不一定是完全二叉树</strong>，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。</li>\n<li>（<strong>二叉</strong>）堆是一个数组，它可以被看成是一个 <strong>近似的完全二叉树</strong>。——《算法导论》第三版</li>\n</ul>\n<p>大家可以尝试判断下面给出的图是否是堆？</p>\n<p><img src=\"./pictures/堆/堆1.png\" alt=\"\" /></p>\n<p>第1个和第2个是堆。第1个是最大堆，每个节点都比子树中所有节点大。第2个是最小堆，每个节点都比子树中所有节点小。</p>\n<p>第3个不是，第三个中，根结点1比2和15小，而15却比3大，19比5大，不满足堆的性质。</p>\n<h2 id=\"堆的用途\"> 堆的用途</h2>\n<p>当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。</p>\n<p>有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 <code>O(nlog(n))</code>，查找最大值或者最小值时间复杂度都是 <code>O(1)</code>，但是，涉及到更新（插入或删除）数据时，时间复杂度为 <code>O(n)</code>，即使是使用复杂度为 <code>O(log(n))</code> 的二分法找到要插入或者删除的数据，在移动数据时也需要 <code>O(n)</code> 的时间复杂度。</p>\n<p><strong>相对于有序数组而言，堆的主要优势在于更新数据效率较高。</strong> 堆的初始化时间复杂度为 <code>O(nlog(n))</code>，堆可以做到<code>O(1)</code>时间复杂度取出最大值或者最小值，<code>O(log(n))</code>时间复杂度插入或者删除数据，具体操作在后续章节详细介绍。</p>\n<h2 id=\"堆的分类\"> 堆的分类</h2>\n<p>堆分为 <strong>最大堆</strong> 和 <strong>最小堆</strong>。二者的区别在于节点的排序方式。</p>\n<ul>\n<li><strong>最大堆</strong> ：堆中的每一个节点的值都大于等于子树中所有节点的值</li>\n<li><strong>最小堆</strong> ：堆中的每一个节点的值都小于等于子树中所有节点的值</li>\n</ul>\n<p>如下图所示，图1是最大堆，图2是最小堆</p>\n<p><img src=\"./pictures/堆/堆2.png\" alt=\"\" /></p>\n<h2 id=\"堆的存储\"> 堆的存储</h2>\n<p>之前介绍树的时候说过，由于完全二叉树的优秀性质，利用数组存储二叉树即节省空间，又方便索引（若根结点的序号为1，那么对于树中任意节点i，其左子节点序号为 <code>2*i</code>，右子节点序号为 <code>2*i+1</code>）。</p>\n<p>为了方便存储和索引，（二叉）堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：</p>\n<p><img src=\"./pictures/堆/堆的存储.png\" alt=\"堆的存储\" /></p>\n<h2 id=\"堆的操作\"> 堆的操作</h2>\n<p>堆的更新操作主要包括两种 :  <strong>插入元素</strong> 和 <strong>删除堆顶元素</strong>。操作过程需要着重掌握和理解。</p>\n<blockquote>\n<p>在进入正题之前，再重申一遍，堆是一个公平的公司，有能力的人自然会走到与他能力所匹配的位置</p>\n</blockquote>\n<h3 id=\"插入元素\"> 插入元素</h3>\n<blockquote>\n<p>插入元素，作为一个新入职的员工，初来乍到，这个员工需要从基层做起</p>\n</blockquote>\n<p><strong>1.将要插入的元素放到最后</strong></p>\n<p><img src=\"./pictures/堆/堆-插入元素1.png\" alt=\"堆-插入元素-1\" /></p>\n<blockquote>\n<p>有能力的人会逐渐升职加薪，是金子总会发光的！！！</p>\n</blockquote>\n<p><strong>2.从底向上，如果父结点比该元素大，则该节点和父结点交换，直到无法交换</strong></p>\n<p><img src=\"./pictures/堆/堆-插入元素2.png\" alt=\"堆-插入元素2\" /></p>\n<p><img src=\"./pictures/堆/堆-插入元素3.png\" alt=\"堆-插入元素3\" /></p>\n<h3 id=\"删除堆顶元素\"> 删除堆顶元素</h3>\n<p>根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。</p>\n<p>删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为&quot;<strong>堆化</strong>&quot;，堆化的方法分为两种：</p>\n<ul>\n<li>一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。</li>\n<li>另一种是自顶向下堆化，元素由最顶部向下移动。在讲解删除堆顶元素的方法时，我将阐述这两种操作的过程，大家可以体会一下二者的不同。</li>\n</ul>\n<h4 id=\"自底向上堆化\"> 自底向上堆化</h4>\n<blockquote>\n<p>在堆这个公司中，会出现老大离职的现象，老大离职之后，他的位置就空出来了</p>\n</blockquote>\n<p>首先删除堆顶元素，使得数组中下标为1的位置空出。</p>\n<p><img src=\"./pictures/堆/删除堆顶元素1.png\" alt=\"删除堆顶元素1\" /></p>\n<blockquote>\n<p>那么他的位置由谁来接替呢，当然是他的直接下属了，谁能力强就让谁上呗</p>\n</blockquote>\n<p>比较根结点的左子节点和右子节点，也就是下标为2,3的数组元素，将较大的元素填充到根结点(下标为1)的位置。</p>\n<p><img src=\"./pictures/堆/删除堆顶元素2.png\" alt=\"删除堆顶元素2\" /></p>\n<blockquote>\n<p>这个时候又空出一个位置了，老规矩，谁有能力谁上</p>\n</blockquote>\n<p>一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部</p>\n<p><img src=\"./pictures/堆/删除堆顶元素3.png\" alt=\"删除堆顶元素3\" /></p>\n<p>这个时候已经完成了自底向上的堆化，没有元素可以填补空缺了，但是，我们可以看到数组中出现了“气泡”，这会导致存储空间的浪费。接下来我们试试自顶向下堆化。</p>\n<h4 id=\"自顶向下堆化\"> 自顶向下堆化</h4>\n<p>自顶向下的堆化用一个词形容就是“石沉大海”，那么第一件事情，就是把石头抬起来，从海面扔下去。这个石头就是堆的最后一个元素，我们将最后一个元素移动到堆顶。</p>\n<p><img src=\"./pictures/堆/删除堆顶元素4.png\" alt=\"删除堆顶元素4\" /></p>\n<p>然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。</p>\n<p><img src=\"./pictures/堆/删除堆顶元素5.png\" alt=\"删除堆顶元素5\" /></p>\n<p><img src=\"./pictures/堆/删除堆顶元素6.png\" alt=\"删除堆顶元素6\" /></p>\n<h3 id=\"堆的操作总结\"> 堆的操作总结</h3>\n<ul>\n<li><strong>插入元素</strong> ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮</li>\n<li><strong>删除堆顶元素</strong> ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。</li>\n</ul>\n<h2 id=\"堆排序\"> 堆排序</h2>\n<p>堆排序的过程分为两步：</p>\n<ul>\n<li>第一步是建堆，将一个无序的数组建立为一个堆</li>\n<li>第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。</li>\n</ul>\n<h3 id=\"建堆\"> 建堆</h3>\n<p>如果你已经足够了解堆化的过程，那么建堆的过程掌握起来就比较容易了。建堆的过程就是一个对所有非叶节点的自顶向下堆化过程。</p>\n<p>首先要了解哪些是非叶节点，最后一个节点的父结点及它之前的元素，都是非叶节点。也就是说，如果节点个数为n，那么我们需要对n/2到1的节点进行自顶向下（沉底）堆化。</p>\n<p>具体过程如下图：</p>\n<p><img src=\"./pictures/堆/建堆1.png\" alt=\"建堆1\" /></p>\n<p>将初始的无序数组抽象为一棵树，图中的节点个数为6，所以4,5,6节点为叶节点，1,2,3节点为非叶节点，所以要对1-3号节点进行自顶向下（沉底）堆化，注意，顺序是从后往前堆化，从3号节点开始，一直到1号节点。\n3号节点堆化结果：</p>\n<p><img src=\"./pictures/堆/建堆2.png\" alt=\"建堆1\" /></p>\n<p>2号节点堆化结果：</p>\n<p><img src=\"./pictures/堆/建堆3.png\" alt=\"建堆1\" /></p>\n<p>1号节点堆化结果：</p>\n<p><img src=\"./pictures/堆/建堆4.png\" alt=\"建堆1\" /></p>\n<p>至此，数组所对应的树已经成为了一个最大堆，建堆完成！</p>\n<h3 id=\"排序\"> 排序</h3>\n<p>由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。</p>\n<p>现在思考两个问题：</p>\n<ul>\n<li>删除堆顶元素后需要执行自顶向下（沉底）堆化还是自底向上（上浮）堆化？</li>\n<li>取出的堆顶元素存在哪，新建一个数组存？</li>\n</ul>\n<p>先回答第一个问题，我们需要执行自顶向下（沉底）堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将取出的元素放在末尾。</p>\n<p>机智的小伙伴已经发现了，这其实是做了一次交换操作，将堆顶和末尾元素调换位置，从而将取出堆顶元素和堆化的第一步(将末尾元素放至根结点位置)进行合并。</p>\n<p>详细过程如下图所示：</p>\n<p>取出第一个元素并堆化：</p>\n<p><img src=\"./pictures/堆/堆排序1.png\" alt=\"堆排序1\" /></p>\n<p>取出第二个元素并堆化：</p>\n<p><img src=\"./pictures/堆/堆排序2.png\" alt=\"堆排序2\" /></p>\n<p>取出第三个元素并堆化：</p>\n<p><img src=\"./pictures/堆/堆排序3.png\" alt=\"堆排序3\" /></p>\n<p>取出第四个元素并堆化：</p>\n<p><img src=\"./pictures/堆/堆排序4.png\" alt=\"堆排序4\" /></p>\n<p>取出第五个元素并堆化：</p>\n<p><img src=\"./pictures/堆/堆排序5.png\" alt=\"堆排序5\" /></p>\n<p>取出第六个元素并堆化：</p>\n<p><img src=\"./pictures/堆/堆排序6.png\" alt=\"堆排序6\" /></p>\n<p>堆排序完成！</p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": []
    },
    {
      "title": "线性数据结构",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/data-structure/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/data-structure/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",
      "content_html": "<h1 id=\"线性数据结构\"> 线性数据结构</h1>\n<blockquote>\n<p>开头还是求点赞，求转发！原创优质公众号，希望大家能让更多人看到我们的文章。</p>\n<p>图片都是我们手绘的，可以说非常用心了！</p>\n</blockquote>\n<h2 id=\"_1-数组\"> 1. 数组</h2>\n<p><strong>数组（Array）</strong> 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。</p>\n<p>我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。</p>\n<p>数组的特点是：<strong>提供随机访问</strong> 并且容量有限。</p>\n<div><pre><code>假如数组的长度为 n。\n访问：<span>O</span>（<span>1</span>）<span>//访问特定位置的元素</span>\n插入：<span>O</span>（n ）<span>//最坏的情况发生在插入发生在数组的首部并需要移动所有元素时</span>\n删除：<span>O</span>（n）<span>//最坏的情况发生在删除数组的开头发生并需要移动第一元素后面所有的元素时</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/数组.png\" alt=\"数组\" /></p>\n<h2 id=\"_2-链表\"> 2. 链表</h2>\n<h3 id=\"_2-1-链表简介\"> 2.1. 链表简介</h3>\n<p><strong>链表（LinkedList）</strong> 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。</p>\n<p>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。</p>\n<p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p>\n<h3 id=\"_2-2-链表分类\"> 2.2. 链表分类</h3>\n<p><strong>常见链表分类：</strong></p>\n<ol>\n<li>单链表</li>\n<li>双向链表</li>\n<li>循环链表</li>\n<li>双向循环链表</li>\n</ol>\n<div><pre><code>假如链表中有n个元素。\n访问：<span>O</span>（n）<span>//访问特定位置的元素</span>\n插入删除：<span>O</span>（<span>1</span>）<span>//必须要要知道插入元素的位置</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"_2-2-1-单链表\"> 2.2.1. 单链表</h4>\n<p><strong>单链表</strong> 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/单链表2.png\" alt=\"单链表\" /></p>\n<h4 id=\"_2-2-2-循环链表\"> 2.2.2. 循环链表</h4>\n<p><strong>循环链表</strong> 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/循环链表2.png\" alt=\"循环链表\" /></p>\n<h4 id=\"_2-2-3-双向链表\"> 2.2.3. 双向链表</h4>\n<p><strong>双向链表</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向链表.png\" alt=\"双向链表\" /></p>\n<h4 id=\"_2-2-4-双向循环链表\"> 2.2.4. 双向循环链表</h4>\n<p><strong>双向循环链表</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向循环链表.png\" alt=\"双向循环链表\" /></p>\n<h3 id=\"_2-3-应用场景\"> 2.3. 应用场景</h3>\n<ul>\n<li>如果需要支持随机访问的话，链表没办法做到。</li>\n<li>如果需要存储的数据元素的个数不确定，并且需要经常添加和删除数据的话，使用链表比较合适。</li>\n<li>如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适。</li>\n</ul>\n<h3 id=\"_2-4-数组-vs-链表\"> 2.4. 数组 vs 链表</h3>\n<ul>\n<li>数组支持随机访问，而链表不支持。</li>\n<li>数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</li>\n<li>数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！</li>\n</ul>\n<h2 id=\"_3-栈\"> 3. 栈</h2>\n<h3 id=\"_3-1-栈简介\"> 3.1. 栈简介</h3>\n<p><strong>栈</strong> (stack)只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 <strong>后进先出（LIFO, Last In First Out）</strong> 的原理运作。<strong>在栈中，push 和 pop 的操作都发生在栈顶。</strong></p>\n<p>栈常用一维数组或链表来实现，用数组实现的栈叫作 <strong>顺序栈</strong> ，用链表实现的栈叫作 <strong>链式栈</strong> 。</p>\n<div><pre><code>假设堆栈中有n个元素。\n访问：<span>O</span>（n）<span>//最坏情况</span>\n插入删除：<span>O</span>（<span>1</span>）<span>//顶端插入和删除元素</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/栈.png\" alt=\"栈\" /></p>\n<h3 id=\"_3-2-栈的常见应用常见应用场景\"> 3.2. 栈的常见应用常见应用场景</h3>\n<p>当我们我们要处理的数据只涉及在一端插入和删除数据，并且满足 <strong>后进先出（LIFO, Last In First Out）</strong> 的特性时，我们就可以使用栈这个数据结构。</p>\n<h4 id=\"_3-2-1-实现浏览器的回退和前进功能\"> 3.2.1. 实现浏览器的回退和前进功能</h4>\n<p>我们只需要使用两个栈(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 1,2,3,4 这四个页面压入 Stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。示例图如下:</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/栈实现浏览器倒退和前进.png\" alt=\"栈实现浏览器倒退和前进\" /></p>\n<h4 id=\"_3-2-2-检查符号是否成对出现\"> 3.2.2. 检查符号是否成对出现</h4>\n<blockquote>\n<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串，判断该字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<ol>\n<li>左括号必须用相同类型的右括号闭合。</li>\n<li>左括号必须以正确的顺序闭合。</li>\n</ol>\n<p>比如 &quot;()&quot;、&quot;()[]{}&quot;、&quot;{[]}&quot; 都是有效字符串，而 &quot;(]&quot; 、&quot;([)]&quot; 则不是。</p>\n</blockquote>\n<p>这个问题实际是 Leetcode 的一道题目，我们可以利用栈 <code>Stack</code> 来解决这个问题。</p>\n<ol>\n<li>首先我们将括号间的对应规则存放在 <code>Map</code> 中，这一点应该毋容置疑；</li>\n<li>创建一个栈。遍历字符串，如果字符是左括号就直接加入<code>stack</code>中，否则将<code>stack</code> 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果<code>stack</code>为空，返回 <code>true</code>。</li>\n</ol>\n<div><pre><code><span>public</span> <span>boolean</span> <span>isValid</span><span>(</span><span>String</span> s<span>)</span><span>{</span>\n    <span>// 括号之间的对应规则</span>\n    <span>HashMap</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>Character</span><span>></span></span> mappings <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>Character</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    mappings<span>.</span><span>put</span><span>(</span><span>')'</span><span>,</span> <span>'('</span><span>)</span><span>;</span>\n    mappings<span>.</span><span>put</span><span>(</span><span>'}'</span><span>,</span> <span>'{'</span><span>)</span><span>;</span>\n    mappings<span>.</span><span>put</span><span>(</span><span>']'</span><span>,</span> <span>'['</span><span>)</span><span>;</span>\n    <span>Stack</span><span><span>&lt;</span><span>Character</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>Character</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>char</span><span>[</span><span>]</span> chars <span>=</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> chars<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>mappings<span>.</span><span>containsKey</span><span>(</span>chars<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>{</span>\n            <span>char</span> topElement <span>=</span> stack<span>.</span><span>empty</span><span>(</span><span>)</span> <span>?</span> <span>'#'</span> <span>:</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>topElement <span>!=</span> mappings<span>.</span><span>get</span><span>(</span>chars<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>{</span>\n                <span>return</span> <span>false</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            stack<span>.</span><span>push</span><span>(</span>chars<span>[</span>i<span>]</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h4 id=\"_3-2-3-反转字符串\"> 3.2.3. 反转字符串</h4>\n<p>将字符串中的每个字符先入栈再出栈就可以了。</p>\n<h4 id=\"_3-2-4-维护函数调用\"> 3.2.4. 维护函数调用</h4>\n<p>最后一个被调用的函数必须先完成执行，符合栈的 <strong>后进先出（LIFO, Last In First Out）</strong> 特性。</p>\n<h3 id=\"_3-3-栈的实现\"> 3.3. 栈的实现</h3>\n<p>栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。</p>\n<p>下面我们使用数组来实现一个栈，并且这个栈具有<code>push()</code>、<code>pop()</code>（返回栈顶元素并出栈）、<code>peek()</code> （返回栈顶元素不出栈）、<code>isEmpty()</code>、<code>size()</code>这些基本的方法。</p>\n<blockquote>\n<p>提示：每次入栈之前先判断栈的容量是否够用，如果不够用就用<code>Arrays.copyOf()</code>进行扩容；</p>\n</blockquote>\n<div><pre><code><span>public</span> <span>class</span> <span>MyStack</span> <span>{</span>\n    <span>private</span> <span>int</span><span>[</span><span>]</span> storage<span>;</span><span>//存放栈中元素的数组</span>\n    <span>private</span> <span>int</span> capacity<span>;</span><span>//栈的容量</span>\n    <span>private</span> <span>int</span> count<span>;</span><span>//栈中元素数量</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> GROW_FACTOR <span>=</span> <span>2</span><span>;</span>\n\n    <span>//不带初始容量的构造方法。默认容量为8</span>\n    <span>public</span> <span>MyStack</span><span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>capacity <span>=</span> <span>8</span><span>;</span>\n        <span>this</span><span>.</span>storage<span>=</span><span>new</span> <span>int</span><span>[</span><span>8</span><span>]</span><span>;</span>\n        <span>this</span><span>.</span>count <span>=</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>//带初始容量的构造方法</span>\n    <span>public</span> <span>MyStack</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>initialCapacity <span>&lt;</span> <span>1</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Capacity too small.\"</span><span>)</span><span>;</span>\n\n        <span>this</span><span>.</span>capacity <span>=</span> initialCapacity<span>;</span>\n        <span>this</span><span>.</span>storage <span>=</span> <span>new</span> <span>int</span><span>[</span>initialCapacity<span>]</span><span>;</span>\n        <span>this</span><span>.</span>count <span>=</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>//入栈</span>\n    <span>public</span> <span>void</span> <span>push</span><span>(</span><span>int</span> value<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>count <span>==</span> capacity<span>)</span> <span>{</span>\n            <span>ensureCapacity</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        storage<span>[</span>count<span>++</span><span>]</span> <span>=</span> value<span>;</span>\n    <span>}</span>\n\n    <span>//确保容量大小</span>\n    <span>private</span> <span>void</span> <span>ensureCapacity</span><span>(</span><span>)</span> <span>{</span>\n        <span>int</span> newCapacity <span>=</span> capacity <span>*</span> GROW_FACTOR<span>;</span>\n        storage <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>storage<span>,</span> newCapacity<span>)</span><span>;</span>\n        capacity <span>=</span> newCapacity<span>;</span>\n    <span>}</span>\n\n    <span>//返回栈顶元素并出栈</span>\n    <span>private</span> <span>int</span> <span>pop</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>count <span>==</span> <span>0</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Stack is empty.\"</span><span>)</span><span>;</span>\n        count<span>--</span><span>;</span>\n        <span>return</span> storage<span>[</span>count<span>]</span><span>;</span>\n    <span>}</span>\n\n    <span>//返回栈顶元素不出栈</span>\n    <span>private</span> <span>int</span> <span>peek</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>count <span>==</span> <span>0</span><span>)</span><span>{</span>\n            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Stack is empty.\"</span><span>)</span><span>;</span>\n        <span>}</span><span>else</span> <span>{</span>\n            <span>return</span> storage<span>[</span>count<span>-</span><span>1</span><span>]</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>//判断栈是否为空</span>\n    <span>private</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> count <span>==</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>//返回栈中元素的个数</span>\n    <span>private</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> count<span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br></div></div><p>验证</p>\n<div><pre><code><span>MyStack</span> myStack <span>=</span> <span>new</span> <span>MyStack</span><span>(</span><span>3</span><span>)</span><span>;</span>\nmyStack<span>.</span><span>push</span><span>(</span><span>1</span><span>)</span><span>;</span>\nmyStack<span>.</span><span>push</span><span>(</span><span>2</span><span>)</span><span>;</span>\nmyStack<span>.</span><span>push</span><span>(</span><span>3</span><span>)</span><span>;</span>\nmyStack<span>.</span><span>push</span><span>(</span><span>4</span><span>)</span><span>;</span>\nmyStack<span>.</span><span>push</span><span>(</span><span>5</span><span>)</span><span>;</span>\nmyStack<span>.</span><span>push</span><span>(</span><span>6</span><span>)</span><span>;</span>\nmyStack<span>.</span><span>push</span><span>(</span><span>7</span><span>)</span><span>;</span>\nmyStack<span>.</span><span>push</span><span>(</span><span>8</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myStack<span>.</span><span>peek</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//8</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myStack<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//8</span>\n<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>8</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myStack<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myStack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//true</span>\nmyStack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span><span>//报错：java.lang.IllegalArgumentException: Stack is empty.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"_4-队列\"> 4. 队列</h2>\n<h3 id=\"_4-1-队列简介\"> 4.1. 队列简介</h3>\n<p><strong>队列</strong> 是 <strong>先进先出( FIFO，First In, First Out)</strong> 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 <strong>顺序队列</strong> ，用链表实现的队列叫作 <strong>链式队列</strong> 。<strong>队列只允许在后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue</strong></p>\n<p>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p>\n<div><pre><code>假设队列中有n个元素。\n访问：<span>O</span>（n）<span>//最坏情况</span>\n插入删除：<span>O</span>（<span>1</span>）<span>//后端插入前端删除元素</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/队列.png\" alt=\"队列\" /></p>\n<h3 id=\"_4-2-队列分类\"> 4.2. 队列分类</h3>\n<h4 id=\"_4-2-1-单队列\"> 4.2.1. 单队列</h4>\n<p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 <strong>顺序队列（数组实现）</strong> 和 <strong>链式队列（链表实现）</strong>。</p>\n<p><strong>顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。</strong></p>\n<p>假设下图是一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear 移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 <strong>”假溢出“</strong> 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（越界）。</p>\n<blockquote>\n<p>为了避免当只有一个元素的时候，队头和队尾重合使处理变得麻烦，所以引入两个指针，front 指针指向对头元素，rear 指针指向队列最后一个元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。——From 《大话数据结构》</p>\n</blockquote>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/顺序队列假溢出1.png\" alt=\"顺序队列假溢出\" /></p>\n<h4 id=\"_4-2-2-循环队列\"> 4.2.2. 循环队列</h4>\n<p>循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。</p>\n<p>还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/循环队列.png\" alt=\"循环队列\" /></p>\n<p>顺序队列中，我们说 <code>front==rear</code> 的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种：</p>\n<ol>\n<li>可以设置一个标志变量 <code>flag</code>,当 <code>front==rear</code> 并且 <code>flag=0</code> 的时候队列为空，当<code>front==rear</code> 并且 <code>flag=1</code> 的时候队列为满。</li>\n<li>队列为空的时候就是 <code>front==rear</code> ，队列满的时候，我们保证数组还有一个空闲的位置，rear 就指向这个空闲位置，如下图所示，那么现在判断队列是否为满的条件就是： <code>(rear+1) % QueueSize= front</code> 。</li>\n</ol>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/循环队列-堆满.png\" alt=\"循环队列-队满\" /></p>\n<h3 id=\"_4-3-常见应用场景\"> 4.3. 常见应用场景</h3>\n<p>当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。</p>\n<ul>\n<li><strong>阻塞队列：</strong> 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。</li>\n<li><strong>线程池中的请求/任务队列：</strong> 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：<code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出<code>java.util.concurrent.RejectedExecutionException</code> 异常。</li>\n<li>Linux 内核进程队列（按优先级排队）</li>\n<li>现实生活中的派对，播放器上的播放列表;</li>\n<li>消息队列</li>\n<li>等等......</li>\n</ul>\n",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/数组.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": []
    },
    {
      "title": "HTTPS中的TLS",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/network/HTTPS%E4%B8%AD%E7%9A%84TLS/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/network/HTTPS%E4%B8%AD%E7%9A%84TLS/",
      "content_html": "<h1 id=\"_1-ssl-与-tls\"> 1. SSL 与 TLS</h1>\n<p>SSL：（Secure Socket Layer） 安全套接层，于 1994 年由网景公司设计，并于 1995 年发布了 3.0 版本<br>\nTLS：（Transport Layer Security）传输层安全性协议，是 IETF 在 SSL3.0 的基础上设计的协议<br>\n以下全部使用 TLS 来表示</p>\n<h1 id=\"_2-从网络协议的角度理解-https\"> 2. 从网络协议的角度理解 HTTPS</h1>\n<p><img src=\"https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/七层.png\" alt=\"此图并不准确\" /><br>\nHTTP：HyperText Transfer Protocol 超文本传输协议<br>\nHTTPS：Hypertext Transfer Protocol Secure 超文本传输安全协议<br>\nTLS：位于 HTTP 和 TCP 之间的协议，其内部有 TLS握手协议、TLS记录协议<br>\nHTTPS 经由 HTTP 进行通信，但利用 TLS 来保证安全，即 HTTPS = HTTP + TLS</p>\n<h1 id=\"_3-从密码学的角度理解-https\"> 3. 从密码学的角度理解 HTTPS</h1>\n<p>HTTPS 使用 TLS 保证安全，这里的“安全”分两部分，一是传输内容加密、二是服务端的身份认证</p>\n<h2 id=\"_3-1-tls-工作流程\"> 3.1. TLS 工作流程</h2>\n<p><img src=\"https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/tls流程.png\" alt=\"此图并不准确\" /><br>\n此为服务端单向认证，还有客户端/服务端双向认证，流程类似，只不过客户端也有自己的证书，并发送给服务器进行验证</p>\n<h2 id=\"_3-2-密码基础\"> 3.2. 密码基础</h2>\n<h3 id=\"_3-2-1-伪随机数生成器\"> 3.2.1. 伪随机数生成器</h3>\n<p>为什么叫伪随机数，因为没有真正意义上的随机数，具体可以参考 Random/TheadLocalRandom<br>\n它的主要作用在于生成对称密码的秘钥、用于公钥密码生成秘钥对</p>\n<h3 id=\"_3-2-2-消息认证码\"> 3.2.2. 消息认证码</h3>\n<p>消息认证码主要用于验证消息的完整性与消息的认证，其中消息的认证指“消息来自正确的发送者”</p>\n<blockquote>\n<p>消息认证码用于验证和认证，而不是加密</p>\n</blockquote>\n<p><img src=\"https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/消息认证码过程.png\" alt=\"消息认证码过程\" /></p>\n<ol>\n<li>发送者与接收者事先共享秘钥</li>\n<li>发送者根据发送消息计算 MAC 值</li>\n<li>发送者发送消息和 MAC 值</li>\n<li>接收者根据接收到的消息计算 MAC 值</li>\n<li>接收者根据自己计算的 MAC 值与收到的 MAC 对比</li>\n<li>如果对比成功，说明消息完整，并来自于正确的发送者</li>\n</ol>\n<h3 id=\"_3-2-3-数字签名\"> 3.2.3. 数字签名</h3>\n<p>消息认证码的缺点在于<strong>无法防止否认</strong>，因为共享秘钥被 client、server 两端拥有，server 可以伪造 client 发送给自己的消息（自己给自己发送消息），为了解决这个问题，我们需要它们有各自的秘钥不被第二个知晓（这样也解决了共享秘钥的配送问题）</p>\n<p><img src=\"https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/数字签名过程.png\" alt=\"数字签名过程\" /></p>\n<blockquote>\n<p>数字签名和消息认证码都<strong>不是为了加密</strong><br>\n可以将单向散列函数获取散列值的过程理解为使用 md5 摘要算法获取摘要的过程</p>\n</blockquote>\n<p>使用自己的私钥对自己所认可的消息生成一个该消息专属的签名，这就是数字签名，表明我承认该消息来自自己<br>\n注意：<strong>私钥用于加签，公钥用于解签，每个人都可以解签，查看消息的归属人</strong></p>\n<h3 id=\"_3-2-4-公钥密码\"> 3.2.4. 公钥密码</h3>\n<p>公钥密码也叫非对称密码，由公钥和私钥组成，它最开始是为了解决秘钥的配送传输安全问题，即，我们不配送私钥，只配送公钥，私钥由本人保管<br>\n它与数字签名相反，公钥密码的私钥用于解密、公钥用于加密，每个人都可以用别人的公钥加密，但只有对应的私钥才能解开密文<br>\nclient：明文 + 公钥 = 密文<br>\nserver：密文 + 私钥 = 明文<br>\n注意：<strong>公钥用于加密，私钥用于解密，只有私钥的归属者，才能查看消息的真正内容</strong></p>\n<h3 id=\"_3-2-5-证书\"> 3.2.5. 证书</h3>\n<p>证书：全称公钥证书（Public-Key Certificate, PKC）,里面保存着归属者的基本信息，以及证书过期时间、归属者的公钥，并由认证机构（Certification Authority, <strong>CA</strong>）施加数字签名，表明，某个认证机构认定该公钥的确属于此人</p>\n<blockquote>\n<p>想象这个场景：你想在支付宝页面交易，你需要支付宝的公钥进行加密通信，于是你从百度上搜索关键字“支付宝公钥”，你获得了支什宝的公钥，这个时候，支什宝通过中间人攻击，让你访问到了他们支什宝的页面，最后你在这个支什宝页面完美的使用了支什宝的公钥完成了与支什宝的交易\n<img src=\"https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/dns中间人攻击.png\" alt=\"证书过程\" /></p>\n</blockquote>\n<p>在上面的场景中，你可以理解支付宝证书就是由支付宝的公钥、和给支付宝颁发证书的企业的数字签名组成<br>\n任何人都可以给自己或别人的公钥添加自己的数字签名，表明：我拿我的尊严担保，我的公钥/别人的公钥是真的，至于信不信那是另一回事了</p>\n<h3 id=\"_3-2-6-密码小结\"> 3.2.6. 密码小结</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">密码</th>\n<th style=\"text-align:left\">作用</th>\n<th style=\"text-align:left\">组成</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">消息认证码</td>\n<td style=\"text-align:left\">确认消息的完整、并对消息的来源认证</td>\n<td style=\"text-align:left\">共享秘钥+消息的散列值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">数字签名</td>\n<td style=\"text-align:left\">对消息的散列值签名</td>\n<td style=\"text-align:left\">公钥+私钥+消息的散列值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">公钥密码</td>\n<td style=\"text-align:left\">解决秘钥的配送问题</td>\n<td style=\"text-align:left\">公钥+私钥+消息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">证书</td>\n<td style=\"text-align:left\">解决公钥的归属问题</td>\n<td style=\"text-align:left\">公钥密码中的公钥+数字签名</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_3-3-tls-使用的密码技术\"> 3.3. TLS 使用的密码技术</h2>\n<ol>\n<li>伪随机数生成器：秘钥生成随机性，更难被猜测</li>\n<li>对称密码：对称密码使用的秘钥就是由伪随机数生成，相较于非对称密码，效率更高</li>\n<li>消息认证码：保证消息信息的完整性、以及验证消息信息的来源</li>\n<li>公钥密码：证书技术使用的就是公钥密码</li>\n<li>数字签名：验证证书的签名，确定由真实的某个 CA 颁发</li>\n<li>证书：解决公钥的真实归属问题，降低中间人攻击概率</li>\n</ol>\n<h2 id=\"_3-4-tls-总结\"> 3.4. TLS 总结</h2>\n<p>TLS 是一系列密码工具的框架，作为框架，它也是非常的灵活，体现在每个工具套件它都可以替换，即：客户端与服务端之间协商密码套件，从而更难的被攻破，例如使用不同方式的对称密码，或者公钥密码、数字签名生成方式、单向散列函数技术的替换等</p>\n<h1 id=\"_4-rsa-简单示例\"> 4. RSA 简单示例</h1>\n<p>RSA 是一种公钥密码算法，我们简单的走一遍它的加密解密过程<br>\n加密算法：密文 = (明文^E) mod N，其中公钥为{E,N}，即”求明文的E次方的对 N 的余数“<br>\n解密算法：明文 = (密文^D) mod N，其中秘钥为{D,N}，即”求密文的D次方的对 N 的余数“<br>\n例：我们已知公钥为{5,323}，私钥为{29,323}，明文为300，请写出加密和解密的过程：</p>\n<blockquote>\n<p>加密：密文 = 123 ^ 5 mod 323 = 225<br>\n解密：明文 = 225 ^ 29 mod 323 = [[(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 4) mod 323]] mod 323 = (4 * 4 * 4 * 4 * 4 * 290) mod 323 = 123</p>\n</blockquote>\n<h1 id=\"_5-参考\"> 5. 参考</h1>\n<ol>\n<li>SSL加密发生在哪里：<a href=\"https://security.stackexchange.com/questions/19681/where-does-ssl-encryption-take-place\" target=\"_blank\" rel=\"noopener noreferrer\">https://security.stackexchange.com/questions/19681/where-does-ssl-encryption-take-place</a></li>\n<li>TLS工作流程：<a href=\"https://blog.csdn.net/ustccw/article/details/76691248\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/ustccw/article/details/76691248</a></li>\n<li>《图解密码技术》：<a href=\"https://book.douban.com/subject/26822106/\" target=\"_blank\" rel=\"noopener noreferrer\">https://book.douban.com/subject/26822106/</a> 豆瓣评分 9.5</li>\n</ol>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "后端程序员必备的 Linux 基础知识总结",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/operating-system/linux/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/operating-system/linux/",
      "content_html": "<p>简单介绍一下 Java 程序员必知的 Linux 的一些概念以及常见命令。</p>\n<p><em>如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！笔芯！</em></p>\n<h2 id=\"_1-从认识操作系统开始\"> 1. 从认识操作系统开始</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/image-20200807161118901.png\" alt=\"\" /></p>\n<p>正式开始 Linux 之前，简单花一点点篇幅科普一下操作系统相关的内容。</p>\n<h3 id=\"_1-1-操作系统简介\"> 1.1. 操作系统简介</h3>\n<p>我通过以下四点介绍什么是操作系统：</p>\n<ol>\n<li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li>\n<li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li>\n<li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li>\n<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。</li>\n</ol>\n<blockquote>\n<p>内核（Kernel）在后文中会提到。</p>\n</blockquote>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png\" alt=\"Kernel_Layout\" /></p>\n<h3 id=\"_1-2-操作系统简单分类\"> 1.2. 操作系统简单分类</h3>\n<h4 id=\"_1-2-1-windows\"> 1.2.1. Windows</h4>\n<p>目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。界面简单易操作，软件生态非常好。</p>\n<p><em>玩玩电脑游戏还是必须要有 Windows 的，所以我现在是一台 Windows 用于玩游戏，一台 Mac 用于平时日常开发和学习使用。</em></p>\n<p><img src=\"./images/windows.png\" alt=\"windows\" /></p>\n<h4 id=\"_1-2-2-unix\"> 1.2.2. Unix</h4>\n<p>最早的多用户、多任务操作系统 。后面崛起的 Linux 在很多方面都参考了 Unix。</p>\n<p>目前这款操作系统已经逐渐逐渐退出操作系统的舞台。</p>\n<p><img src=\"./images/unix.png\" alt=\"unix\" /></p>\n<h4 id=\"_1-2-3-linux\"> 1.2.3. Linux</h4>\n<p><strong>Linux 是一套免费使用、开源的类 Unix 操作系统。</strong> Linux 存在着许多不同的发行版本，但它们都使用了 <strong>Linux 内核</strong> 。</p>\n<blockquote>\n<p>严格来讲，Linux 这个词本身只表示 Linux 内核，在 GNU/Linux 系统中，Linux 实际就是 Linux 内核，而该系统的其余部分主要是由 GNU 工程编写和提供的程序组成。单独的 Linux 内核并不能成为一个可以正常工作的操作系统。</p>\n<p><strong>很多人更倾向使用 “GNU/Linux” 一词来表达人们通常所说的 “Linux”。</strong></p>\n</blockquote>\n<p><img src=\"./images/linux.png\" alt=\"linux\" /></p>\n<h4 id=\"_1-2-4-mac-os\"> 1.2.4. Mac OS</h4>\n<p>苹果自家的操作系统，编程体验和 Linux 相当，但是界面、软件生态以及用户体验各方面都要比 Linux 操作系统更好。</p>\n<p><img src=\"./images/macos.png\" alt=\"macos\" /></p>\n<h3 id=\"_1-3-操作系统的内核-kernel\"> 1.3. 操作系统的内核（Kernel）</h3>\n<p>我们先来看看维基百科对于内核的解释，我觉得总结的非常好！</p>\n<blockquote>\n<p><strong>内核</strong>（英语：Kernel，又称核心）在计算机科学中是一个用来管理软件发出的数据 I/O（输入与输出）要求的电脑程序，将这些要求转译为数据处理的指令并交由中央处理器（CPU）及电脑中其他电子组件进行处理，是现代操作系统中最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并由内核决定一个程序在什么时候对某部分硬件操作多长时间。 <strong>直接对硬件操作是非常复杂的。所以内核通常提供一种硬件抽象的方法，来完成这些操作。有了这个，通过进程间通信机制及系统调用，应用进程可间接控制所需的硬件资源（特别是处理器及 IO 设备）。</strong></p>\n<p>早期计算机系统的设计中，还没有操作系统的内核这个概念。随着计算机系统的发展，操作系统内核的概念才渐渐明晰起来了!</p>\n</blockquote>\n<p>简单概括两点：</p>\n<ol>\n<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</strong></li>\n<li><strong>操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。</strong></li>\n</ol>\n<h3 id=\"_1-4-中央处理器-cpu-central-processing-unit\"> 1.4. 中央处理器（CPU，Central Processing Unit）</h3>\n<p>关于 CPU 简单概括三点：</p>\n<ol>\n<li><strong>CPU 是一台计算机的运算核心（Core）+控制核心（ Control Unit），可以称得上是计算机的大脑。</strong></li>\n<li><strong>CPU 主要包括两个部分：控制器+运算器。</strong></li>\n<li><strong>CPU 的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。</strong></li>\n</ol>\n<h3 id=\"_1-5-cpu-vs-kernel-内核\"> 1.5. CPU vs Kernel(内核)</h3>\n<p>很多人容易无法区分操作系统的内核（Kernel）和中央处理器（CPU），你可以简单从下面两点来区别：</p>\n<ol>\n<li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li>\n<li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。</li>\n</ol>\n<p>下图清晰说明了应用程序、内核、CPU 这三者的关系。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png\" alt=\"Kernel_Layout\" /></p>\n<h3 id=\"_1-6-系统调用\"> 1.6. 系统调用</h3>\n<p>介绍系统调用之前，我们先来了解一下用户态和系统态。</p>\n<p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>\n<ol>\n<li><strong>用户态(user mode)</strong> : 用户态运行的进程或可以直接读取用户程序的数据。</li>\n<li><strong>系统态(kernel mode)</strong>: 可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>\n</ol>\n<p><strong>说了用户态和系统态之后，那么什么是系统调用呢？</strong></p>\n<p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p>\n<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>\n<p>这些系统调用按功能大致可分为如下几类：</p>\n<ul>\n<li><strong>设备管理</strong> ：完成设备的请求或释放，以及设备启动等功能。</li>\n<li><strong>文件管理</strong> ：完成文件的读、写、创建及删除等功能。</li>\n<li><strong>进程控制</strong> ：完成进程的创建、撤销、阻塞及唤醒等功能。</li>\n<li><strong>进程通信</strong> ：完成进程之间的消息传递或信号传递等功能。</li>\n<li><strong>内存管理</strong> ：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>\n</ul>\n<p>我在网上找了一个图，通过这个图可以很清晰的说明用户程序、系统调用、内核和硬件之间的关系。（<em>太难了~木有自己画</em>）</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/L181kk2Eou-compress.jpg\" alt=\"\" /></p>\n<h2 id=\"_2-初探-linux\"> 2. 初探 Linux</h2>\n<h3 id=\"_2-1-linux-简介\"> 2.1. Linux 简介</h3>\n<p>我们上面已经简单了 Linux，这里只强调三点。</p>\n<ul>\n<li><strong>类 Unix 系统</strong> ： Linux 是一种自由、开放源码的类似 Unix 的操作系统</li>\n<li><strong>Linux 本质是指 Linux 内核</strong> ： 严格来讲，Linux 这个词本身只表示 Linux 内核，单独的 Linux 内核并不能成为一个可以正常工作的操作系统。所以，就有了各种 Linux 发行版。</li>\n<li><strong>Linux 之父(林纳斯·本纳第克特·托瓦兹 Linus Benedict Torvalds)</strong> ： 一个编程领域的传奇式人物，真大佬！我辈崇拜敬仰之楷模。他是 <strong>Linux 内核</strong> 的最早作者，随后发起了这个开源项目，担任 Linux 内核的首要架构师。他还发起了 Git 这个开源项目，并为主要的开发者。</li>\n</ul>\n<p><img src=\"./images/Linux之父.png\" alt=\"Linux\" /></p>\n<h3 id=\"_2-2-linux-诞生\"> 2.2. Linux 诞生</h3>\n<p>1989 年，Linus Torvalds 进入芬兰陆军新地区旅，服 11 个月的国家义务兵役，军衔为少尉，主要服务于计算机部门，任务是弹道计算。服役期间，购买了安德鲁·斯图尔特·塔能鲍姆所著的教科书及 minix 源代码，开始研究操作系统。1990 年，他退伍后回到大学，开始接触 Unix。</p>\n<blockquote>\n<p><strong>Minix</strong> 是一个迷你版本的类 Unix 操作系统，由塔能鲍姆教授为了教学之用而创作，采用微核心设计。它启发了 Linux 内核的创作。</p>\n</blockquote>\n<p>1991 年，Linus Torvalds 开源了 Linux 内核。Linux 以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。</p>\n<p><img src=\"./images/Linux-Logo.png\" alt=\"OPINION: Make the switch to a Linux operating system | Opinion ...\" /></p>\n<h3 id=\"_2-3-常见-linux-发行版本有哪些\"> 2.3. 常见 Linux 发行版本有哪些？</h3>\n<p>Linus Torvalds 开源的只是 Linux 内核，我们上面也提到了操作系统内核的作用。一些组织或厂商将 Linux 内核与各种软件和文档包装起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。</p>\n<blockquote>\n<p>内核主要负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</p>\n</blockquote>\n<p>Linux 的发行版本可以大体分为两类：</p>\n<ul>\n<li>商业公司维护的发行版本，以著名的 Red Hat 为代表，比较典型的有 CentOS 。</li>\n<li>社区组织维护的发行版本，以 Debian 为代表，比较典型的有 Ubuntu、Debian。</li>\n</ul>\n<p>对于初学者学习 Linux ,推荐选择 CentOS 。</p>\n<h2 id=\"_3-linux-文件系统概览\"> 3. Linux 文件系统概览</h2>\n<h3 id=\"_3-1-linux-文件系统简介\"> 3.1. Linux 文件系统简介</h3>\n<p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong> 也就是说在 Linux 系统中有一个重要的概念：<strong>一切都是文件</strong>。</p>\n<p>其实这是 UNIX 哲学的一个体现，在 UNIX 系统中，把一切资源都看作是文件，Linux 的文件系统也是借鉴 UNIX 文件系统而来。</p>\n<h3 id=\"_3-2-inode-介绍\"> 3.2. inode 介绍</h3>\n<p><strong>inode 是 linux/unix 文件系统的基础。那么，inode 是什么?有什么作用呢?</strong></p>\n<p>硬盘的最小存储单位是扇区(Sector)，块(block)由多个扇区组成。文件数据存储在块中。块的最常见的大小是 4kb，约为 8 个连续的扇区组成（每个扇区存储 512 字节）。一个文件可能会占用多个 block，但是一个块只能存放一个文件。</p>\n<p>虽然，我们将文件存储在了块(block)中，但是我们还需要一个空间来存储文件的 <strong>元信息 metadata</strong> ：如某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种 <strong>存储文件元信息的区域就叫 inode</strong>，译为索引节点：<strong>i（index）+node</strong>。 每个文件都有一个 inode，存储文件的元信息。</p>\n<p>可以使用 <code>stat</code> 命令可以查看文件的 inode 信息。每个 inode 都有一个号码，Linux/Unix 操作系统不使用文件名来区分文件，而是使用 inode 号码区分不同的文件。</p>\n<p>简单来说：inode 就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</p>\n<p>简单总结一下：</p>\n<ul>\n<li><strong>inode</strong> ：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。</li>\n<li><strong>block</strong> ：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）</li>\n</ul>\n<p><img src=\"./images/文件inode信息.png\" alt=\"文件inode信息\" /></p>\n<h3 id=\"_3-3-linux-文件类型\"> 3.3. Linux 文件类型</h3>\n<p>Linux 支持很多文件类型，其中非常重要的文件类型有: <strong>普通文件</strong>，<strong>目录文件</strong>，<strong>链接文件</strong>，<strong>设备文件</strong>，<strong>管道文件</strong>，<strong>Socket 套接字文件</strong>等。</p>\n<ul>\n<li><strong>普通文件（-）</strong> ： 用于存储信息和数据， Linux 用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。</li>\n<li><strong>目录文件（d，directory file）</strong> ：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。</li>\n<li><strong>符号链接文件（l，symbolic link）</strong> ：保留了指向文件的地址而不是文件本身。</li>\n<li><strong>字符设备（c，char）</strong> ：用来访问字符设备比如键盘。</li>\n<li><strong>设备文件（b，block）</strong> ： 用来访问块设备比如硬盘、软盘。</li>\n<li><strong>管道文件(p,pipe)</strong> : 一种特殊类型的文件，用于进程之间的通信。</li>\n<li><strong>套接字(s,socket)</strong> ：用于进程间的网络通信，也可以用于本机之间的非网络通信。</li>\n</ul>\n<h3 id=\"_3-4-linux-目录树\"> 3.4. Linux 目录树</h3>\n<p>所有可操作的计算机资源都存在于目录树这个结构中，对计算资源的访问，可以看做是对这棵目录树的访问。</p>\n<p><strong>Linux 的目录结构如下：</strong></p>\n<p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：\n<img src=\"./images/Linux目录树.png\" alt=\"Linux的目录结构\" /></p>\n<p><strong>常见目录说明：</strong></p>\n<ul>\n<li><strong>/bin：</strong> 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；</li>\n<li><strong>/etc：</strong> 存放系统管理和配置文件；</li>\n<li><strong>/home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是/home/user，可以用~user 表示；</li>\n<li><strong>/usr ：</strong> 用于存放系统应用程序；</li>\n<li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；</li>\n<li><strong>/proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li>\n<li><strong>/root：</strong> 超级用户（系统管理员）的主目录（特权阶级<sup>o</sup>）；</li>\n<li><strong>/sbin:</strong> 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；</li>\n<li><strong>/dev：</strong> 用于存放设备文件；</li>\n<li><strong>/mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li>\n<li><strong>/boot：</strong> 存放用于系统引导时使用的各种文件；</li>\n<li><strong>/lib ：</strong> 存放着和系统运行相关的库文件 ；</li>\n<li><strong>/tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li>\n<li><strong>/var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li>\n<li><strong>/lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。</li>\n</ul>\n<h2 id=\"_4-linux-基本命令\"> 4. Linux 基本命令</h2>\n<p>下面只是给出了一些比较常用的命令。推荐一个 Linux 命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。</p>\n<p>Linux 命令大全：<a href=\"http://man.linuxde.net/\" target=\"_blank\" rel=\"noopener noreferrer\">http://man.linuxde.net/</a></p>\n<h3 id=\"_4-1-目录切换命令\"> 4.1. 目录切换命令</h3>\n<ul>\n<li><strong><code>cd usr</code>：</strong> 切换到该目录下 usr 目录</li>\n<li><strong><code>cd ..（或cd../）</code>：</strong> 切换到上一层目录</li>\n<li><strong><code>cd /</code>：</strong> 切换到系统根目录</li>\n<li><strong><code>cd ~</code>：</strong> 切换到用户主目录</li>\n<li><strong><code>cd -</code>：</strong> 切换到上一个操作所在目录</li>\n</ul>\n<h3 id=\"_4-2-目录的操作命令-增删改查\"> 4.2. 目录的操作命令(增删改查)</h3>\n<ul>\n<li><strong><code>mkdir 目录名称</code>：</strong> 增加目录。</li>\n<li><strong><code>ls/ll</code></strong>（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息。</li>\n<li><strong><code>find 目录 参数</code>：</strong> 寻找目录（查）。示例：① 列出当前目录及子目录下所有文件和文件夹: <code>find .</code>；② 在<code>/home</code>目录下查找以.txt 结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code> ,忽略大小写: <code>find /home -iname &quot;*.txt&quot;</code> ；③ 当前目录及子目录下查找所有以.txt 和.pdf 结尾的文件:<code>find . \\( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \\)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code>。</li>\n<li><strong><code>mv 目录名称 新目录名称</code>：</strong> 修改目录的名称（改）。注意：mv 的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到 mv 命令的另一个用法。</li>\n<li><strong><code>mv 目录名称 目录的新位置</code>：</strong> 移动目录的位置---剪切（改）。注意：mv 语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外 mv 与 cp 的结果不同，mv 好像文件“搬家”，文件个数并未增加。而 cp 对文件进行复制，文件个数增加了。</li>\n<li><strong><code>cp -r 目录名称 目录拷贝的目标位置</code>：</strong> 拷贝目录（改），-r 代表递归拷贝 。注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r 递归。</li>\n<li><strong><code>rm [-rf] 目录</code> :</strong> 删除目录（删）。注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用<code>rm -rf</code> 目录/文件/压缩包。</li>\n</ul>\n<h3 id=\"_4-3-文件的操作命令-增删改查\"> 4.3. 文件的操作命令(增删改查)</h3>\n<ul>\n<li><strong><code>touch 文件名称</code>:</strong> 文件的创建（增）。</li>\n<li><strong><code>cat/more/less/tail 文件名称</code></strong> ：文件的查看（查） 。命令 <code>tail -f 文件</code> 可以对某个文件进行动态监控，例如 tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 <code>tail -f catalina-2016-11-11.log</code> 监控 文 件的变化 。</li>\n<li><strong><code>vim 文件</code>：</strong> 修改文件的内容（改）。vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤： <code>vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入：wq/q!</code> （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。</li>\n<li><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）。</li>\n</ul>\n<h3 id=\"_4-4-压缩文件的操作命令\"> 4.4. 压缩文件的操作命令</h3>\n<p><strong>1）打包并压缩文件：</strong></p>\n<p>Linux 中的打包文件一般是以.tar 结尾的，压缩的命令一般是以.gz 结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。\n命令：<code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code> ，其中：</p>\n<ul>\n<li>z：调用 gzip 压缩命令进行压缩</li>\n<li>c：打包文件</li>\n<li>v：显示运行过程</li>\n<li>f：指定文件名</li>\n</ul>\n<p>比如：假如 test 目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包 test 目录并指定压缩后的压缩包名称为 test.tar.gz 可以使用命令：<strong><code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code></strong></p>\n<p><strong>2）解压压缩包：</strong></p>\n<p>命令：<code>tar [-xvf] 压缩文件</code></p>\n<p>其中：x：代表解压</p>\n<p>示例：</p>\n<ul>\n<li>将 /test 下的 test.tar.gz 解压到当前目录下可以使用命令：<strong><code>tar -xvf test.tar.gz</code></strong></li>\n<li>将 /test 下的 test.tar.gz 解压到根目录/usr 下:<strong><code>tar -xvf test.tar.gz -C /usr</code></strong>（- C 代表指定解压的位置）</li>\n</ul>\n<h3 id=\"_4-5-linux-的权限命令\"> 4.5. Linux 的权限命令</h3>\n<p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在 Linux 中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。</p>\n<p>通过 <strong><code>ls -l</code></strong> 命令我们可以 查看某个目录下的文件或目录的权限</p>\n<p>示例：在随意某个目录下<code>ls -l</code></p>\n<p><img src=\"./images/Linux权限命令.png\" alt=\"\" /></p>\n<p>第一列的内容的信息解释如下：</p>\n<p><img src=\"./images/Linux权限解读.png\" alt=\"\" /></p>\n<blockquote>\n<p>下面将详细讲解文件的类型、Linux 中权限以及文件有所有者、所在组、其它组具体是什么？</p>\n</blockquote>\n<p><strong>文件的类型：</strong></p>\n<ul>\n<li>d： 代表目录</li>\n<li>-： 代表文件</li>\n<li>l： 代表软链接（可以认为是 window 中的快捷方式）</li>\n</ul>\n<p><strong>Linux 中权限分为以下几种：</strong></p>\n<ul>\n<li>r：代表权限是可读，r 也可以用数字 4 表示</li>\n<li>w：代表权限是可写，w 也可以用数字 2 表示</li>\n<li>x：代表权限是可执行，x 也可以用数字 1 表示</li>\n</ul>\n<p><strong>文件和目录权限的区别：</strong></p>\n<p>对文件和目录而言，读写执行表示不同的意义。</p>\n<p>对于文件：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">权限名称</th>\n<th style=\"text-align:right\">可执行操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">r</td>\n<td style=\"text-align:right\">可以使用 cat 查看文件的内容</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">w</td>\n<td style=\"text-align:right\">可以修改文件的内容</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">x</td>\n<td style=\"text-align:right\">可以将其运行为二进制文件</td>\n</tr>\n</tbody>\n</table>\n<p>对于目录：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">权限名称</th>\n<th style=\"text-align:right\">可执行操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">r</td>\n<td style=\"text-align:right\">可以查看目录下列表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">w</td>\n<td style=\"text-align:right\">可以创建和删除目录下文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">x</td>\n<td style=\"text-align:right\">可以使用 cd 进入目录</td>\n</tr>\n</tbody>\n</table>\n<p>需要注意的是： <strong>超级用户可以无视普通用户的权限，即使文件目录权限是 000，依旧可以访问。</strong></p>\n<p><strong>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</strong></p>\n<ul>\n<li><strong>所有者(u)</strong> ：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用 <code>ls ‐ahl</code> 命令可以看到文件的所有者 也可以使用 chown 用户名 文件名来修改文件的所有者 。</li>\n<li><strong>文件所在组(g)</strong> ：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 <code>ls ‐ahl</code>命令可以看到文件的所有组也可以使用 chgrp 组名 文件名来修改文件所在的组。</li>\n<li><strong>其它组(o)</strong> ：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</li>\n</ul>\n<blockquote>\n<p>我们再来看看如何修改文件/目录的权限。</p>\n</blockquote>\n<p><strong>修改文件/目录的权限的命令：<code>chmod</code></strong></p>\n<p>示例：修改/test 下的 aaa.txt 的权限为文件所有者有全部权限，文件所有者所在的组有读写权限，其他用户只有读的权限。</p>\n<p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong> 或者 <strong><code>chmod 764 aaa.txt</code></strong></p>\n<p><img src=\"./images/修改文件权限.png\" alt=\"\" /></p>\n<p><strong>补充一个比较常用的东西:</strong></p>\n<p>假如我们装了一个 zookeeper，我们每次开机到要求其自动启动该怎么办？</p>\n<ol>\n<li>新建一个脚本 zookeeper</li>\n<li>为新建的脚本 zookeeper 添加可执行权限，命令是:<code>chmod +x zookeeper</code></li>\n<li>把 zookeeper 这个脚本添加到开机启动项里面，命令是：<code>chkconfig --add zookeeper</code></li>\n<li>如果想看看是否添加成功，命令是：<code>chkconfig --list</code></li>\n</ol>\n<h3 id=\"_4-6-linux-用户管理\"> 4.6. Linux 用户管理</h3>\n<p>Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>\n<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>\n<p><strong>Linux 用户管理相关命令:</strong></p>\n<ul>\n<li><code>useradd 选项 用户名</code>:添加用户账号</li>\n<li><code>userdel 选项 用户名</code>:删除用户帐号</li>\n<li><code>usermod 选项 用户名</code>:修改帐号</li>\n<li><code>passwd 用户名</code>:更改或创建用户的密码</li>\n<li><code>passwd -S 用户名</code> :显示用户账号密码信息</li>\n<li><code>passwd -d 用户名</code>: 清除用户密码</li>\n</ul>\n<p><code>useradd</code> 命令用于 Linux 中创建的新的系统用户。<code>useradd</code>可用来建立用户帐号。帐号建好之后，再用<code>passwd</code>设定帐号的密码．而可用<code>userdel</code>删除帐号。使用<code>useradd</code>指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code>文本文件中。</p>\n<p><code>passwd</code>命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p>\n<h3 id=\"_4-7-linux-系统用户组的管理\"> 4.7. Linux 系统用户组的管理</h3>\n<p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>\n<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p>\n<p><strong>Linux 系统用户组的管理相关命令:</strong></p>\n<ul>\n<li><code>groupadd 选项 用户组</code> :增加一个新的用户组</li>\n<li><code>groupdel 用户组</code>:要删除一个已有的用户组</li>\n<li><code>groupmod 选项 用户组</code> : 修改用户组的属性</li>\n</ul>\n<h3 id=\"_4-8-其他常用命令\"> 4.8. 其他常用命令</h3>\n<ul>\n<li>\n<p><strong><code>pwd</code>：</strong> 显示当前所在位置</p>\n</li>\n<li>\n<p><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p>\n</li>\n<li>\n<p><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，--color 代表高亮显示</p>\n</li>\n<li>\n<p><strong><code>ps -ef</code>/<code>ps -aux</code>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<strong><code>ps aux|grep redis</code></strong> （查看包括 redis 字符串的进程），也可使用 <code>pgrep redis -a</code>。</p>\n<p>注意：如果直接用 ps（（Process Status））命令，会显示所有进程的状态，通常结合 grep 命令查看某进程的状态。</p>\n</li>\n<li>\n<p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止。）</p>\n<p>先用 ps 查找进程，然后用 kill 杀掉</p>\n</li>\n<li>\n<p><strong>网络通信命令：</strong></p>\n<ul>\n<li>查看当前系统的网卡信息：ifconfig</li>\n<li>查看与某台机器的连接情况：ping</li>\n<li>查看当前系统的端口使用：netstat -an</li>\n</ul>\n</li>\n<li>\n<p><strong>net-tools 和 iproute2 ：</strong>\n<code>net-tools</code>起源于 BSD 的 TCP/IP 工具箱，后来成为老版本 LinuxLinux 中配置网络功能的工具。但自 2001 年起，Linux 社区已经对其停止维护。同时，一些 Linux 发行版比如 Arch Linux 和 CentOS/RHEL 7 则已经完全抛弃了 net-tools，只支持<code>iproute2</code>。linux ip 命令类似于 ifconfig，但功能更强大，旨在替代它。更多详情请阅读<a href=\"https://linoxide.com/linux-command/use-ip-command-linux\" target=\"_blank\" rel=\"noopener noreferrer\">如何在 Linux 中使用 IP 命令和示例</a></p>\n</li>\n<li>\n<p><strong><code>shutdown</code>：</strong> <code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定 5 分钟后关机，同时送出警告信息给登入用户。</p>\n</li>\n<li>\n<p><strong><code>reboot</code>：</strong> <strong><code>reboot</code>：</strong> 重开机。<strong><code>reboot -w</code>：</strong> 做个重开机的模拟（只有纪录并不会真的重开机）。</p>\n</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/image-20200807161118901.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "操作系统常见面试题总结",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/operating-system/basis/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/operating-system/basis/",
      "content_html": "<p>大家好，我是 Guide 哥！</p>\n<p>很多读者抱怨计算操作系统的知识点比较繁杂，自己也没有多少耐心去看，但是面试的时候又经常会遇到。所以，我带着我整理好的操作系统的常见问题来啦！这篇文章总结了一些我觉得比较重要的操作系统相关的问题比如<strong>进程管理</strong>、<strong>内存管理</strong>、<strong>虚拟内存</strong>等等。</p>\n<p>文章形式通过大部分比较喜欢的面试官和求职者之间的对话形式展开。另外，Guide哥 也只是在大学的时候学习过操作系统，不过基本都忘了，为了写这篇文章这段时间看了很多相关的书籍和博客。如果文中有任何需要补充和完善的地方，你都可以在 issue 中指出！</p>\n<p>这篇文章只是对一些操作系统比较重要概念的一个概览，深入学习的话，建议大家还是老老实实地去看书。另外， 这篇文章的很多内容参考了《现代操作系统》第三版这本书，非常感谢。</p>\n<p>开始本文的内容之前，我们先聊聊为什么要学习操作系统。</p>\n<ul>\n<li><strong>从对个人能力方面提升来说</strong>  ：操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。比如说我们开发的系统使用的缓存（比如 Redis）和操作系统的高速缓存就很像。CPU 中的高速缓存有很多种，不过大部分都是为了解决 CPU 处理速度和内存处理速度不对等的问题。我们还可以把内存看作外存的高速缓存，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。同样地，我们使用的 Redis 缓存就是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。高速缓存一般会按照局部性原理（2-8 原则）根据相应的淘汰算法保证缓存中的数据是经常会被访问的。我们平常使用的 Redis 缓存很多时候也会按照 2-8 原则去做，很多淘汰算法都和操作系统中的类似。既说了 2-8 原则，那就不得不提命中率了，这是所有缓存概念都通用的。简单来说也就是你要访问的数据有多少能直接在缓存中直接找到。命中率高的话，一般表明你的缓存设计比较合理，系统处理速度也相对较快。</li>\n<li><strong>从面试角度来说</strong> ：尤其是校招，对于操作系统方面知识的考察是非常非常多的。</li>\n</ul>\n<p><strong>简单来说，学习操作系统能够提高自己思考的深度以及对技术的理解力，并且，操作系统方面的知识也是面试必备。</strong></p>\n<p>关于如何学习操作系统，可以看这篇回答：<a href=\"https://www.zhihu.com/question/270998611/answer/1640198217\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.zhihu.com/question/270998611/answer/1640198217</a>。</p>\n<h2 id=\"一-操作系统基础\"> 一 操作系统基础</h2>\n<p>面试官顶着蓬松的假发向我走来，只见他一手拿着厚重的 Thinkpad ，一手提着他那淡黄的长裙。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/ceeb653ely1gd8wj5evc4j20i00n0dh0.jpg\" height=\"300\"></img></p>\n<h3 id=\"_1-1-什么是操作系统\"> 1.1 什么是操作系统？</h3>\n<p>👨‍💻<strong>面试官</strong> ： 先来个简单问题吧！<strong>什么是操作系统？</strong></p>\n<p>🙋 <strong>我</strong> ：我通过以下四点向您介绍一下什么是操作系统吧！</p>\n<ol>\n<li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li>\n<li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong>  举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li>\n<li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li>\n<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li>\n</ol>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png\" alt=\"Kernel_Layout\" /></p>\n<h3 id=\"_1-2-系统调用\"> 1.2 系统调用</h3>\n<p>👨‍💻<strong>面试官</strong> ：<strong>什么是系统调用呢？</strong> 能不能详细介绍一下。</p>\n<p>🙋 <strong>我</strong> ：介绍系统调用之前，我们先来了解一下用户态和系统态。</p>\n<p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>\n<ol>\n<li>用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。</li>\n<li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>\n</ol>\n<p>说了用户态和系统态之后，那么什么是系统调用呢？</p>\n<p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p>\n<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>\n<p>这些系统调用按功能大致可分为如下几类：</p>\n<ul>\n<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>\n<li>文件管理。完成文件的读、写、创建及删除等功能。</li>\n<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>\n<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>\n<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>\n</ul>\n<h2 id=\"二-进程和线程\"> 二 进程和线程</h2>\n<h3 id=\"_2-1-进程和线程的区别\"> 2.1 进程和线程的区别</h3>\n<p>👨‍💻<strong>面试官</strong>: 好的！我明白了！那你再说一下： <strong>进程和线程的区别</strong>。</p>\n<p>🙋 <strong>我：</strong> 好的！ 下图是 Java 内存区域，我们从 JVM 的角度来说一下线程和进程之间的关系吧！</p>\n<blockquote>\n<p>如果你对 Java 内存区域 (运行时数据区) 这部分知识不太了解的话可以阅读一下这篇文章：<a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F\" target=\"_blank\" rel=\"noopener noreferrer\">《可能是把 Java 内存区域讲的最清楚的一篇文章》</a></p>\n</blockquote>\n<p><img src=\"https://oscimg.oschina.net/oscnet/up-cd8ac705f6f004c01e0a1312f1599430ba5.png\" alt=\"\" /></p>\n<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)<strong>资源，但是每个线程有自己的</strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>\n<p><strong>总结：</strong> 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>\n<h3 id=\"_2-2-进程有哪几种状态\"> 2.2 进程有哪几种状态?</h3>\n<p>👨‍💻<strong>面试官</strong> ： 那你再说说<strong>进程有哪几种状态?</strong></p>\n<p>🙋 <strong>我</strong> ：我们一般把进程大致分为 5 种状态，这一点和<a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md#6-%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81\" target=\"_blank\" rel=\"noopener noreferrer\">线程</a>很像！</p>\n<ul>\n<li><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</li>\n<li><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li>\n<li><strong>运行状态(running)</strong> ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li>\n<li><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li>\n<li><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>\n</ul>\n<blockquote>\n<p>订正：下图中 running 状态被 interrupt 向 ready 状态转换的箭头方向反了。</p>\n</blockquote>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/d38202593012b457debbcd74994c6292.png\" alt=\"process-state\" /></p>\n<h3 id=\"_2-3-进程间的通信方式\"> 2.3 进程间的通信方式</h3>\n<p>👨‍💻<strong>面试官</strong> ：<strong>进程间的通信常见的的有哪几种方式呢?</strong></p>\n<p>🙋 <strong>我</strong> ：大概有 7 种常见的进程间的通信方式。</p>\n<blockquote>\n<p>下面这部分总结参考了:<a href=\"https://www.jianshu.com/p/c1015f5ffa74\" target=\"_blank\" rel=\"noopener noreferrer\">《进程间通信 IPC (InterProcess Communication)》</a> 这篇文章，推荐阅读，总结的非常不错。</p>\n</blockquote>\n<ol>\n<li><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>\n<li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循<strong>先进先出(first in first out)</strong>。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>\n<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>\n<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。</strong></li>\n<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>\n<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>\n<li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>\n</ol>\n<h3 id=\"_2-4-线程间的同步的方式\"> 2.4 线程间的同步的方式</h3>\n<p>👨‍💻<strong>面试官</strong> ：<strong>那线程间的同步的方式有哪些呢?</strong></p>\n<p>🙋 <strong>我</strong> ：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：</p>\n<ol>\n<li><strong>互斥量(Mutex)</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>\n<li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li>\n<li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操</li>\n</ol>\n<h3 id=\"_2-5-进程的调度算法\"> 2.5 进程的调度算法</h3>\n<p>👨‍💻<strong>面试官</strong> ：<strong>你知道操作系统中进程的调度算法有哪些吗?</strong></p>\n<p>🙋 <strong>我</strong> ：嗯嗯！这个我们大学的时候学过，是一个很重要的知识点！</p>\n<p>为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：</p>\n<ul>\n<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>\n<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>\n<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>\n<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>\n<li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>\n</ul>\n<h3 id=\"_2-6-什么是死锁\"> 2.6 什么是死锁</h3>\n<p>👨‍💻<strong>面试官</strong> ：<strong>你知道什么是死锁吗?</strong></p>\n<p>🙋 <strong>我</strong> ：多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况成为<strong>死锁</strong>。</p>\n<h3 id=\"_2-7-死锁的四个条件\"> 2.7 死锁的四个条件</h3>\n<p>👨‍💻<strong>面试官</strong> ：<strong>产生死锁的四个必要条件是什么?</strong></p>\n<p>🙋 <strong>我</strong> ：如果系统中以下四个条件同时成立，那么就能引起死锁：</p>\n<ul>\n<li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li>\n<li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li>\n<li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li>\n<li><strong>循环等待</strong>：有一组等待进程 <code>{P0, P1,..., Pn}</code>，  <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，......，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li>\n</ul>\n<p>注意，只有四个条件同时成立时，死锁才会出现。</p>\n<h2 id=\"三-操作系统内存管理基础\"> 三 操作系统内存管理基础</h2>\n<h3 id=\"_3-1-内存管理介绍\"> 3.1 内存管理介绍</h3>\n<p>👨‍💻 <strong>面试官</strong>: <strong>操作系统的内存管理主要是做什么？</strong></p>\n<p>🙋 <strong>我：</strong> 操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。</p>\n<h3 id=\"_3-2-常见的几种内存管理机制\"> 3.2 常见的几种内存管理机制</h3>\n<p>👨‍💻 <strong>面试官</strong>: <strong>操作系统的内存管理机制了解吗？内存管理有哪几种方式?</strong></p>\n<p>🙋 <strong>我：</strong> 这个在学习操作系统的时候有了解过。</p>\n<p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理</strong> 和 <strong>段式管理</strong>。</p>\n<ol>\n<li><strong>块式管理</strong> ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li>\n<li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li>\n<li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li>\n</ol>\n<p>👨‍💻<strong>面试官</strong> ： 回答的还不错！不过漏掉了一个很重要的 <strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</p>\n<p>🙋 <strong>我</strong> ：谢谢面试官！刚刚把这个给忘记了～</p>\n<h3 id=\"_3-3-快表和多级页表\"> 3.3 快表和多级页表</h3>\n<p>👨‍💻<strong>面试官</strong> ： 页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。你给我简单介绍一下吧！</p>\n<p>🙋 <strong>我</strong> ：在分页内存管理中，很重要的两点是：</p>\n<ol>\n<li>虚拟地址到物理地址的转换要快。</li>\n<li>解决虚拟地址空间大，页表也会很大的问题。</li>\n</ol>\n<h4 id=\"快表\"> 快表</h4>\n<p>为了解决虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>\n<p>使用快表之后的地址转换流程是这样的：</p>\n<ol>\n<li>根据虚拟地址中的页号查快表；</li>\n<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>\n<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>\n<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>\n</ol>\n<p>看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p>\n<h4 id=\"多级页表\"> 多级页表</h4>\n<p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章</p>\n<ul>\n<li>多级页表如何节约内存：<a href=\"https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.polarxiong.com/archives/多级页表如何节约内存.html</a></li>\n</ul>\n<h4 id=\"总结\"> 总结</h4>\n<p>为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。</p>\n<h3 id=\"_3-4-分页机制和分段机制的共同点和区别\"> 3.4 分页机制和分段机制的共同点和区别</h3>\n<p>👨‍💻<strong>面试官</strong> ： <strong>分页机制和分段机制有哪些共同点和区别呢？</strong></p>\n<p>🙋 <strong>我</strong> ：</p>\n<ol>\n<li><strong>共同点</strong> ：\n<ul>\n<li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。</li>\n<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>\n</ul>\n</li>\n<li><strong>区别</strong> ：\n<ul>\n<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>\n<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"_3-5-逻辑-虚拟-地址和物理地址\"> 3.5 逻辑(虚拟)地址和物理地址</h3>\n<p>👨‍💻<strong>面试官</strong> ：你刚刚还提到了<strong>逻辑地址和物理地址</strong>这两个概念，我不太清楚，你能为我解释一下不？</p>\n<p>🙋 <strong>我：</strong> em...好的嘛！我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p>\n<h3 id=\"_3-6-cpu-寻址了解吗-为什么需要虚拟地址空间\"> 3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?</h3>\n<p>👨‍💻<strong>面试官</strong> ：<strong>CPU 寻址了解吗?为什么需要虚拟地址空间?</strong></p>\n<p>🙋 <strong>我</strong> ：这部分我真不清楚！</p>\n<p>于是面试完之后我默默去查阅了相关文档！留下了没有技术的泪水。。。</p>\n<blockquote>\n<p>这部分内容参考了 Microsoft 官网的介绍，地址：<a href=\"https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/virtual-address-spaces?redirectedfrom=MSDN\" target=\"_blank\" rel=\"noopener noreferrer\">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/virtual-address-spaces?redirectedfrom=MSDN</a></p>\n</blockquote>\n<p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。<strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong> 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 <strong>内存管理单元（Memory Management Unit, MMU）</strong> 的硬件。如下图所示：</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/2b27dac8cc647f8aac989da2d1166db2.png\" alt=\"MMU_principle_updated\" /></p>\n<p><strong>为什么要有虚拟地址空间呢？</strong></p>\n<p>先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，<strong>程序都是直接访问和操作的都是物理内存</strong> 。但是这样有什么问题呢？</p>\n<ol>\n<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li>\n<li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li>\n</ol>\n<p><strong>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</strong></p>\n<p>通过虚拟地址访问内存有以下优势：</p>\n<ul>\n<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>\n<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>\n<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>\n</ul>\n<h2 id=\"四-虚拟内存\"> 四 虚拟内存</h2>\n<h3 id=\"_4-1-什么是虚拟内存-virtual-memory\"> 4.1 什么是虚拟内存(Virtual Memory)?</h3>\n<p>👨‍💻<strong>面试官</strong> ：再问你一个常识性的问题！<strong>什么是虚拟内存(Virtual Memory)?</strong></p>\n<p>🙋 <strong>我</strong> ：这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。<strong>为什么可以这样呢？</strong> 正是因为 <strong>虚拟内存</strong> 的存在，通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。</p>\n<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。<strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间</strong>。推荐阅读：<a href=\"https://juejin.im/post/59f8691b51882534af254317\" target=\"_blank\" rel=\"noopener noreferrer\">《虚拟内存的那点事儿》</a></p>\n<p>维基百科中有几句话是这样介绍虚拟内存的。</p>\n<blockquote>\n<p><strong>虚拟内存</strong> 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。From:<a href=\"https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/虚拟内存</a></p>\n</blockquote>\n<h3 id=\"_4-2-局部性原理\"> 4.2 局部性原理</h3>\n<p>👨‍💻<strong>面试官</strong> ：要想更好地理解虚拟内存技术，必须要知道计算机中著名的<strong>局部性原理</strong>。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。</p>\n<p>🙋 <strong>我</strong> ：局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p>\n<blockquote>\n<p>以下内容摘自《计算机操作系统教程》 第 4 章存储器管理。</p>\n</blockquote>\n<p>早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。</p>\n<p>局部性原理表现在以下两个方面：</p>\n<ol>\n<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>\n<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>\n</ol>\n<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>\n<h3 id=\"_4-3-虚拟存储器\"> 4.3 虚拟存储器</h3>\n<blockquote>\n<p><strong>勘误：虚拟存储器又叫做虚拟内存，都是 Virtual Memory 的翻译，属于同一个概念。</strong></p>\n</blockquote>\n<p>👨‍💻<strong>面试官</strong> ：<s>都说了虚拟内存了。你再讲讲<strong>虚拟存储器</strong>把！</s></p>\n<p>🙋 <strong>我</strong> ：</p>\n<blockquote>\n<p>这部分内容来自：<a href=\"https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html\" target=\"_blank\" rel=\"noopener noreferrer\">王道考研操作系统知识点整理</a>。</p>\n</blockquote>\n<p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——<strong>虚拟存储器</strong>。</p>\n<p>实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。</p>\n<h3 id=\"_4-4-虚拟内存的技术实现\"> 4.4 虚拟内存的技术实现</h3>\n<p>👨‍💻<strong>面试官</strong> ：<strong>虚拟内存技术的实现呢？</strong></p>\n<p>🙋 <strong>我</strong> ：<strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p>\n<ol>\n<li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>\n<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>\n<li><strong>请求段页式存储管理</strong></li>\n</ol>\n<p><strong>这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？</strong></p>\n<p>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</p>\n<p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p>\n<p>不管是上面那种实现方式，我们一般都需要：</p>\n<ol>\n<li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li>\n<li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li>\n<li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li>\n</ol>\n<h3 id=\"_4-5-页面置换算法\"> 4.5 页面置换算法</h3>\n<p>👨‍💻<strong>面试官</strong> ：虚拟内存管理很重要的一个概念就是页面置换算法。那你说一下 <strong>页面置换算法的作用?常见的页面置换算法有哪些?</strong></p>\n<p>🙋 <strong>我</strong> ：</p>\n<blockquote>\n<p>这个题目经常作为笔试题出现，网上已经给出了很不错的回答，我这里只是总结整理了一下。</p>\n</blockquote>\n<p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p>\n<blockquote>\n<p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>\n</blockquote>\n<p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p>\n<ul>\n<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>\n<li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>\n<li><strong>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li>\n<li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> :  该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>\n</ul>\n<h2 id=\"reference\"> Reference</h2>\n<ul>\n<li>《计算机操作系统—汤小丹》第四版</li>\n<li><a href=\"https://book.douban.com/subject/1230413/\" target=\"_blank\" rel=\"noopener noreferrer\">《深入理解计算机系统》</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/输入输出内存管理单元</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E5%BF%AB%E8%A1%A8/19781679\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/快表/19781679</a></li>\n<li>https://www.jianshu.com/p/1d47ed0b46d5</li>\n<li><a href=\"https://www.studytonight.com/operating-system\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.studytonight.com/operating-system</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/interprocess-communication-methods/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.geeksforgeeks.org/interprocess-communication-methods/</a></li>\n<li><a href=\"https://juejin.im/post/59f8691b51882534af254317\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.im/post/59f8691b51882534af254317</a></li>\n<li>王道考研操作系统知识点整理： https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "谢希仁老师的《计算机网络》内容总结",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/network/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%80%81%E5%B8%88%E7%9A%84%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/network/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%80%81%E5%B8%88%E7%9A%84%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/",
      "content_html": "<p>本文是我在大二学习计算机网络期间整理， 大部分内容都来自于谢希仁老师的《计算机网络》这本书。</p>\n<p>为了内容更容易理解，我对之前的整理进行了一波重构，并配上了一些相关的示意图便于理解。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e7177b00248e30dc49bd6061093a0590.png\" alt=\"\" /></p>\n\n\n<ul>\n<li>\n<ul>\n<li></li>\n<li></li>\n</ul>\n</li>\n<li>\n<ul>\n<li></li>\n<li></li>\n<li>\n<ul>\n<li></li>\n<li></li>\n<li></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li></li>\n<li></li>\n<li></li>\n</ul>\n</li>\n<li>\n<ul>\n<li></li>\n<li></li>\n</ul>\n</li>\n<li>\n<ul>\n<li></li>\n<li></li>\n<li></li>\n</ul>\n</li>\n<li>\n<ul>\n<li></li>\n<li></li>\n<li></li>\n</ul>\n</li>\n</ul>\n\n<h2 id=\"_1-计算机网络概述\"> 1. 计算机网络概述</h2>\n<h3 id=\"_1-1-基本术语\"> 1.1. 基本术语</h3>\n<ol>\n<li><strong>结点 （node）</strong> ：网络中的结点可以是计算机，集线器，交换机或路由器等。</li>\n<li><strong>链路（link ）</strong> : 从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。</li>\n<li><strong>主机（host）</strong> ：连接在因特网上的计算机。</li>\n<li><strong>ISP（Internet Service Provider）</strong> ：因特网服务提供者（提供商）。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b83f6951e3f8f4bcde5b227257d603a8.png\" alt=\"ISP (Internet Service Provider) Definition\" /></p>\n<ol start=\"5\">\n<li><strong>IXP（Internet eXchange Point）</strong> ： 互联网交换点 IXP 的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/7a9568a9e94001fc110801addc8c4ec0.png\" alt=\"IXP Traffic Levels During the Stratos Skydive — RIPE Labs\" /></p>\n<p style=\"text-align:center;font-size:13px;color:gray\">https://labs.ripe.net/Members/fergalc/ixp-traffic-during-stratos-skydive</p>\n<ol start=\"6\">\n<li><strong>RFC(Request For Comments)</strong> ：意思是“请求评议”，包含了关于 Internet 几乎所有的重要的文字资料。</li>\n<li><strong>广域网 WAN（Wide Area Network）</strong> ：任务是通过长距离运送主机发送的数据。</li>\n<li><strong>城域网 MAN（Metropolitan Area Network）</strong>：用来将多个局域网进行互连。</li>\n<li><strong>局域网 LAN（Local Area Network）</strong> ： 学校或企业大多拥有多个互连的局域网。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/25a5789f8e18995c649f2f864d51e7a9.png\" alt=\"MAN &amp; WMAN | Red de área metropolitana, Redes informaticas, Par trenzado\" /></p>\n<p style=\"text-align:center;font-size:13px;color:gray\">http://conexionesmanwman.blogspot.com/</p>\n<ol start=\"10\">\n<li><strong>个人区域网 PAN（Personal Area Network）</strong> ：在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5c99dd6011439b1fab6cd2fece155dd5.png\" alt=\"Advantages and disadvantages of personal area network (PAN) - IT Release\" /></p>\n<p style=\"text-align:center;font-size:13px;color:gray\">https://www.itrelease.com/2018/07/advantages-and-disadvantages-of-personal-area-network-pan/</p>\n<ol start=\"12\">\n<li><strong>分组（packet ）</strong> ：因特网中传送的数据单元。由首部 header 和数据段组成。分组又称为包，首部可称为包头。</li>\n<li><strong>存储转发（store and forward ）</strong> ：路由器收到一个分组，先检查分组是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发送的输出端口地址，然后将该包发送出去。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20201025142342169.gif#pic_center\" alt=\"\" /></p>\n<ol start=\"14\">\n<li><strong>带宽（bandwidth）</strong> ：在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为 b/s。</li>\n<li><strong>吞吐量（throughput ）</strong> ：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。</li>\n</ol>\n<h3 id=\"_1-2-重要知识点总结\"> 1.2. 重要知识点总结</h3>\n<ol>\n<li><strong>计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</strong></li>\n<li>小写字母 i 开头的 internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。大写字母 I 开头的 Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用 TCP/IP 协议作为通信规则，其前身为 ARPANET。Internet 的推荐译名为因特网，现在一般流行称为互联网。</li>\n<li>路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</li>\n<li>互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。</li>\n<li>计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S 方式）和对等连接方式（P2P 方式）。</li>\n<li>客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</li>\n<li>按照作用范围的不同，计算机网络分为广域网 WAN，城域网 MAN，局域网 LAN，个人区域网 PAN。</li>\n<li><strong>计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</strong></li>\n<li>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</li>\n<li><strong>五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。</strong></li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/2020102514243717.png#pic_center\" alt=\"s\" /></p>\n<p>下面的内容会介绍计算机网络的五层体系结构：<strong>物理层+数据链路层+网络层（网际层）+运输层+应用层</strong>。</p>\n<h2 id=\"_2-物理层-physical-layer\"> 2. 物理层（Physical Layer）</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/4749289d6e152bab1c8a8ccfc946a797.png\" alt=\"物理层\" /></p>\n<h3 id=\"_2-1-基本术语\"> 2.1. 基本术语</h3>\n<ol>\n<li><strong>数据（data）</strong> :运送消息的实体。</li>\n<li><strong>信号（signal）</strong> ：数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。</li>\n<li><strong>码元（ code）</strong> ：在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。</li>\n<li><strong>单工（simplex ）</strong> : 只能有一个方向的通信而没有反方向的交互。</li>\n<li><strong>半双工（half duplex ）</strong> ：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>\n<li><strong>全双工（full duplex）</strong> : 通信的双方可以同时发送和接收信息。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c5be4756d2d6f46cbb6d785d5b86faf1.png\" alt=\"\" /></p>\n<ol start=\"7\">\n<li><strong>失真</strong>：失去真实性，主要是指接受到的信号和发送的信号不同，有磨损和衰减。影响失真程度的因素：1.码元传输速率 2.信号传输距离 3.噪声干扰 4.传输媒体质量</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/aef3aac72e86c1ee6ccb8a91647f656c.png\" alt=\"\" /></p>\n<ol start=\"8\">\n<li><strong>奈氏准则</strong> : 在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。</li>\n<li><strong>香农定理</strong> ：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</li>\n<li><strong>基带信号（baseband signal）</strong> : 来自信源的信号。指没有经过调制的数字信号或模拟信号。</li>\n<li><strong>带通（频带）信号（bandpass signal）</strong> ：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。</li>\n<li><strong>调制（modulation ）</strong> : 对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。</li>\n<li><strong>信噪比（signal-to-noise ratio ）</strong> : 指信号的平均功率和噪声的平均功率之比，记为 S/N。信噪比（dB）=10*log10（S/N）。</li>\n<li><strong>信道复用（channel multiplexing ）</strong> ：指多个用户共享同一个信道。（并不一定是同时）。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/a4889adaad3314f882e2cfab5f382064.png\" alt=\"信道复用技术\" /></p>\n<ol start=\"15\">\n<li><strong>比特率（bit rate ）</strong> ：单位时间（每秒）内传送的比特数。</li>\n<li><strong>波特率（baud rate）</strong> ：单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。</li>\n<li><strong>复用（multiplexing）</strong> ：共享信道的方法。</li>\n<li><strong>ADSL（Asymmetric Digital Subscriber Line ）</strong> ：非对称数字用户线。</li>\n<li><strong>光纤同轴混合网（HFC 网）</strong> :在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网</li>\n</ol>\n<h3 id=\"_2-2-重要知识点总结\"> 2.2. 重要知识点总结</h3>\n<ol>\n<li><strong>物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</strong></li>\n<li>一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</li>\n<li><strong>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电器或电磁的表现。</strong></li>\n<li>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</li>\n<li>根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</li>\n<li>来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</li>\n<li>要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</li>\n<li>传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</li>\n<li>了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</li>\n</ol>\n<h3 id=\"_2-3-补充\"> 2.3. 补充</h3>\n<h4 id=\"_2-3-1-物理层主要做啥\"> 2.3.1. 物理层主要做啥？</h4>\n<p>物理层主要做的事情就是 <strong>透明地传送比特流</strong>。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能能的各种可能事件的出现顺序）。</p>\n<p><strong>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</strong> 现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</p>\n<h4 id=\"_2-3-2-几种常用的信道复用技术\"> 2.3.2. 几种常用的信道复用技术</h4>\n<ol>\n<li><strong>频分复用(FDM)</strong> ：所有用户在同样的时间占用不同的带宽资源。</li>\n<li><strong>时分复用（TDM）</strong> ：所有用户在不同的时间占用同样的频带宽度（分时不分频）。</li>\n<li><strong>统计时分复用 (Statistic TDM)</strong> ：改进的时分复用，能够明显提高信道的利用率。</li>\n<li><strong>码分复用(CDM)</strong> ： 用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li>\n<li><strong>波分复用( WDM)</strong> ：波分复用就是光的频分复用。</li>\n</ol>\n<h4 id=\"_2-3-3-几种常用的宽带接入技术-主要是-adsl-和-fttx\"> 2.3.3. 几种常用的宽带接入技术，主要是 ADSL 和 FTTx</h4>\n<p>用户到互联网的宽带接入方法有非对称数字用户线 ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ASDL 的快速版本是甚高速数字用户线 VDSL。），光纤同轴混合网 HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和 FTTx（即光纤到······）。</p>\n<h2 id=\"_3-数据链路层-data-link-layer\"> 3. 数据链路层（Data Link Layer）</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/2-data-link-layer.svg\" alt=\"数据链路层\" /></p>\n<h3 id=\"_3-1-基本术语\"> 3.1. 基本术语</h3>\n<ol>\n<li><strong>链路（link）</strong> ：一个结点到相邻结点的一段物理链路。</li>\n<li><strong>数据链路（data link）</strong> ：把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路。</li>\n<li><strong>循环冗余检验 CRC（Cyclic Redundancy Check）</strong> ：为了保证数据传输的可靠性，CRC 是数据链路层广泛使用的一种检错技术。</li>\n<li><strong>帧（frame）</strong> ：一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。</li>\n<li><strong>MTU（Maximum Transfer Uint ）</strong> ：最大传送单元。帧的数据部分的的长度上限。</li>\n<li><strong>误码率 BER（Bit Error Rate ）</strong> ：在一段时间内，传输错误的比特占所传输比特总数的比率。</li>\n<li><strong>PPP（Point-to-Point Protocol ）</strong> ：点对点协议。即用户计算机和 ISP 进行通信时所使用的数据链路层协议。以下是 PPP 帧的示意图：\n<img src=\"https://img-blog.csdnimg.cn/img_convert/298dbdeb16f98cec02c3954d8d95c1d6.png\" alt=\"PPP\" /></li>\n<li><strong>MAC 地址（Media Access Control 或者 Medium Access Control）</strong> ：意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。因此一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址 。地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/002b2e6e45d66e805008fafc310afef0.png\" alt=\"ARP (Address Resolution Protocol) explained\" /></p>\n<ol start=\"9\">\n<li><strong>网桥（bridge）</strong> ：一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。</li>\n<li><strong>交换机（switch ）</strong> ：广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥</li>\n</ol>\n<h3 id=\"_3-2-重要知识点总结\"> 3.2. 重要知识点总结</h3>\n<ol>\n<li>链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</li>\n<li>数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</li>\n<li>数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></li>\n<li><strong>循环冗余检验 CRC</strong> 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码</li>\n<li><strong>点对点协议 PPP</strong> 是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</li>\n<li>PPPoE 是为宽带上网的主机使用的链路层协议</li>\n<li><strong>局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</strong></li>\n<li>计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的 ROM 中</strong>。</li>\n<li>以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</li>\n<li>以太网采用的协议是具有冲突检测的<strong>载波监听多点接入 CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道</li>\n<li>以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</li>\n<li>使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</li>\n</ol>\n<h3 id=\"_3-3-补充\"> 3.3. 补充</h3>\n<ol>\n<li>数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP 协议以及 CSMA/CD 协议）的特点</li>\n<li>数据链路层的三个基本问题：<strong>封装成帧</strong>，<strong>透明传输</strong>，<strong>差错检测</strong></li>\n<li>以太网的 MAC 层硬件地址</li>\n<li>适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合</li>\n</ol>\n<h2 id=\"_4-网络层-network-layer\"> 4. 网络层（Network Layer）</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/fbf78bdcf3db11526ac1a234a8b98234.png\" alt=\"网络层\" /></p>\n<h3 id=\"_4-1-基本术语\"> 4.1. 基本术语</h3>\n<ol>\n<li><strong>虚电路（Virtual Circuit）</strong> : 在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li>\n<li><strong>IP（Internet Protocol ）</strong> : 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，是 TCP/IP 体系结构网际层的核心。配套的有 ARP，RARP，ICMP，IGMP。</li>\n<li><strong>ARP（Address Resolution Protocol）</strong> : 地址解析协议。地址解析协议 ARP 把 IP 地址解析为硬件地址。</li>\n<li><strong>ICMP（Internet Control Message Protocol ）</strong> ：网际控制报文协议 （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告）。</li>\n<li><strong>子网掩码（subnet mask ）</strong> ：它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</li>\n<li><strong>CIDR（ Classless Inter-Domain Routing ）</strong>：无分类域间路由选择 （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）。</li>\n<li><strong>默认路由（default route）</strong> ：当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。</li>\n<li><strong>路由选择算法（Virtual Circuit）</strong> ：路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。</li>\n</ol>\n<h3 id=\"_4-2-重要知识点总结\"> 4.2. 重要知识点总结</h3>\n<ol>\n<li><strong>TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</strong></li>\n<li>在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</li>\n<li>分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明 IP 地址的类别。IP 地址是一种分等级的地址结构。IP 地址管理机构分配 IP 地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的 IP 地址</li>\n<li>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP 首部中的生存时间给出了 IP 数据报在互联网中所能经过的最大路由器数。可防止 IP 数据报在互联网中无限制的兜圈子。</li>\n<li><strong>地址解析协议 ARP 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去广播方式发送 ARP 请求分组</strong></li>\n<li>无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好办法。CIDR 记法把 IP 地址后面加上斜线“/”，然后写上前缀所所占的位数。前缀（或网络前缀用来指明网络），前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”，IP 地址分配都以 CIDR 地址块为单位。</li>\n<li>网际控制报文协议是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 数据报并不是为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种 ICMP 差错报告报文和 ICMP 询问报文。</li>\n<li><strong>要解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议-IPv6。</strong> IPv6 所带来的变化有 ① 更大的地址空间（采用 128 位地址）② 灵活的首部格式 ③ 改进的选项 ④ 支持即插即用 ⑤ 支持资源的预分配 ⑥IPv6 的首部改为 8 字节对齐。</li>\n<li><strong>虚拟专用网络 VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密。</strong></li>\n<li>MPLS 的特点是：① 支持面向连接的服务质量 ② 支持流量工程，平衡网络负载 ③ 有效的支持虚拟专用网 VPN。MPLS 在入口节点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</li>\n</ol>\n<h2 id=\"_5-传输层-transport-layer\"> 5. 传输层（Transport Layer）</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/09eb87a29bed99775ef5bde5eb216971.png\" alt=\"传输层\" /></p>\n<h3 id=\"_5-1-基本术语\"> 5.1. 基本术语</h3>\n<ol>\n<li><strong>进程（process）</strong> ：指计算机中正在运行的程序实体。</li>\n<li><strong>应用进程互相通信</strong> ：一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）。</li>\n<li><strong>传输层的复用与分用</strong> ：复用指发送方不同的进程都可以通过统一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。</li>\n<li><strong>TCP（Transmission Control Protocol）</strong> ：传输控制协议。</li>\n<li><strong>UDP（User Datagram Protocol）</strong> ：用户数据报协议。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/2bd5bf90676c338864807ade87b7bdea.png\" alt=\"TCP和UDP\" /></p>\n<ol start=\"6\">\n<li><strong>端口（port）</strong> ：端口的目的是为了确认对方机器是那个进程在于自己进行交互，比如 MSN 和 QQ 的端口不同，如果没有端口就可能出现 QQ 进程和 MSN 交互错误。端口又称协议端口号。</li>\n<li><strong>停止等待协议（stop-and-wait）</strong> ：指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。</li>\n<li><strong>流量控制</strong> : 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</li>\n<li><strong>拥塞控制</strong> ：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</li>\n</ol>\n<h3 id=\"_5-2-重要知识点总结\"> 5.2. 重要知识点总结</h3>\n<ol>\n<li><strong>运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</strong></li>\n<li><strong>网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</strong></li>\n<li>运输层的两个重要协议是用户数据报协议 UDP 和传输控制协议 TCP。按照 OSI 的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元 TPDU（Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 TCP 报文段或 UDP 用户数据报。</li>\n<li><strong>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式。 TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</strong></li>\n<li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP 和 TCP 的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到 IP 层交上来的运输层报文时，就能够 根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方 IP 地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</li>\n<li>运输层用一个 16 位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由 TCP 和 UDP 来完成。</li>\n<li>运输层的端口号分为服务器端使用的端口号（0~1023 指派给熟知端口，1024~49151 是登记端口号）和客户端暂时使用的端口号（49152~65535）</li>\n<li><strong>UDP 的主要特点是 ① 无连接 ② 尽最大努力交付 ③ 面向报文 ④ 无拥塞控制 ⑤ 支持一对一，一对多，多对一和多对多的交互通信 ⑥ 首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</strong></li>\n<li><strong>TCP 的主要特点是 ① 面向连接 ② 每一条 TCP 连接只能是一对一的 ③ 提供可靠交付 ④ 提供全双工通信 ⑤ 面向字节流</strong></li>\n<li><strong>TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP 地址：端口号）来表示。每一条 TCP 连接唯一被通信两端的两个端点所确定。</strong></li>\n<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>\n<li>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</li>\n<li>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</li>\n<li>TCP 报文段的前 20 个字节是固定的，后面有 4n 字节是根据需要增加的选项。因此，TCP 首部的最小长度是 20 字节。</li>\n<li><strong>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</strong></li>\n<li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>\n<li><strong>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</strong></li>\n<li><strong>TCP 的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</strong></li>\n<li>运输连接的三个阶段，即：连接建立，数据传送和连接释放。</li>\n<li><strong>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</strong></li>\n<li>TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接</li>\n</ol>\n<h3 id=\"_5-3-补充-重要\"> 5.3. 补充（重要）</h3>\n<p>以下知识点需要重点关注：</p>\n<ol>\n<li>端口和套接字的意义</li>\n<li>UDP 和 TCP 的区别以及两者的应用场景</li>\n<li>在不可靠的网络上实现可靠传输的工作原理，停止等待协议和 ARQ 协议</li>\n<li>TCP 的滑动窗口，流量控制，拥塞控制和连接管理</li>\n<li>TCP 的三次握手，四次挥手机制</li>\n</ol>\n<h2 id=\"_6-应用层-application-layer\"> 6. 应用层（Application Layer）</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3ff57c0632bc7f4017723b1d1b7d3a52.png\" alt=\"应用层\" /></p>\n<h3 id=\"_6-1-基本术语\"> 6.1. 基本术语</h3>\n<ol>\n<li><strong>域名系统（DNS）</strong> ：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。我们可以将其理解为专为互联网设计的电话薄。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/6af26a3293530061785df50e70d53e07.png\" alt=\"\" /></p>\n<p style=\"text-align:right;font-size:12px\">https://www.seobility.net/en/wiki/HTTP_headers</p>\n<ol start=\"2\">\n<li><strong>文件传输协议（FTP）</strong> ：FTP 是 File TransferProtocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于 Internet 上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的 FTP 应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在 FTP 的使用当中，用户经常遇到两个概念：&quot;下载&quot;（Download）和&quot;上传&quot;（Upload）。 &quot;下载&quot;文件就是从远程主机拷贝文件至自己的计算机上；&quot;上传&quot;文件就是将文件从自己的计算机中拷贝至远程主机上。用 Internet 语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3f1abf8adba4aa317eca69c489e3db23.png\" alt=\"FTP工作过程\" /></p>\n<ol start=\"3\">\n<li><strong>简单文件传输协议（TFTP）</strong> ：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为 69。</li>\n<li><strong>远程终端协议（TELNET）</strong> ：Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet 会话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控制 Web 服务器的方法。</li>\n<li><strong>万维网（WWW）</strong> ：WWW 是环球信息网的缩写，（亦作“Web”、“WWW”、“'W3'”，英文全称为“World Wide Web”），中文名字为“万维网”，&quot;环球网&quot;等，常简称为 Web。分为 Web 客户端和 Web 服务器程序。WWW 可以让 Web 客户端（常用浏览器）访问浏览 Web 服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。万维网联盟（英语：World Wide Web Consortium，简称 W3C），又称 W3C 理事会。1994 年 10 月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</li>\n<li><strong>万维网的大致工作工程：</strong></li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/735f55501e81898aa61b8032f7dbcb73.png\" alt=\"万维网的大致工作工程\" /></p>\n<ol start=\"7\">\n<li><strong>统一资源定位符（URL）</strong> ：统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</li>\n<li><strong>超文本传输协议（HTTP）</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了 HTTP 超文本传输协议标准架构的发展根基。</li>\n</ol>\n<p>HTTP 协议的本质就是一种浏览器与服务器之间约定好的通信格式。HTTP 的原理如下图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b273efef5f2388e26414135672b00295.png\" alt=\"\" /></p>\n<ol start=\"10\">\n<li><strong>代理服务器（Proxy Server）</strong> ： 代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器工作，也可以在中间系统工作。</li>\n<li><strong>简单邮件传输协议(SMTP)</strong> : SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 通过 SMTP 协议所指定的服务器,就可以把 E-mail 寄到收信人的服务器上了，整个过程只要几分钟。SMTP 服务器则是遵循 SMTP 协议的发送邮件服务器，用来发送或中转发出的电子邮件。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b16da4d4fea63de5fce53f54973967d7.png\" alt=\"一个电子邮件被发送的过程\" /></p>\n<p style=\"text-align:right;font-size:12px\">https://www.campaignmonitor.com/resources/knowledge-base/what-is-the-code-that-makes-bcc-or-cc-operate-in-an-email/<p>\n<ol start=\"11\">\n<li><strong>搜索引擎</strong> :搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/68fe865a9d87de361c45f4a42d624035.png\" alt=\"搜索引擎\" /></p>\n<ol start=\"12\">\n<li><strong>垂直搜索引擎</strong> ：垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。</li>\n<li><strong>全文索引</strong> :全文索引技术是目前搜索引擎的关键技术。试想在 1M 大小的文件中搜索一个词，可能需要几秒，在 100M 的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。</li>\n<li><strong>目录索引</strong> ：目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。</li>\n</ol>\n<h3 id=\"_6-2-重要知识点总结\"> 6.2. 重要知识点总结</h3>\n<ol>\n<li>文件传输协议（FTP）使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可以同时为多个用户提供服务。在进进行文件传输时，FTP 的客户和服务器之间要先建立两个并行的 TCP 连接:控制连接和数据连接。实际用于传输文件的是数据连接。</li>\n<li>万维网客户程序与服务器之间进行交互使用的协议是超文本传输协议 HTTP。HTTP 使用 TCP 连接进行可靠传输。但 HTTP 本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接（分为非流水线方式和流水线方式）</li>\n<li>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</li>\n<li>一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP）。用户代理和邮件服务器都要运行这些协议。</li>\n</ol>\n<h3 id=\"_6-3-补充-重要\"> 6.3. 补充（重要）</h3>\n<p>以下知识点需要重点关注：</p>\n<ol>\n<li>应用层的常见协议（重点关注 HTTP 协议）</li>\n<li>域名系统-从域名解析出 IP 地址</li>\n<li>访问一个网站大致的过程</li>\n<li>系统调用和应用编程接口概念</li>\n</ol>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/e7177b00248e30dc49bd6061093a0590.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "计算机网络常见面试题",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/",
      "content_html": "<h2 id=\"一-osi-与-tcp-ip-各层的结构与功能-都有哪些协议\"> 一 OSI 与 TCP/IP 各层的结构与功能, 都有哪些协议?</h2>\n<p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/五层体系结构.png\" alt=\"五层体系结构\" /></p>\n<p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p>\n<h3 id=\"_1-1-应用层\"> 1.1 应用层</h3>\n<p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。<strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如</strong>域名系统 DNS</strong>，支持万维网应用的 <strong>HTTP 协议</strong>，支持电子邮件的 <strong>SMTP 协议</strong>等等。我们把应用层交互的数据单元称为报文。</p>\n<p><strong>域名系统</strong></p>\n<blockquote>\n<p>域名系统(Domain Name System 缩写 DNS，Domain Name 被译为域名)是因特网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 www.ibm.com、Oracle 公司的域名是 www.oracle.com、Cisco 公司的域名是 www.cisco.com 等。</p>\n</blockquote>\n<p><strong>HTTP 协议</strong></p>\n<blockquote>\n<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p>\n</blockquote>\n<h3 id=\"_1-2-运输层\"> 1.2 运输层</h3>\n<p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>\n<p><strong>运输层主要使用以下两种协议:</strong></p>\n<ol>\n<li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）--提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li>\n<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）--提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li>\n</ol>\n<p><strong>TCP 与 UDP 的对比见问题三。</strong></p>\n<h3 id=\"_1-3-网络层\"> 1.3 网络层</h3>\n<p><strong>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p>\n<p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>\n<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p>\n<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP 层</strong>。</p>\n<h3 id=\"_1-4-数据链路层\"> 1.4 数据链路层</h3>\n<p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>\n<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。\n控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>\n<h3 id=\"_1-5-物理层\"> 1.5 物理层</h3>\n<p>在物理层上所传送的数据单位是比特。</p>\n<p><strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>\n<p>在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定单指 TCP 和 IP 这两个具体的协议，而往往表示互联网所使用的整个 TCP/IP 协议族。</p>\n<h3 id=\"_1-6-总结一下\"> 1.6 总结一下</h3>\n<p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下（图片来源于网络）。</p>\n<p><img src=\"./images/七层体系结构图.png\" alt=\"七层体系结构图\" /></p>\n<h2 id=\"二-tcp-三次握手和四次挥手-面试常客\"> 二 TCP 三次握手和四次挥手(面试常客)</h2>\n<p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p>\n<h3 id=\"_2-1-tcp-三次握手漫画图解\"> 2.1 TCP 三次握手漫画图解</h3>\n<p>如下图所示，下面的两个机器人通过 3 次握手确定了对方能正确接收和发送消息(图片来源：《图解 HTTP》)。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/三次握手.png\" alt=\"TCP三次握手\" /></p>\n<p><strong>简单示意图：</strong></p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/三次握手2.png\" alt=\"TCP三次握手\" /></p>\n<ul>\n<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>\n<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>\n<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>\n</ul>\n<p><strong>详细示意图（图片来源不详）</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/0c9f470819684156cfdc27c682db4def.png\" alt=\"\" /></p>\n<h3 id=\"_2-2-为什么要三次握手\"> 2.2 为什么要三次握手</h3>\n<p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>\n<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>\n<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>\n<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>\n<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>\n<h3 id=\"_2-3-第-2-次握手传回了-ack-为什么还要传回-syn\"> 2.3 第 2 次握手传回了 ACK，为什么还要传回 SYN？</h3>\n<p>接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。”</p>\n<blockquote>\n<p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>\n</blockquote>\n<h3 id=\"_2-5-为什么要四次挥手\"> 2.5 为什么要四次挥手</h3>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/TCP四次挥手.png\" alt=\"TCP四次挥手\" /></p>\n<p>断开一个 TCP 连接则需要“四次挥手”：</p>\n<ul>\n<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>\n<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li>\n<li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li>\n<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li>\n</ul>\n<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>\n<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>\n<p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a href=\"https://blog.csdn.net/qzcsu/article/details/72861891\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>\n<h2 id=\"三-tcp-udp-协议的区别\"> 三 TCP, UDP 协议的区别</h2>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg\" alt=\"TCP、UDP协议的区别\" /></p>\n<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>\n<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>\n<h2 id=\"四-tcp-协议如何保证可靠传输\"> 四 TCP 协议如何保证可靠传输</h2>\n<ol>\n<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>\n<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>\n<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>\n<li>TCP 的接收端会丢弃重复的数据。</li>\n<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>\n<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>\n<li><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>\n<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>\n</ol>\n<h3 id=\"_4-1-arq-协议\"> 4.1 ARQ 协议</h3>\n<p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>\n<h4 id=\"停止等待-arq-协议\"> 停止等待 ARQ 协议</h4>\n<p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p>\n<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>\n<p><strong>优缺点：</strong></p>\n<ul>\n<li><strong>优点：</strong> 简单</li>\n<li><strong>缺点：</strong> 信道利用率低，等待时间长</li>\n</ul>\n<p><strong>1) 无差错情况:</strong></p>\n<p>发送方发送分组, 接收方在规定时间内收到, 并且回复确认. 发送方再次发送。</p>\n<p><strong>2) 出现差错情况（超时重传）:</strong></p>\n<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>\n<p><strong>3) 确认丢失和确认迟到</strong></p>\n<ul>\n<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li>\n<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li>\n</ul>\n<h4 id=\"连续-arq-协议\"> 连续 ARQ 协议</h4>\n<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>\n<p><strong>优缺点：</strong></p>\n<ul>\n<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>\n<li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>\n</ul>\n<h3 id=\"_4-2-滑动窗口和流量控制\"> 4.2 滑动窗口和流量控制</h3>\n<p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>\n<h3 id=\"_4-3-拥塞控制\"> 4.3 拥塞控制</h3>\n<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>\n<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>\n<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>\n<ul>\n<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>\n<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</li>\n<li><strong>快重传与快恢复：</strong>\n在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>\n</ul>\n<h2 id=\"五-在浏览器中输入-url-地址-显示主页的过程-面试常客\"> 五 在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程(面试常客)</h2>\n<p>百度好像最喜欢问这个问题。</p>\n<blockquote>\n<p>打开一个网页，整个过程会使用哪些协议？</p>\n</blockquote>\n<p>图解（图片来源：《图解 HTTP》）：</p>\n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url输入到展示出来的过程.jpg\" style=\"zoom:50%; \" />\n<blockquote>\n<p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p>\n</blockquote>\n<p>总体来说分为以下几个过程:</p>\n<ol>\n<li>DNS 解析</li>\n<li>TCP 连接</li>\n<li>发送 HTTP 请求</li>\n<li>服务器处理请求并返回 HTTP 报文</li>\n<li>浏览器解析渲染页面</li>\n<li>连接结束</li>\n</ol>\n<p>具体可以参考下面这篇文章：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000006879700\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000006879700</a></li>\n</ul>\n<h2 id=\"六-状态码\"> 六 状态码</h2>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/状态码.png\" alt=\"状态码\" /></p>\n<h2 id=\"七-各种协议与-http-协议之间的关系\"> 七 各种协议与 HTTP 协议之间的关系</h2>\n<p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p>\n<p>图片来源：《图解 HTTP》</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/各种协议与HTTP协议之间的关系.png\" alt=\"各种协议与HTTP协议之间的关系\" /></p>\n<h2 id=\"八-http-长连接-短连接\"> 八 HTTP 长连接, 短连接</h2>\n<p>在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。</p>\n<p>而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：</p>\n<div><pre><code>Connection:keep-alive\n</code></pre>\n<div><span>1</span><br></div></div><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>\n<p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong></p>\n<p>—— <a href=\"https://www.cnblogs.com/gotodsp/p/6366163.html\" target=\"_blank\" rel=\"noopener noreferrer\">《HTTP 长连接、短连接究竟是什么？》</a></p>\n<h2 id=\"九-http-是不保存状态的协议-如何保存用户状态\"> 九 HTTP 是不保存状态的协议, 如何保存用户状态?</h2>\n<p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p>\n<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>\n<p><strong>Cookie 被禁用怎么办?</strong></p>\n<p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HTTP是无状态的.png\" alt=\"HTTP是无状态协议\" /></p>\n<h2 id=\"十-cookie-的作用是什么-和-session-有什么区别\"> 十 Cookie 的作用是什么? 和 Session 有什么区别？</h2>\n<p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>\n<p><strong>Cookie 一般用来保存用户信息</strong> 比如 ① 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；② 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③ 登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>\n<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>\n<p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>\n<h2 id=\"十一-http-1-0-和-http-1-1-的主要区别是什么\"> 十一 HTTP 1.0 和 HTTP 1.1 的主要区别是什么?</h2>\n<blockquote>\n<p>这部分回答引用这篇文章 <a href=\"https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?</a> 的一些内容。</p>\n</blockquote>\n<p>HTTP1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而 HTTP1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP1.1 也是当前使用最为广泛的 HTTP 协议。 主要区别主要体现在：</p>\n<ol>\n<li><strong>长连接</strong> : <strong>在 HTTP/1.0 中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于 TCP/IP 协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1 起，默认使用长连接</strong> ,默认开启 Connection： keep-alive。 <strong>HTTP/1.1 的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到 HTTP 的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>\n<li><strong>错误状态响应码</strong> :在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>\n<li><strong>缓存处理</strong> :在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>\n<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>\n</ol>\n<h2 id=\"十二-uri-和-url-的区别是什么\"> 十二 URI 和 URL 的区别是什么?</h2>\n<ul>\n<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>\n<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>\n</ul>\n<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>\n<h2 id=\"十三-http-和-https-的区别\"> 十三 HTTP 和 HTTPS 的区别？</h2>\n<ol>\n<li><strong>端口</strong> ：HTTP 的 URL 由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li>\n<li><strong>安全性和资源消耗：</strong> HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。\n<ul>\n<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES 等；</li>\n<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"建议\"> 建议</h2>\n<p>非常推荐大家看一下 《图解 HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p>\n<h2 id=\"参考\"> 参考</h2>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_16209077/article/details/52718250\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/qq_16209077/article/details/52718250</a></li>\n<li><a href=\"https://blog.csdn.net/zixiaomuwu/article/details/60965466\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/zixiaomuwu/article/details/60965466</a></li>\n<li><a href=\"https://blog.csdn.net/turn__back/article/details/73743641\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/turn__back/article/details/73743641</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?</a></li>\n</ul>\n",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/五层体系结构.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "Shell 编程入门",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/operating-system/shell/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/cs-basics/operating-system/shell/",
      "content_html": "<h1 id=\"shell-编程入门\"> Shell 编程入门</h1>\n<h2 id=\"走进-shell-编程的大门\"> 走进 Shell 编程的大门</h2>\n<h3 id=\"为什么要学shell\"> 为什么要学Shell？</h3>\n<p>学一个东西，我们大部分情况都是往实用性方向着想。从工作角度来讲，学习 Shell 是为了提高我们自己工作效率，提高产出，让我们在更少的时间完成更多的事情。</p>\n<p>很多人会说 Shell 编程属于运维方面的知识了，应该是运维人员来做，我们做后端开发的没必要学。我觉得这种说法大错特错，相比于专门做Linux运维的人员来说，我们对 Shell 编程掌握程度的要求要比他们低，但是shell编程也是我们必须要掌握的！</p>\n<p>目前Linux系统下最流行的运维自动化语言就是Shell和Python了。</p>\n<p>两者之间，Shell几乎是IT企业必须使用的运维自动化编程语言，特别是在运维工作中的服务监控、业务快速部署、服务启动停止、数据备份及处理、日志分析等环节里，shell是不可缺的。Python 更适合处理复杂的业务逻辑，以及开发复杂的运维软件工具，实现通过web访问等。Shell是一个命令解释器，解释执行用户所输入的命令和程序。一输入命令，就立即回应的交互的对话方式。</p>\n<p>另外，了解 shell 编程也是大部分互联网公司招聘后端开发人员的要求。下图是我截取的一些知名互联网公司对于 Shell 编程的要求。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-16/60190220.jpg\" alt=\"大型互联网公司对于shell编程技能的要求\" /></p>\n<h3 id=\"什么是-shell\"> 什么是 Shell？</h3>\n<p>简单来说“Shell编程就是对一堆Linux命令的逻辑化处理”。</p>\n<p>W3Cschool 上的一篇文章是这样介绍 Shell的，如下图所示。\n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-26/19456505.jpg\" alt=\"什么是 Shell？\" /></p>\n<h3 id=\"shell-编程的-hello-world\"> Shell 编程的 Hello World</h3>\n<p>学习任何一门编程语言第一件事就是输出HelloWorld了！下面我会从新建文件到shell代码编写来说下Shell 编程如何输出Hello World。</p>\n<p>(1)新建一个文件 helloworld.sh :<code>touch helloworld.sh</code>，扩展名为 sh（sh代表Shell）（扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了）</p>\n<p>(2) 使脚本具有执行权限：<code>chmod +x helloworld.sh</code></p>\n<p>(3) 使用 vim 命令修改helloworld.sh文件：<code>vim helloworld.sh</code>(vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入:wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）)</p>\n<p>helloworld.sh 内容如下：</p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>#第一个shell小程序,echo 是linux中的输出命令。</span>\n<span>echo</span>  <span>\"helloworld!\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>shell中 # 符号表示注释。<strong>shell 的第一行比较特殊，一般都会以#!开始来指定使用的 shell 类型。在linux中，除了bash shell以外，还有很多版本的shell， 例如zsh、dash等等...不过bash shell还是我们使用最多的。</strong></p>\n<p>(4) 运行脚本:<code>./helloworld.sh</code> 。（注意，一定要写成 <code>./helloworld.sh</code> ，而不是 <code>helloworld.sh</code> ，运行其它二进制的程序也一样，直接写 <code>helloworld.sh</code> ，linux 系统会去 PATH 里寻找有没有叫 helloworld.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 <code>helloworld.sh</code> 是会找不到命令的，要用<code>./helloworld.sh</code> 告诉系统说，就在当前目录找。）</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-16/55296212.jpg\" alt=\"shell 编程Hello World\" /></p>\n<h2 id=\"shell-变量\"> Shell 变量</h2>\n<h3 id=\"shell-编程中的变量介绍\"> Shell 编程中的变量介绍</h3>\n<p><strong>Shell编程中一般分为三种变量：</strong></p>\n<ol>\n<li><strong>我们自己定义的变量（自定义变量）:</strong> 仅在当前 Shell 实例中有效，其他 Shell 启动的程序不能访问局部变量。</li>\n<li><strong>Linux已定义的环境变量</strong>（环境变量， 例如：<code>PATH</code>, ​<code>HOME</code> 等..., 这类变量我们可以直接使用），使用 <code>env</code> 命令可以查看所有的环境变量，而set命令既可以查看环境变量也可以查看自定义变量。</li>\n<li><strong>Shell变量</strong> ：Shell变量是由 Shell 程序设置的特殊变量。Shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 Shell 的正常运行</li>\n</ol>\n<p><strong>常用的环境变量:</strong></p>\n<blockquote>\n<p>PATH 决定了shell将到哪些目录中寻找命令或程序<br>\nHOME 当前用户主目录<br>\nHISTSIZE　历史记录数<br>\nLOGNAME 当前用户的登录名<br>\nHOSTNAME　指主机的名称<br>\nSHELL 当前用户Shell类型<br>\nLANGUAGE 　语言相关的环境变量，多语言可以修改此环境变量<br>\nMAIL　当前用户的邮件存放目录<br>\nPS1　基本提示符，对于root用户是#，对于普通用户是$</p>\n</blockquote>\n<p><strong>使用 Linux 已定义的环境变量：</strong></p>\n<p>比如我们要看当前用户目录可以使用：<code>echo $HOME</code>命令；如果我们要看当前用户Shell类型 可以使用<code>echo $SHELL</code>命令。可以看出，使用方法非常简单。</p>\n<p><strong>使用自己定义的变量：</strong></p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>#自定义变量hello</span>\n<span>hello</span><span>=</span><span>\"hello world\"</span>\n<span>echo</span> <span>$hello</span>\n<span>echo</span>  <span>\"helloworld!\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-17/19835037.jpg\" alt=\"使用自己定义的变量\" /></p>\n<p><strong>Shell 编程中的变量名的命名的注意事项：</strong></p>\n<ul>\n<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头，但是可以使用下划线（_）开头。</li>\n<li>中间不能有空格，可以使用下划线（_）。</li>\n<li>不能使用标点符号。</li>\n<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>\n</ul>\n<h3 id=\"shell-字符串入门\"> Shell 字符串入门</h3>\n<p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号。这点和Java中有所不同。</p>\n<p><strong>单引号字符串：</strong></p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>name</span><span>=</span><span>'SnailClimb'</span>\n<span>hello</span><span>=</span><span>'Hello, I  am '</span><span>$name</span><span>'!'</span>\n<span>echo</span> <span>$hello</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>输出内容：</p>\n<div><pre><code>Hello, I am SnailClimb!\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>双引号字符串：</strong></p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>name</span><span>=</span><span>'SnailClimb'</span>\n<span>hello</span><span>=</span><span>\"Hello, I  am \"</span><span>$name</span><span>\"!\"</span>\n<span>echo</span> <span>$hello</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>输出内容：</p>\n<div><pre><code>Hello, I am SnailClimb!\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"shell-字符串常见操作\"> Shell 字符串常见操作</h3>\n<p><strong>拼接字符串：</strong></p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>name</span><span>=</span><span>\"SnailClimb\"</span>\n<span># 使用双引号拼接</span>\n<span>greeting</span><span>=</span><span>\"hello, \"</span><span>$name</span><span>\" !\"</span>\n<span>greeting_1</span><span>=</span><span>\"hello, <span>${name}</span> !\"</span>\n<span>echo</span> <span>$greeting</span>  <span>$greeting_1</span>\n<span># 使用单引号拼接</span>\n<span>greeting_2</span><span>=</span><span>'hello, '</span><span>$name</span><span>' !'</span>\n<span>greeting_3</span><span>=</span><span>'hello, ${name} !'</span>\n<span>echo</span> <span>$greeting_2</span>  <span>$greeting_3</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>输出结果：</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-17/51148933.jpg\" alt=\"输出结果\" /></p>\n<p><strong>获取字符串长度：</strong></p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>#获取字符串长度</span>\n<span>name</span><span>=</span><span>\"SnailClimb\"</span>\n<span># 第一种方式</span>\n<span>echo</span> <span>${<span>#</span>name}</span> <span>#输出 10</span>\n<span># 第二种方式</span>\n<span>expr</span> length <span>\"<span>$name</span>\"</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>输出结果:</p>\n<div><pre><code>10\n10\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>使用 expr 命令时，表达式中的运算符左右必须包含空格，如果不包含空格，将会输出表达式本身:</p>\n<div><pre><code><span>expr</span> <span>5</span>+6    // 直接输出 <span>5</span>+6\n<span>expr</span> <span>5</span> + <span>6</span>       // 输出 <span>11</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>对于某些运算符，还需要我们使用符号<code>\\</code>进行转义，否则就会提示语法错误。</p>\n<div><pre><code><span>expr</span> <span>5</span> * <span>6</span>       // 输出错误\n<span>expr</span> <span>5</span> <span>\\</span>* <span>6</span>      // 输出30\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><strong>截取子字符串:</strong></p>\n<p>简单的字符串截取：</p>\n<div><pre><code><span>#从字符串第 1 个字符开始往后截取 10 个字符</span>\n<span>str</span><span>=</span><span>\"SnailClimb is a great man\"</span>\n<span>echo</span> <span>${str<span>:</span>0<span>:</span>10}</span> <span>#输出:SnailClimb</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>根据表达式截取：</p>\n<div><pre><code><span>#!bin/bash</span>\n<span>#author:amau</span>\n\n<span>var</span><span>=</span><span>\"https://www.runoob.com/linux/linux-shell-variable.html\"</span>\n<span># %表示删除从后匹配, 最短结果</span>\n<span># %%表示删除从后匹配, 最长匹配结果</span>\n<span># #表示删除从头匹配, 最短结果</span>\n<span># ##表示删除从头匹配, 最长匹配结果</span>\n<span># 注: *为通配符, 意为匹配任意数量的任意字符</span>\n<span>s1</span><span>=</span><span>${var<span>%%</span>t*}</span> <span>#h</span>\n<span>s2</span><span>=</span><span>${var<span>%</span>t*}</span>  <span>#https://www.runoob.com/linux/linux-shell-variable.h</span>\n<span>s3</span><span>=</span><span>${var<span>%%</span>.*}</span> <span>#http://www</span>\n<span>s4</span><span>=</span><span>${var<span>#</span>*<span>/</span>}</span>  <span>#/www.runoob.com/linux/linux-shell-variable.html</span>\n<span>s5</span><span>=</span><span>${var<span>##</span>*<span>/</span>}</span> <span>#linux-shell-variable.html</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"shell-数组\"> Shell 数组</h3>\n<p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。我下面给了大家一个关于数组操作的 Shell 代码示例，通过该示例大家可以知道如何创建数组、获取数组长度、获取/删除特定位置的数组元素、删除整个数组以及遍历数组。</p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>array</span><span>=</span><span>(</span><span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span><span>)</span><span>;</span>\n<span># 获取数组长度</span>\n<span>length</span><span>=</span><span>${<span>#</span>array<span>[</span>@<span>]</span>}</span>\n<span># 或者</span>\n<span>length2</span><span>=</span><span>${<span>#</span>array<span>[</span>*<span>]</span>}</span>\n<span>#输出数组长度</span>\n<span>echo</span> <span>$length</span> <span>#输出：5</span>\n<span>echo</span> <span>$length2</span> <span>#输出：5</span>\n<span># 输出数组第三个元素</span>\n<span>echo</span> <span>${array<span>[</span>2<span>]</span>}</span> <span>#输出：3</span>\n<span>unset</span> array<span>[</span><span>1</span><span>]</span><span># 删除下标为1的元素也就是删除第二个元素</span>\n<span>for</span> <span>i</span> <span>in</span> <span>${array<span>[</span>@<span>]</span>}</span><span>;</span><span>do</span> <span>echo</span> <span>$i</span> <span>;</span><span>done</span> <span># 遍历数组，输出： 1 3 4 5 </span>\n<span>unset</span> array<span>;</span> <span># 删除数组中的所有元素</span>\n<span>for</span> <span>i</span> <span>in</span> <span>${array<span>[</span>@<span>]</span>}</span><span>;</span><span>do</span> <span>echo</span> <span>$i</span> <span>;</span><span>done</span> <span># 遍历数组，数组元素为空，没有任何输出内容</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"shell-基本运算符\"> Shell 基本运算符</h2>\n<blockquote>\n<p>说明：图片来自《菜鸟教程》</p>\n</blockquote>\n<p>Shell 编程支持下面几种运算符</p>\n<ul>\n<li>算数运算符</li>\n<li>关系运算符</li>\n<li>布尔运算符</li>\n<li>字符串运算符</li>\n<li>文件测试运算符</li>\n</ul>\n<h3 id=\"算数运算符\"> 算数运算符</h3>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/4937342.jpg\" alt=\"算数运算符\" /></p>\n<p>我以加法运算符做一个简单的示例（注意：不是单引号，是反引号）：</p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>a</span><span>=</span><span>3</span><span>;</span><span>b</span><span>=</span><span>3</span><span>;</span>\n<span>val</span><span>=</span><span><span>`</span><span>expr</span> $a + $b<span>`</span></span>\n<span>#输出：Total value : 6</span>\n<span>echo</span> <span>\"Total value : <span>$val</span>\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"关系运算符\"> 关系运算符</h3>\n<p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/64391380.jpg\" alt=\"shell关系运算符\" /></p>\n<p>通过一个简单的示例演示关系运算符的使用，下面shell程序的作用是当score=100的时候输出A否则输出B。</p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>score</span><span>=</span><span>90</span><span>;</span>\n<span>maxscore</span><span>=</span><span>100</span><span>;</span>\n<span>if</span> <span>[</span> <span>$score</span> -eq <span>$maxscore</span> <span>]</span>\n<span>then</span>\n   <span>echo</span> <span>\"A\"</span>\n<span>else</span>\n   <span>echo</span> <span>\"B\"</span>\n<span>fi</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>输出结果：</p>\n<div><pre><code>B\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"逻辑运算符\"> 逻辑运算符</h3>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/60545848.jpg\" alt=\"逻辑运算符\" /></p>\n<p>示例：</p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>a</span><span>=</span><span><span>$((</span> <span>1</span> <span>&amp;&amp;</span> <span>0</span><span>))</span></span>\n<span># 输出：0；逻辑与运算只有相与的两边都是1，与的结果才是1；否则与的结果是0</span>\n<span>echo</span> <span>$a</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"布尔运算符\"> 布尔运算符</h3>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/93961425.jpg\" alt=\"布尔运算符\" /></p>\n<p>这里就不做演示了，应该挺简单的。</p>\n<h3 id=\"字符串运算符\"> 字符串运算符</h3>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/309094.jpg\" alt=\" 字符串运算符\" /></p>\n<p>简单示例：</p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>a</span><span>=</span><span>\"abc\"</span><span>;</span>\n<span>b</span><span>=</span><span>\"efg\"</span><span>;</span>\n<span>if</span> <span>[</span> <span>$a</span> <span>=</span> <span>$b</span> <span>]</span>\n<span>then</span>\n   <span>echo</span> <span>\"a 等于 b\"</span>\n<span>else</span>\n   <span>echo</span> <span>\"a 不等于 b\"</span>\n<span>fi</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>输出：</p>\n<div><pre><code>a 不等于 b\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"文件相关运算符\"> 文件相关运算符</h3>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/60359774.jpg\" alt=\"文件相关运算符\" /></p>\n<p>使用方式很简单，比如我们定义好了一个文件路径<code>file=&quot;/usr/learnshell/test.sh&quot;</code> 如果我们想判断这个文件是否可读，可以这样<code>if [ -r $file ]</code> 如果想判断这个文件是否可写，可以这样<code>-w $file</code>，是不是很简单。</p>\n<h2 id=\"shell流程控制\"> shell流程控制</h2>\n<h3 id=\"if-条件语句\"> if 条件语句</h3>\n<p>简单的 if else-if else 的条件语句示例</p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>a</span><span>=</span><span>3</span><span>;</span>\n<span>b</span><span>=</span><span>9</span><span>;</span>\n<span>if</span> <span>[</span> <span>$a</span> -eq <span>$b</span> <span>]</span>\n<span>then</span>\n   <span>echo</span> <span>\"a 等于 b\"</span>\n<span>elif</span> <span>[</span> <span>$a</span> -gt <span>$b</span> <span>]</span>\n<span>then</span>\n   <span>echo</span> <span>\"a 大于 b\"</span>\n<span>else</span>\n   <span>echo</span> <span>\"a 小于 b\"</span>\n<span>fi</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>输出结果：</p>\n<div><pre><code>a 小于 b\n</code></pre>\n<div><span>1</span><br></div></div><p>相信大家通过上面的示例就已经掌握了 shell 编程中的 if 条件语句。不过，还要提到的一点是，不同于我们常见的 Java 以及 PHP 中的 if 条件语句，shell  if 条件语句中不能包含空语句也就是什么都不做的语句。</p>\n<h3 id=\"for-循环语句\"> for 循环语句</h3>\n<p>通过下面三个简单的示例认识 for 循环语句最基本的使用，实际上 for 循环语句的功能比下面你看到的示例展现的要大得多。</p>\n<p><strong>输出当前列表中的数据：</strong></p>\n<div><pre><code><span>for</span> <span>loop</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span>\n<span>do</span>\n    <span>echo</span> <span>\"The value is: <span>$loop</span>\"</span>\n<span>done</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>产生 10 个随机数：</strong></p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>for</span> <span>i</span> <span>in</span> <span>{</span><span>0</span><span>..</span><span>9</span><span>}</span><span>;</span>\n<span>do</span> \n   <span>echo</span> <span>$RANDOM</span><span>;</span>\n<span>done</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>输出1到5:</strong></p>\n<p>通常情况下 shell 变量调用需要加 $,但是 for 的 (()) 中不需要,下面来看一个例子：</p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>for</span><span><span>((</span>i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span><span>5</span><span>;</span>i<span>++</span><span>))</span></span><span>;</span><span>do</span>\n    <span>echo</span> <span>$i</span><span>;</span>\n<span>done</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"while-语句\"> while 语句</h3>\n<p><strong>基本的 while 循环语句：</strong></p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>int</span><span>=</span><span>1</span>\n<span>while</span><span><span>((</span> $int<span>&lt;=</span><span>5</span> <span>))</span></span>\n<span>do</span>\n    <span>echo</span> <span>$int</span>\n    <span>let</span> <span>\"int++\"</span>\n<span>done</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>while循环可用于读取键盘信息：</strong></p>\n<div><pre><code><span>echo</span> <span>'按下 &lt;CTRL-D> 退出'</span>\n<span>echo</span> -n <span>'输入你最喜欢的电影: '</span>\n<span>while</span> <span>read</span> FILM\n<span>do</span>\n    <span>echo</span> <span>\"是的！<span>$FILM</span> 是一个好电影\"</span>\n<span>done</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>输出内容:</p>\n<div><pre><code>按下 &lt;CTRL-D&gt; 退出\n输入你最喜欢的电影: 变形金刚\n是的！变形金刚 是一个好电影\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>无限循环：</strong></p>\n<div><pre><code><span>while</span> <span>true</span>\n<span>do</span>\n    <span>command</span>\n<span>done</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"shell-函数\"> shell 函数</h2>\n<h3 id=\"不带参数没有返回值的函数\"> 不带参数没有返回值的函数</h3>\n<div><pre><code><span>#!/bin/bash</span>\n<span>hello</span><span>(</span><span>)</span><span>{</span>\n    <span>echo</span> <span>\"这是我的第一个 shell 函数!\"</span>\n<span>}</span>\n<span>echo</span> <span>\"-----函数开始执行-----\"</span>\nhello\n<span>echo</span> <span>\"-----函数执行完毕-----\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>输出结果：</p>\n<div><pre><code>-----函数开始执行-----\n这是我的第一个 shell 函数!\n-----函数执行完毕-----\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"有返回值的函数\"> 有返回值的函数</h3>\n<p><strong>输入两个数字之后相加并返回结果：</strong></p>\n<div><pre><code><span>#!/bin/bash</span>\n<span>funWithReturn</span><span>(</span><span>)</span><span>{</span>\n    <span>echo</span> <span>\"输入第一个数字: \"</span>\n    <span>read</span> aNum\n    <span>echo</span> <span>\"输入第二个数字: \"</span>\n    <span>read</span> anotherNum\n    <span>echo</span> <span>\"两个数字分别为 <span>$aNum</span> 和 <span>$anotherNum</span> !\"</span>\n    <span>return</span> <span><span>$((</span>$aNum<span>+</span>$anotherNum<span>))</span></span>\n<span>}</span>\nfunWithReturn\n<span>echo</span> <span>\"输入的两个数字之和为 <span>$?</span>\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>输出结果：</p>\n<div><pre><code>输入第一个数字: \n1\n输入第二个数字: \n2\n两个数字分别为 1 和 2 !\n输入的两个数字之和为 3\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"带参数的函数\"> 带参数的函数</h3>\n<div><pre><code><span>#!/bin/bash</span>\n<span>funWithParam</span><span>(</span><span>)</span><span>{</span>\n    <span>echo</span> <span>\"第一个参数为 <span>$1</span> !\"</span>\n    <span>echo</span> <span>\"第二个参数为 <span>$2</span> !\"</span>\n    <span>echo</span> <span>\"第十个参数为 <span>$10</span> !\"</span>\n    <span>echo</span> <span>\"第十个参数为 <span>${10}</span> !\"</span>\n    <span>echo</span> <span>\"第十一个参数为 <span>${11}</span> !\"</span>\n    <span>echo</span> <span>\"参数总数有 <span>$#</span> 个!\"</span>\n    <span>echo</span> <span>\"作为一个字符串输出所有参数 <span>$*</span> !\"</span>\n<span>}</span>\nfunWithParam <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span> <span>8</span> <span>9</span> <span>34</span> <span>73</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>输出结果：</p>\n<div><pre><code>第一个参数为 1 !\n第二个参数为 2 !\n第十个参数为 10 !\n第十个参数为 34 !\n第十一个参数为 73 !\n参数总数有 11 个!\n作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-16/60190220.jpg",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "一条 SQL 语句在 MySQL 中如何被执行的?",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/how-sql-executed-in-mysql/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/how-sql-executed-in-mysql/",
      "content_html": "<p>本文来自<a href=\"https://github.com/kinglaw1204\" target=\"_blank\" rel=\"noopener noreferrer\">木木匠</a>投稿。</p>\n<p>本篇文章会分析下一个 sql 语句在 MySQL 中的执行流程，包括 sql 的查询在 MySQL 内部会怎么流转，sql 语句的更新是怎么完成的。</p>\n<p>在分析之前我会先带着你看看 MySQL 的基础架构，知道了 MySQL 由那些组件组成以及这些组件的作用是什么，可以帮助我们理解和解决这些问题。</p>\n<h2 id=\"一-mysql-基础架构分析\"> 一 MySQL 基础架构分析</h2>\n<h3 id=\"_1-1-mysql-基本架构概览\"> 1.1 MySQL 基本架构概览</h3>\n<p>下图是 MySQL  的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。</p>\n<p>先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。</p>\n<ul>\n<li>**连接器：**身份认证和权限相关(登录 MySQL 的时候)。</li>\n<li>**查询缓存：**执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>\n<li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>\n<li>**优化器：**按照 MySQL 认为最优的方案去执行。</li>\n<li>**执行器：**执行语句，然后从存储引擎返回数据。</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/23/169a8bc60a083849?w=950&h=1062&f=jpeg&s=38189\" alt=\"\" /></p>\n<p>简单来说 MySQL  主要分为 Server 层和存储引擎层：</p>\n<ul>\n<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li>\n<li><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></li>\n</ul>\n<h3 id=\"_1-2-server-层基本组件介绍\"> 1.2 Server 层基本组件介绍</h3>\n<h4 id=\"_1-连接器\"> 1) 连接器</h4>\n<p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。</p>\n<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。</p>\n<h4 id=\"_2-查询缓存-mysql-8-0-版本后移除\"> 2) 查询缓存(MySQL 8.0 版本后移除)</h4>\n<p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>\n<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>\n<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>\n<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>\n<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>\n<h4 id=\"_3-分析器\"> 3) 分析器</h4>\n<p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>\n<p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>\n<p><strong>第二步，语法分析</strong>，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p>\n<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>\n<h4 id=\"_4-优化器\"> 4) 优化器</h4>\n<p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>\n<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>\n<h4 id=\"_5-执行器\"> 5) 执行器</h4>\n<p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>\n<h2 id=\"二-语句分析\"> 二 语句分析</h2>\n<h3 id=\"_2-1-查询语句\"> 2.1 查询语句</h3>\n<p>说了以上这么多，那么究竟一条 sql 语句是如何执行的呢？其实我们的 sql 可以分为两种，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：</p>\n<div><pre><code><span>select</span> <span>*</span> <span>from</span> tb_student  A <span>where</span> A<span>.</span>age<span>=</span><span>'18'</span> <span>and</span> A<span>.</span>name<span>=</span><span>' 张三 '</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>结合上面的说明，我们分析下这个语句的执行流程：</p>\n<ul>\n<li>\n<p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p>\n</li>\n<li>\n<p>通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p>\n</li>\n<li>\n<p>接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：</p>\n<div><pre><code>  a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。\n  b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。\n</code></pre>\n</div><p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>\n</li>\n<li>\n<p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p>\n</li>\n</ul>\n<h3 id=\"_2-2-更新语句\"> 2.2 更新语句</h3>\n<p>以上就是一条查询 sql 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？sql 语句如下：</p>\n<div><pre><code>update tb_student A set A.age=&#39;19&#39; where A.name=&#39; 张三 &#39;;\n</code></pre>\n<div><span>1</span><br></div></div><p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>\n<ul>\n<li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li>\n<li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>\n<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>\n<li>更新完成。</li>\n</ul>\n<p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p>\n<p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p>\n<p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>\n<ul>\n<li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>\n<li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>\n</ul>\n<p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？\n这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p>\n<ul>\n<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>\n<li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li>\n</ul>\n<p>这样就解决了数据一致性的问题。</p>\n<h2 id=\"三-总结\"> 三 总结</h2>\n<ul>\n<li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</li>\n<li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li>\n<li>查询语句的执行流程如下：权限校验（如果命中缓存）---&gt;查询缓存---&gt;分析器---&gt;优化器---&gt;权限校验---&gt;执行器---&gt;引擎</li>\n<li>更新语句执行流程如下：分析器----&gt;权限校验----&gt;执行器---&gt;引擎---redo log(prepare 状态)---&gt;binlog---&gt;redo log(commit状态)</li>\n</ul>\n<h2 id=\"四-参考\"> 四 参考</h2>\n<ul>\n<li>《MySQL 实战45讲》</li>\n<li>MySQL 5.6参考手册:<a href=\"https://dev.MySQL.com/doc/refman/5.6/en/\" target=\"_blank\" rel=\"noopener noreferrer\">https://dev.MySQL.com/doc/refman/5.6/en/</a></li>\n</ul>\n",
      "image": "https://user-gold-cdn.xitu.io/2019/3/23/169a8bc60a083849?w=950&h=1062&f=jpeg&s=38189",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "一千行 MySQL 学习笔记",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/a-thousand-lines-of-mysql-study-notes/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/a-thousand-lines-of-mysql-study-notes/",
      "content_html": "<blockquote>\n<p>原文地址：https://shockerli.net/post/1000-line-mysql-note/ ，JavaGuide 对本文进行了简答排版，新增了目录。\n作者：格物</p>\n</blockquote>\n<p>非常不错的总结，强烈建议保存下来，需要的时候看一看。</p>\n<h3 id=\"基本操作\"> 基本操作</h3>\n<div><pre><code>/* Windows服务 */\n-- 启动MySQL\n    net start mysql\n-- 创建Windows服务\n    sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)\n/* 连接与断开服务器 */\nmysql -h 地址 -P 端口 -u 用户名 -p 密码\nSHOW PROCESSLIST -- 显示哪些线程正在运行\nSHOW VARIABLES -- 显示系统变量信息\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"数据库操作\"> 数据库操作</h3>\n<div><pre><code>/* 数据库操作 */ ------------------\n-- 查看当前数据库\n    SELECT DATABASE();\n-- 显示当前时间、用户名、数据库版本\n    SELECT now(), user(), version();\n-- 创建库\n    CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项\n    数据库选项：\n        CHARACTER SET charset_name\n        COLLATE collation_name\n-- 查看已有库\n    SHOW DATABASES[ LIKE &#39;PATTERN&#39;]\n-- 查看当前库信息\n    SHOW CREATE DATABASE 数据库名\n-- 修改库的选项信息\n    ALTER DATABASE 库名 选项信息\n-- 删除库\n    DROP DATABASE[ IF EXISTS] 数据库名\n        同时删除该数据库相关的目录及其目录内容\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id=\"表的操作\"> 表的操作</h3>\n<div><pre><code>-- 创建表\n    CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]\n        每个字段必须有数据类型\n        最后一个字段后不能有逗号\n        TEMPORARY 临时表，会话结束时表自动消失\n        对于字段的定义：\n            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#39;string&#39;]\n-- 表选项\n    -- 字符集\n        CHARSET = charset_name\n        如果表没有设定，则使用数据库字符集\n    -- 存储引擎\n        ENGINE = engine_name\n        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同\n        常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive\n        不同的引擎在保存表的结构和数据时采用不同的方式\n        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引\n        InnoDB表文件含义：.frm表定义，表空间数据和日志文件\n        SHOW ENGINES -- 显示存储引擎的状态信息\n        SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息\n    -- 自增起始数\n    \tAUTO_INCREMENT = 行数\n    -- 数据文件目录\n        DATA DIRECTORY = &#39;目录&#39;\n    -- 索引文件目录\n        INDEX DIRECTORY = &#39;目录&#39;\n    -- 表注释\n        COMMENT = &#39;string&#39;\n    -- 分区选项\n        PARTITION BY ... (详细见手册)\n-- 查看所有表\n    SHOW TABLES[ LIKE &#39;pattern&#39;]\n    SHOW TABLES FROM  库名\n-- 查看表结构\n    SHOW CREATE TABLE 表名 （信息更详细）\n    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &#39;PATTERN&#39;]\n    SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;]\n-- 修改表\n    -- 修改表本身的选项\n        ALTER TABLE 表名 表的选项\n        eg: ALTER TABLE 表名 ENGINE=MYISAM;\n    -- 对表进行重命名\n        RENAME TABLE 原表名 TO 新表名\n        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）\n        -- RENAME可以交换两个表名\n    -- 修改表的字段机构（13.1.2. ALTER TABLE语法）\n        ALTER TABLE 表名 操作名\n        -- 操作名\n            ADD[ COLUMN] 字段定义       -- 增加字段\n                AFTER 字段名          -- 表示增加在该字段名后面\n                FIRST               -- 表示增加在第一个\n            ADD PRIMARY KEY(字段名)   -- 创建主键\n            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引\n            ADD INDEX [索引名] (字段名) -- 创建普通索引\n            DROP[ COLUMN] 字段名      -- 删除字段\n            MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)\n            CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改\n            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)\n            DROP INDEX 索引名 -- 删除索引\n            DROP FOREIGN KEY 外键    -- 删除外键\n-- 删除表\n    DROP TABLE[ IF EXISTS] 表名 ...\n-- 清空表数据\n    TRUNCATE [TABLE] 表名\n-- 复制表结构\n    CREATE TABLE 表名 LIKE 要复制的表名\n-- 复制表结构和数据\n    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名\n-- 检查表是否有错误\n    CHECK TABLE tbl_name [, tbl_name] ... [option] ...\n-- 优化表\n    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...\n-- 修复表\n    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]\n-- 分析表\n    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div><h3 id=\"数据操作\"> 数据操作</h3>\n<div><pre><code>/* 数据操作 */ ------------------\n-- 增\n    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]\n        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。\n        -- 可同时插入多条数据记录！\n        REPLACE 与 INSERT 完全一样，可互换。\n    INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]\n-- 查\n    SELECT 字段列表 FROM 表名[ 其他子句]\n        -- 可来自多个表的多个字段\n        -- 其他子句可以不使用\n        -- 字段列表可以用*代替，表示所有字段\n-- 删\n    DELETE FROM 表名[ 删除条件子句]\n        没有条件子句，则会删除全部\n-- 改\n    UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"字符集编码\"> 字符集编码</h3>\n<div><pre><code>/* 字符集编码 */ ------------------\n-- MySQL、数据库、表、字段均可设置编码\n-- 数据编码与客户端编码不需一致\nSHOW VARIABLES LIKE &#39;character_set_%&#39;   -- 查看所有字符集编码项\n    character_set_client        客户端向服务器发送数据时使用的编码\n    character_set_results       服务器端将结果返回给客户端所使用的编码\n    character_set_connection    连接层编码\nSET 变量名 = 变量值\n    SET character_set_client = gbk;\n    SET character_set_results = gbk;\n    SET character_set_connection = gbk;\nSET NAMES GBK;  -- 相当于完成以上三个设置\n-- 校对集\n    校对集用以排序\n    SHOW CHARACTER SET [LIKE &#39;pattern&#39;]/SHOW CHARSET [LIKE &#39;pattern&#39;]   查看所有字符集\n    SHOW COLLATION [LIKE &#39;pattern&#39;]     查看所有校对集\n    CHARSET 字符集编码     设置字符集编码\n    COLLATE 校对集编码     设置校对集编码\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"数据类型-列类型\"> 数据类型(列类型)</h3>\n<div><pre><code>/* 数据类型（列类型） */ ------------------\n1. 数值类型\n-- a. 整型 ----------\n    类型         字节     范围（有符号位）\n    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255\n    smallint    2字节    -32768 ~ 32767\n    mediumint   3字节    -8388608 ~ 8388607\n    int         4字节\n    bigint      8字节\n    int(M)  M表示总位数\n    - 默认存在符号位，unsigned 属性修改\n    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改\n        例：int(5)   插入一个数&#39;123&#39;，补填后为&#39;00123&#39;\n    - 在满足要求的情况下，越小越好。\n    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。\n-- b. 浮点型 ----------\n    类型             字节     范围\n    float(单精度)     4字节\n    double(双精度)    8字节\n    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。\n        不同于整型，前后均会补填0.\n    定义浮点型时，需指定总位数和小数位数。\n        float(M, D)     double(M, D)\n        M表示总位数，D表示小数位数。\n        M和D的大小会决定浮点数的范围。不同于整型的固定范围。\n        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。\n        支持科学计数法表示。\n        浮点数表示近似值。\n-- c. 定点数 ----------\n    decimal -- 可变长度\n    decimal(M, D)   M也表示总位数，D表示小数位数。\n    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。\n    将浮点数转换为字符串来保存，每9位数字保存为4个字节。\n2. 字符串类型\n-- a. char, varchar ----------\n    char    定长字符串，速度快，但浪费空间\n    varchar 变长字符串，速度慢，但节省空间\n    M表示能存储的最大长度，此长度是字符数，非字节数。\n    不同的编码，所占用的空间不同。\n    char,最多255个字符，与编码无关。\n    varchar,最多65535字符，与编码有关。\n    一条有效记录最大不能超过65535个字节。\n        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符\n    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。\n    varchar 的最大有效长度由最大行大小和使用的字符集确定。\n    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是65535-1-2=65532字节。\n    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3\n-- b. blob, text ----------\n    blob 二进制字符串（字节字符串）\n        tinyblob, blob, mediumblob, longblob\n    text 非二进制字符串（字符字符串）\n        tinytext, text, mediumtext, longtext\n    text 在定义时，不需要定义长度，也不会计算总长度。\n    text 类型在定义时，不可给default值\n-- c. binary, varbinary ----------\n    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。\n    char, varchar, text 对应 binary, varbinary, blob.\n3. 日期时间类型\n    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。\n    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59\n    date        3字节    日期         1000-01-01 到 9999-12-31\n    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07\n    time        3字节    时间         -838:59:59 到 838:59:59\n    year        1字节    年份         1901 - 2155\ndatetime    YYYY-MM-DD hh:mm:ss\ntimestamp   YY-MM-DD hh:mm:ss\n            YYYYMMDDhhmmss\n            YYMMDDhhmmss\n            YYYYMMDDhhmmss\n            YYMMDDhhmmss\ndate        YYYY-MM-DD\n            YY-MM-DD\n            YYYYMMDD\n            YYMMDD\n            YYYYMMDD\n            YYMMDD\ntime        hh:mm:ss\n            hhmmss\n            hhmmss\nyear        YYYY\n            YY\n            YYYY\n            YY\n4. 枚举和集合\n-- 枚举(enum) ----------\nenum(val1, val2, val3...)\n    在已知的值中进行单选。最大数量为65535.\n    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。\n    表现为字符串类型，存储却是整型。\n    NULL值的索引是NULL。\n    空字符串错误值的索引值是0。\n-- 集合（set） ----------\nset(val1, val2, val3...)\n    create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) );\n    insert into tab values (&#39;男, 女&#39;);\n    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。\n    当创建表时，SET成员值的尾部空格将自动被删除。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br></div></div><h3 id=\"列属性-列约束\"> 列属性(列约束)</h3>\n<div><pre><code>/* 列属性（列约束） */ ------------------\n1. PRIMARY 主键\n    - 能唯一标识记录的字段，可以作为主键。\n    - 一个表只能有一个主键。\n    - 主键具有唯一性。\n    - 声明字段时，用 primary key 标识。\n        也可以在字段列表之后声明\n            例：create table tab ( id int, stu varchar(10), primary key (id));\n    - 主键字段的值不能为null。\n    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。\n        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));\n2. UNIQUE 唯一索引（唯一约束）\n    使得某字段的值也不能重复。\n3. NULL 约束\n    null不是数据类型，是列的一个属性。\n    表示当前列是否可以为null，表示什么都没有。\n    null, 允许为空。默认。\n    not null, 不允许为空。\n    insert into tab values (null, &#39;val&#39;);\n        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null\n4. DEFAULT 默认值属性\n    当前字段的默认值。\n    insert into tab values (default, &#39;val&#39;);    -- 此时表示强制使用默认值。\n    create table tab ( add_time timestamp default current_timestamp );\n        -- 表示将当前时间的时间戳设为默认值。\n        current_date, current_time\n5. AUTO_INCREMENT 自动增长约束\n    自动增长必须为索引（主键或unique）\n    只能存在一个字段为自动增长。\n    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;\n6. COMMENT 注释\n    例：create table tab ( id int ) comment &#39;注释内容&#39;;\n7. FOREIGN KEY 外键约束\n    用于限制主表与从表数据完整性。\n    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);\n        -- 将表t1的t1_id外键关联到表t2的id字段。\n        -- 每个外键都有一个名字，可以通过 constraint 指定\n    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。\n    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。\n    MySQL中，可以对InnoDB引擎使用外键约束：\n    语法：\n    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]\n    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。\n    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。\n    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：\n    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。\n    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。\n    3. restrict，拒绝父表删除和更新。\n    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h3 id=\"建表规范\"> 建表规范</h3>\n<div><pre><code>/* 建表规范 */ ------------------\n    -- Normal Format, NF\n        - 每个表保存一个实体信息\n        - 每个具有一个ID字段作为主键\n        - ID主键 + 原子表\n    -- 1NF, 第一范式\n        字段不能再分，就满足第一范式。\n    -- 2NF, 第二范式\n        满足第一范式的前提下，不能出现部分依赖。\n        消除复合主键就可以避免部分依赖。增加单列关键字。\n    -- 3NF, 第三范式\n        满足第二范式的前提下，不能出现传递依赖。\n        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。\n        将一个实体信息的数据放在一个表内实现。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"select\"> SELECT</h3>\n<div><pre><code>/* SELECT */ ------------------\nSELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT\na. select_expr\n    -- 可以用 * 表示所有字段。\n        select * from tb;\n    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）\n        select stu, 29+25, now() from tb;\n    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。\n        - 使用 as 关键字，也可省略 as.\n        select stu+10 as add10 from tb;\nb. FROM 子句\n    用于标识查询来源。\n    -- 可以为表起别名。使用as关键字。\n        SELECT * FROM tb1 AS tt, tb2 AS bb;\n    -- from子句后，可以同时出现多个表。\n        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。\n        SELECT * FROM tb1, tb2;\n    -- 向优化符提示如何选择索引\n        USE INDEX、IGNORE INDEX、FORCE INDEX\n        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;\n        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;\nc. WHERE 子句\n    -- 从from获得的数据源中进行筛选。\n    -- 整型1表示真，0表示假。\n    -- 表达式由运算符和运算数组成。\n        -- 运算数：变量（字段）、值、函数返回值\n        -- 运算符：\n            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,\n            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor\n            is/is not 加上ture/false/unknown，检验某个值的真假\n            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较\nd. GROUP BY 子句, 分组子句\n    GROUP BY 字段/别名 [排序方式]\n    分组后会进行排序。升序：ASC，降序：DESC\n    以下[合计函数]需配合 GROUP BY 使用：\n    count 返回不同的非NULL值数目  count(*)、count(字段)\n    sum 求和\n    max 求最大值\n    min 求最小值\n    avg 求平均值\n    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。\ne. HAVING 子句，条件子句\n    与 where 功能、用法相同，执行时机不同。\n    where 在开始时执行检测数据，对原数据进行过滤。\n    having 对筛选出的结果再次进行过滤。\n    having 字段必须是查询出来的，where 字段必须是数据表存在的。\n    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。\n    where 不可以使用合计函数。一般需用合计函数才会用 having\n    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。\nf. ORDER BY 子句，排序子句\n    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...\n    升序：ASC，降序：DESC\n    支持多个字段的排序。\ng. LIMIT 子句，限制结果数量子句\n    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。\n    limit 起始位置, 获取条数\n    省略第一个参数，表示从索引0开始。limit 获取条数\nh. DISTINCT, ALL 选项\n    distinct 去除重复记录\n    默认为 all, 全部记录\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><h3 id=\"union\"> UNION</h3>\n<div><pre><code>/* UNION */ ------------------\n    将多个select查询的结果组合成一个结果集合。\n    SELECT ... UNION [ALL|DISTINCT] SELECT ...\n    默认 DISTINCT 方式，即所有返回的行都是唯一的\n    建议，对每个SELECT查询加上小括号包裹。\n    ORDER BY 排序时，需加上 LIMIT 进行结合。\n    需要各select查询的字段数量一样。\n    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"子查询\"> 子查询</h3>\n<div><pre><code>/* 子查询 */ ------------------\n    - 子查询需用括号包裹。\n-- from型\n    from后要求是一个表，必须给子查询结果取个别名。\n    - 简化每个查询内的条件。\n    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。\n    - 子查询返回一个表，表型子查询。\n    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;\n-- where型\n    - 子查询返回一个值，标量子查询。\n    - 不需要给子查询取别名。\n    - where子查询内的表，不能直接用以更新。\n    select * from tb where money = (select max(money) from tb);\n    -- 列子查询\n        如果子查询结果返回的是一列。\n        使用 in 或 not in 完成查询\n        exists 和 not exists 条件\n            如果子查询返回数据，则返回1或0。常用于判断条件。\n            select column1 from t1 where exists (select * from t2);\n    -- 行子查询\n        查询条件是一个行。\n        select * from t1 where (id, gender) in (select id, gender from t2);\n        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)\n        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。\n    -- 特殊运算符\n    != all()    相当于 not in\n    = some()    相当于 in。any 是 some 的别名\n    != some()   不等同于 not in，不等于其中某一个。\n    all, some 可以配合其他运算符一起使用。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"连接查询-join\"> 连接查询(join)</h3>\n<div><pre><code>/* 连接查询(join) */ ------------------\n    将多个表的字段进行连接，可以指定连接条件。\n-- 内连接(inner join)\n    - 默认就是内连接，可省略inner。\n    - 只有数据存在时才能发送连接。即连接结果不能出现空行。\n    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）\n    也可用where表示连接条件。\n    还有 using, 但需字段名相同。 using(字段名)\n    -- 交叉连接 cross join\n        即，没有条件的内连接。\n        select * from tb1 cross join tb2;\n-- 外连接(outer join)\n    - 如果数据不存在，也会出现在连接结果中。\n    -- 左外连接 left join\n        如果数据不存在，左表记录会出现，而右表为null填充\n    -- 右外连接 right join\n        如果数据不存在，右表记录会出现，而左表为null填充\n-- 自然连接(natural join)\n    自动判断连接条件完成连接。\n    相当于省略了using，会自动查找相同字段名。\n    natural join\n    natural left join\n    natural right join\nselect info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id=\"truncate\"> TRUNCATE</h3>\n<div><pre><code>/* TRUNCATE */ ------------------\nTRUNCATE [TABLE] tbl_name\n清空数据\n删除重建表\n区别：\n1，truncate 是删除表再创建，delete 是逐条删除\n2，truncate 重置auto_increment的值。而delete不会\n3，truncate 不知道删除了几条，而delete知道。\n4，当被用于带分区的表时，truncate 会保留分区\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"备份与还原\"> 备份与还原</h3>\n<div><pre><code>/* 备份与还原 */ ------------------\n备份，将数据的结构与表内数据保存起来。\n利用 mysqldump 指令完成。\n-- 导出\nmysqldump [options] db_name [tables]\nmysqldump [options] ---database DB1 [DB2 DB3...]\nmysqldump [options] --all--database\n1. 导出一张表\n　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)\n2. 导出多张表\n　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)\n3. 导出所有表\n　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)\n4. 导出一个库\n　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)\n可以-w携带WHERE条件\n-- 导入\n1. 在登录mysql的情况下：\n　　source  备份文件\n2. 在不登录的情况下\n　　mysql -u用户名 -p密码 库名 &lt; 备份文件\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"视图\"> 视图</h3>\n<div><pre><code>什么是视图：\n    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。\n    视图具有表结构文件，但不存在数据文件。\n    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。\n    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。\n-- 创建视图\nCREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement\n    - 视图名必须唯一，同时不能与表重名。\n    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。\n    - 可以指定视图执行的算法，通过ALGORITHM指定。\n    - column_list如果存在，则数目必须等于SELECT语句检索的列数\n-- 查看结构\n    SHOW CREATE VIEW view_name\n-- 删除视图\n    - 删除视图后，数据依然存在。\n    - 可同时删除多个视图。\n    DROP VIEW [IF EXISTS] view_name ...\n-- 修改视图结构\n    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。\n    ALTER VIEW view_name [(column_list)] AS select_statement\n-- 视图作用\n    1. 简化业务逻辑\n    2. 对客户端隐藏真实的表结构\n-- 视图算法(ALGORITHM)\n    MERGE       合并\n        将视图的查询语句，与外部查询需要先合并再执行！\n    TEMPTABLE   临时表\n        将视图执行完毕后，形成临时表，再做外层查询！\n    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"事务-transaction\"> 事务(transaction)</h3>\n<div><pre><code>事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。\n    - 支持连续SQL的集体成功或集体撤销。\n    - 事务是数据库在数据完整性方面的一个功能。\n    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。\n    - InnoDB被称为事务安全型引擎。\n-- 事务开启\n    START TRANSACTION; 或者 BEGIN;\n    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。\n-- 事务提交\n    COMMIT;\n-- 事务回滚\n    ROLLBACK;\n    如果部分操作发生问题，映射到事务开启前。\n-- 事务的特性\n    1. 原子性（Atomicity）\n        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。\n    2. 一致性（Consistency）\n        事务前后数据的完整性必须保持一致。\n        - 事务开始和结束时，外部数据一致\n        - 在整个事务过程中，操作是连续的\n    3. 隔离性（Isolation）\n        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间的数据要相互隔离。\n    4. 持久性（Durability）\n        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。\n-- 事务的实现\n    1. 要求是事务支持的表类型\n    2. 执行一组相关的操作前开启事务\n    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。\n-- 事务的原理\n    利用InnoDB的自动提交(autocommit)特性完成。\n    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。\n    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。\n-- 注意\n    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。\n    2. 事务不能被嵌套\n-- 保存点\n    SAVEPOINT 保存点名称 -- 设置一个事务保存点\n    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点\n    RELEASE SAVEPOINT 保存点名称 -- 删除保存点\n-- InnoDB自动提交特性设置\n    SET autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。\n    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。\n    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，\n        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)\n        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h3 id=\"锁表\"> 锁表</h3>\n<div><pre><code>/* 锁表 */\n表锁定只用于防止其它客户端进行不正当地读取和写入\nMyISAM 支持表锁，InnoDB 支持行锁\n-- 锁定\n    LOCK TABLES tbl_name [AS alias]\n-- 解锁\n    UNLOCK TABLES\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"触发器\"> 触发器</h3>\n<div><pre><code>/* 触发器 */ ------------------\n    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象\n    监听：记录的增加、修改、删除。\n-- 创建触发器\nCREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt\n    参数：\n    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。\n    trigger_event指明了激活触发程序的语句的类型\n        INSERT：将新行插入表时激活触发程序\n        UPDATE：更改某一行时激活触发程序\n        DELETE：从表中删除某一行时激活触发程序\n    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。\n    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构\n-- 删除\nDROP TRIGGER [schema_name.]trigger_name\n可以使用old和new代替旧的和新的数据\n    更新操作，更新前是old，更新后是new.\n    删除操作，只有old.\n    增加操作，只有new.\n-- 注意\n    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。\n-- 字符连接函数\nconcat(str1,str2,...])\nconcat_ws(separator,str1,str2,...)\n-- 分支语句\nif 条件 then\n    执行语句\nelseif 条件 then\n    执行语句\nelse\n    执行语句\nend if;\n-- 修改最外层语句结束符\ndelimiter 自定义结束符号\n    SQL语句\n自定义结束符号\ndelimiter ;     -- 修改回原来的分号\n-- 语句块包裹\nbegin\n    语句块\nend\n-- 特殊的执行\n1. 只要添加记录，就会触发程序。\n2. Insert into on duplicate key update 语法会触发：\n    如果没有重复记录，会触发 before insert, after insert;\n    如果有重复记录并更新，会触发 before insert, before update, after update;\n    如果有重复记录但是没有发生更新，则触发 before insert, before update\n3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><h3 id=\"sql编程\"> SQL编程</h3>\n<div><pre><code>/* SQL编程 */ ------------------\n--// 局部变量 ----------\n-- 变量声明\n    declare var_name[,...] type [default value]\n    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。\n-- 赋值\n    使用 set 和 select into 语句为变量赋值。\n    - 注意：在函数内是可以使用全局变量（用户自定义的变量）\n--// 全局变量 ----------\n-- 定义、赋值\nset 语句可以定义并为变量赋值。\nset @var = value;\n也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。\n还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。\nselect @var:=20;\nselect @v1:=id, @v2=name from t1 limit 1;\nselect * from tbl_name where @var:=30;\nselect into 可以将表中查询获得的数据赋给变量。\n    -| select max(height) into @max_height from tb;\n-- 自定义变量名\n为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。\n@var=10;\n    - 变量被定义后，在整个会话周期都有效（登录到退出）\n--// 控制结构 ----------\n-- if语句\nif search_condition then\n    statement_list   \n[elseif search_condition then\n    statement_list]\n...\n[else\n    statement_list]\nend if;\n-- case语句\nCASE value WHEN [compare-value] THEN result\n[WHEN [compare-value] THEN result ...]\n[ELSE result]\nEND\n-- while循环\n[begin_label:] while search_condition do\n    statement_list\nend while [end_label];\n- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。\n    -- 退出循环\n        退出整个循环 leave\n        退出当前循环 iterate\n        通过退出的标签决定退出哪个循环\n--// 内置函数 ----------\n-- 数值函数\nabs(x)          -- 绝对值 abs(-10.9) = 10\nformat(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46\nceil(x)         -- 向上取整 ceil(10.1) = 11\nfloor(x)        -- 向下取整 floor (10.1) = 10\nround(x)        -- 四舍五入去整\nmod(m, n)       -- m%n m mod n 求余 10%3=1\npi()            -- 获得圆周率\npow(m, n)       -- m^n\nsqrt(x)         -- 算术平方根\nrand()          -- 随机数\ntruncate(x, d)  -- 截取d位小数\n-- 时间日期函数\nnow(), current_timestamp();     -- 当前日期时间\ncurrent_date();                 -- 当前日期\ncurrent_time();                 -- 当前时间\ndate(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取日期部分\ntime(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取时间部分\ndate_format(&#39;yyyy-mm-dd hh:ii:ss&#39;, &#39;%d %y %a %d %m %b %j&#39;); -- 格式化时间\nunix_timestamp();               -- 获得unix时间戳\nfrom_unixtime();                -- 从时间戳获得时间\n-- 字符串函数\nlength(string)          -- string长度，字节\nchar_length(string)     -- string的字符个数\nsubstring(str, position [,length])      -- 从str的position开始,取length个字符\nreplace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str\ninstr(string ,substring)    -- 返回substring首次在string中出现的位置\nconcat(string [,...])   -- 连接字串\ncharset(str)            -- 返回字串字符集\nlcase(string)           -- 转换成小写\nleft(string, length)    -- 从string2中的左边起取length个字符\nload_file(file_name)    -- 从文件读取内容\nlocate(substring, string [,start_position]) -- 同instr,但可指定开始位置\nlpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length\nltrim(string)           -- 去除前端空格\nrepeat(string, count)   -- 重复count次\nrpad(string, length, pad)   --在str后用pad补充,直到长度为length\nrtrim(string)           -- 去除后端空格\nstrcmp(string1 ,string2)    -- 逐字符比较两字串大小\n-- 流程函数\ncase when [condition] then result [when [condition] then result ...] [else result] end   多分支\nif(expr1,expr2,expr3)  双分支。\n-- 聚合函数\ncount()\nsum();\nmax();\nmin();\navg();\ngroup_concat()\n-- 其他常用函数\nmd5();\ndefault();\n--// 存储函数，自定义函数 ----------\n-- 新建\n    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型\n        函数体\n    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。\n    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。\n    - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。\n    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。\n    - 多条语句应该使用 begin...end 语句块包含。\n    - 一定要有 return 返回值语句。\n-- 删除\n    DROP FUNCTION [IF EXISTS] function_name;\n-- 查看\n    SHOW FUNCTION STATUS LIKE &#39;partten&#39;\n    SHOW CREATE FUNCTION function_name;\n-- 修改\n    ALTER FUNCTION function_name 函数选项\n--// 存储过程，自定义功能 ----------\n-- 定义\n存储存储过程 是一段代码（过程），存储在数据库中的sql组成。\n一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。\n而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。\n-- 创建\nCREATE PROCEDURE sp_name (参数列表)\n    过程体\n参数列表：不同于函数的参数列表，需要指明参数类型\nIN，表示输入型\nOUT，表示输出型\nINOUT，表示混合型\n注意，没有返回值。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br></div></div><h3 id=\"存储过程\"> 存储过程</h3>\n<div><pre><code>/* 存储过程 */ ------------------\n存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。\n调用：CALL 过程名\n-- 注意\n- 没有返回值。\n- 只能单独调用，不可夹杂在其他语句中\n-- 参数\nIN|OUT|INOUT 参数名 数据类型\nIN      输入：在调用过程中，将数据输入到过程体内部的参数\nOUT     输出：在调用过程中，将过程体处理完的结果返回到客户端\nINOUT   输入输出：既可输入，也可输出\n-- 语法\nCREATE PROCEDURE 过程名 (参数列表)\nBEGIN\n    过程体\nEND\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"用户和权限管理\"> 用户和权限管理</h3>\n<div><pre><code>/* 用户和权限管理 */ ------------------\n-- root密码重置\n1. 停止MySQL服务\n2.  [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp;\n    [Windows] mysqld --skip-grant-tables\n3. use mysql;\n4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;;\n5. FLUSH PRIVILEGES;\n用户信息表：mysql.user\n-- 刷新权限\nFLUSH PRIVILEGES;\n-- 增加用户\nCREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)\n    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。\n    - 只能创建用户，不能赋予权限。\n    - 用户名，注意引号：如 &#39;user_name&#39;@&#39;192.168.1.1&#39;\n    - 密码也需引号，纯数字密码也要加引号\n    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD\n-- 重命名用户\nRENAME USER old_user TO new_user\n-- 设置密码\nSET PASSWORD = PASSWORD(&#39;密码&#39;)  -- 为当前用户设置密码\nSET PASSWORD FOR 用户名 = PASSWORD(&#39;密码&#39;) -- 为指定用户设置密码\n-- 删除用户\nDROP USER 用户名\n-- 分配权限/添加用户\nGRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#39;password&#39;]\n    - all privileges 表示所有权限\n    - *.* 表示所有库的所有表\n    - 库名.表名 表示某库下面的某表\n    GRANT ALL PRIVILEGES ON `pms`.* TO &#39;pms&#39;@&#39;%&#39; IDENTIFIED BY &#39;pms0817&#39;;\n-- 查看权限\nSHOW GRANTS FOR 用户名\n    -- 查看当前用户权限\n    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();\n-- 撤消权限\nREVOKE 权限列表 ON 表名 FROM 用户名\nREVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限\n-- 权限层级\n-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。\n全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user\n    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。\n数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host\n    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。\n表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv\n    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。\n列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv\n    当使用REVOKE时，您必须指定与被授权列相同的列。\n-- 权限列表\nALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限\nALTER   -- 允许使用ALTER TABLE\nALTER ROUTINE   -- 更改或取消已存储的子程序\nCREATE  -- 允许使用CREATE TABLE\nCREATE ROUTINE  -- 创建已存储的子程序\nCREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE\nCREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。\nCREATE VIEW     -- 允许使用CREATE VIEW\nDELETE  -- 允许使用DELETE\nDROP    -- 允许使用DROP TABLE\nEXECUTE     -- 允许用户运行已存储的子程序\nFILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE\nINDEX   -- 允许使用CREATE INDEX和DROP INDEX\nINSERT  -- 允许使用INSERT\nLOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES\nPROCESS     -- 允许使用SHOW FULL PROCESSLIST\nREFERENCES  -- 未被实施\nRELOAD  -- 允许使用FLUSH\nREPLICATION CLIENT  -- 允许用户询问从属服务器或主服务器的地址\nREPLICATION SLAVE   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）\nSELECT  -- 允许使用SELECT\nSHOW DATABASES  -- 显示所有数据库\nSHOW VIEW   -- 允许使用SHOW CREATE VIEW\nSHUTDOWN    -- 允许使用mysqladmin shutdown\nSUPER   -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。\nUPDATE  -- 允许使用UPDATE\nUSAGE   -- “无权限”的同义词\nGRANT OPTION    -- 允许授予权限\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br></div></div><h3 id=\"表维护\"> 表维护</h3>\n<div><pre><code>/* 表维护 */\n-- 分析和存储表的关键字分布\nANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...\n-- 检查一个或多个表是否有错误\nCHECK TABLE tbl_name [, tbl_name] ... [option] ...\noption = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}\n-- 整理数据文件的碎片\nOPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"杂项\"> 杂项</h3>\n<div><pre><code>/* 杂项 */ ------------------\n1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！\n2. 每个库目录存在一个保存当前数据库的选项文件db.opt。\n3. 注释：\n    单行注释 # 注释内容\n    多行注释 /* 注释内容 */\n    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)\n4. 模式通配符：\n    _   任意单个字符\n    %   任意多个字符，甚至包括零字符\n    单引号需要进行转义 \\&#39;\n5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\\G&quot;, &quot;\\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。\n6. SQL对大小写不敏感\n7. 清除已有语句：\\c\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL 高性能优化规范建议",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/mysql-high-performance-optimization-specification-recommendations/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/mysql-high-performance-optimization-specification-recommendations/",
      "content_html": "<blockquote>\n<p>作者: 听风，原文地址: <a href=\"https://www.cnblogs.com/huchong/p/10219318.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/huchong/p/10219318.html</a>。JavaGuide 已获得作者授权。</p>\n</blockquote>\n<h2 id=\"数据库命令规范\"> 数据库命令规范</h2>\n<ul>\n<li>所有数据库对象名称必须使用小写字母并用下划线分割</li>\n<li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li>\n<li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li>\n<li>临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀</li>\n<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li>\n</ul>\n<hr>\n<h2 id=\"数据库基本设计规范\"> 数据库基本设计规范</h2>\n<h3 id=\"_1-所有表必须使用-innodb-存储引擎\"> 1. 所有表必须使用 Innodb 存储引擎</h3>\n<p>没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。</p>\n<p>Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p>\n<h3 id=\"_2-数据库和表的字符集统一使用-utf8\"> 2. 数据库和表的字符集统一使用 UTF8</h3>\n<p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p>\n<p>参考文章：<a href=\"https://blog.csdn.net/horses/article/details/107243447\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL 字符集不一致导致索引失效的一个真实案例</a></p>\n<h3 id=\"_3-所有表和字段都需要添加注释\"> 3. 所有表和字段都需要添加注释</h3>\n<p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p>\n<h3 id=\"_4-尽量控制单表数据量的大小-建议控制在-500-万以内。\"> 4. 尽量控制单表数据量的大小,建议控制在 500 万以内。</h3>\n<p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p>\n<p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>\n<h3 id=\"_5-谨慎使用-mysql-分区表\"> 5. 谨慎使用 MySQL 分区表</h3>\n<p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p>\n<p>谨慎选择分区键，跨分区查询效率可能更低；</p>\n<p>建议采用物理分表的方式管理大数据。</p>\n<h3 id=\"_6-尽量做到冷热数据分离-减小表的宽度\"> 6.尽量做到冷热数据分离,减小表的宽度</h3>\n<blockquote>\n<p>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。</p>\n</blockquote>\n<p>减少磁盘 IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）；</p>\n<p>更有效的利用缓存，避免读入无用的冷数据；</p>\n<p>经常一起使用的列放到一个表中（避免更多的关联操作）。</p>\n<h3 id=\"_7-禁止在表中建立预留字段\"> 7. 禁止在表中建立预留字段</h3>\n<p>预留字段的命名很难做到见名识义。</p>\n<p>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</p>\n<p>对预留字段类型的修改，会对表进行锁定。</p>\n<h3 id=\"_8-禁止在数据库中存储图片-文件等大的二进制数据\"> 8. 禁止在数据库中存储图片,文件等大的二进制数据</h3>\n<p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。</p>\n<p>通常存储于文件服务器，数据库只存储文件地址信息</p>\n<h3 id=\"_9-禁止在线上做数据库压力测试\"> 9. 禁止在线上做数据库压力测试</h3>\n<h3 id=\"_10-禁止从开发环境-测试环境直接连接生产环境数据库\"> 10. 禁止从开发环境,测试环境直接连接生产环境数据库</h3>\n<hr>\n<h2 id=\"数据库字段设计规范\"> 数据库字段设计规范</h2>\n<h3 id=\"_1-优先选择符合存储需要的最小的数据类型\"> 1. 优先选择符合存储需要的最小的数据类型</h3>\n<p><strong>原因：</strong></p>\n<p>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。</p>\n<p><strong>方法：</strong></p>\n<p><strong>a.将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</strong></p>\n<p>MySQL 提供了两个方法来处理 ip 地址</p>\n<ul>\n<li>inet_aton 把 ip 转为无符号整型 (4-8 位)</li>\n<li>inet_ntoa 把整型的 ip 转为地址</li>\n</ul>\n<p>插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间，显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。</p>\n<p><strong>b.对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储</strong></p>\n<p><strong>原因：</strong></p>\n<p>无符号相对于有符号可以多出一倍的存储空间</p>\n<div><pre><code>SIGNED INT -2147483648~2147483647\nUNSIGNED INT 0~4294967295\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>VARCHAR(N) 中的 N 代表的是字符数，而不是字节数，使用 UTF8 存储 255 个汉字 Varchar(255)=765 个字节。<strong>过大的长度会消耗更多的内存。</strong></p>\n<h3 id=\"_2-避免使用-text-blob-数据类型-最常见的-text-类型可以存储-64k-的数据\"> 2. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h3>\n<p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</strong></p>\n<p>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p>\n<p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select * 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p>\n<p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p>\n<p>因为<a href=\"https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247487885&amp;idx=1&amp;sn=65b1bf5f7d4505502620179669a9c2df&amp;chksm=ebd62ea1dca1a7b7bf884bcd9d538d78ba064ee03c09436ca8e57873b1d98a55afd6d7884cfc&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL</a> 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p>\n<h3 id=\"_3-避免使用-enum-类型\"> 3. 避免使用 ENUM 类型</h3>\n<p>修改 ENUM 值需要使用 ALTER 语句</p>\n<p>ENUM 类型的 ORDER BY 操作效率低，需要额外操作</p>\n<p>禁止使用数值作为 ENUM 的枚举值</p>\n<h3 id=\"_4-尽可能把所有列定义为-not-null\"> 4. 尽可能把所有列定义为 NOT NULL</h3>\n<p><strong>原因：</strong></p>\n<p>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间</p>\n<p>进行比较和计算时要对 NULL 值做特别的处理</p>\n<h3 id=\"_5-使用-timestamp-4-个字节-或-datetime-类型-8-个字节-存储时间\"> 5. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</h3>\n<p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p>\n<p>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高</p>\n<p>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p>\n<p><strong>经常会有人用字符串存储日期型的数据（不正确的做法）</strong></p>\n<ul>\n<li>缺点 1：无法用日期函数进行计算和比较</li>\n<li>缺点 2：用字符串存储日期要占用更多的空间</li>\n</ul>\n<h3 id=\"_6-同财务相关的金额类数据必须使用-decimal-类型\"> 6. 同财务相关的金额类数据必须使用 decimal 类型</h3>\n<ul>\n<li>非精准浮点：float,double</li>\n<li>精准浮点：decimal</li>\n</ul>\n<p>Decimal 类型为精准浮点数，在计算时不会丢失精度</p>\n<p>占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节</p>\n<p>可用于存储比 bigint 更大的整型数据</p>\n<hr>\n<h2 id=\"索引设计规范\"> 索引设计规范</h2>\n<h3 id=\"_1-限制每张表上的索引数量-建议单张表索引不超过-5-个\"> 1. 限制每张表上的索引数量,建议单张表索引不超过 5 个</h3>\n<p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p>\n<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>\n<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>\n<h3 id=\"_2-禁止给表中的每一列都建立单独的索引\"> 2. 禁止给表中的每一列都建立单独的索引</h3>\n<p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p>\n<h3 id=\"_3-每个-innodb-表必须有个主键\"> 3. 每个 Innodb 表必须有个主键</h3>\n<p>Innodb 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p>\n<p>Innodb 是按照主键索引的顺序来组织表的</p>\n<ul>\n<li>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</li>\n<li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li>\n<li>主键建议使用自增 ID 值</li>\n</ul>\n<hr>\n<h3 id=\"_4-常见索引列建议\"> 4. 常见索引列建议</h3>\n<ul>\n<li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li>\n<li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li>\n<li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li>\n<li>多表 join 的关联列</li>\n</ul>\n<hr>\n<h3 id=\"_5-如何选择索引列的顺序\"> 5.如何选择索引列的顺序</h3>\n<p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>\n<ul>\n<li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li>\n<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li>\n<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li>\n</ul>\n<hr>\n<h3 id=\"_6-避免建立冗余索引和重复索引-增加了查询优化器生成执行计划的时间\"> 6. 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h3>\n<ul>\n<li>重复索引示例：primary key(id)、index(id)、unique index(id)</li>\n<li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li>\n</ul>\n<hr>\n<h3 id=\"_7-对于频繁的查询优先考虑使用覆盖索引\"> 7. 对于频繁的查询优先考虑使用覆盖索引</h3>\n<blockquote>\n<p>覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引</p>\n</blockquote>\n<p><strong>覆盖索引的好处：</strong></p>\n<ul>\n<li><strong>避免 Innodb 表进行索引的二次查询:</strong> Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li>\n<li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li>\n</ul>\n<hr>\n<h3 id=\"_8-索引-set-规范\"> 8.索引 SET 规范</h3>\n<p><strong>尽量避免使用外键约束</strong></p>\n<ul>\n<li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li>\n<li>外键可用于保证数据的参照完整性，但建议在业务端实现</li>\n<li>外键会影响父表和子表的写操作从而降低性能</li>\n</ul>\n<hr>\n<h2 id=\"数据库-sql-开发规范\"> 数据库 SQL 开发规范</h2>\n<h3 id=\"_1-建议使用预编译语句进行数据库操作\"> 1. 建议使用预编译语句进行数据库操作</h3>\n<p>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</p>\n<p>只传参数，比传递 SQL 语句更高效。</p>\n<p>相同语句可以一次解析，多次使用，提高处理效率。</p>\n<h3 id=\"_2-避免数据类型的隐式转换\"> 2. 避免数据类型的隐式转换</h3>\n<p>隐式转换会导致索引失效如:</p>\n<div><pre><code>select name,phone from customer where id = &#39;111&#39;;\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_3-充分利用表上已经存在的索引\"> 3. 充分利用表上已经存在的索引</h3>\n<p>避免使用双%号的查询条件。如：<code>a like '%123%'</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</p>\n<p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p>\n<p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p>\n<h3 id=\"_4-数据库设计时-应该要对以后扩展进行考虑\"> 4. 数据库设计时，应该要对以后扩展进行考虑</h3>\n<h3 id=\"_5-程序连接不同的数据库使用不同的账号-禁止跨库查询\"> 5. 程序连接不同的数据库使用不同的账号，禁止跨库查询</h3>\n<ul>\n<li>为数据库迁移和分库分表留出余地</li>\n<li>降低业务耦合度</li>\n<li>避免权限过大而产生的安全风险</li>\n</ul>\n<h3 id=\"_6-禁止使用-select-必须使用-select-字段列表-查询\"> 6. 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h3>\n<p><strong>原因：</strong></p>\n<ul>\n<li>消耗更多的 CPU 和 IO 以网络带宽资源</li>\n<li>无法使用覆盖索引</li>\n<li>可减少表结构变更带来的影响</li>\n</ul>\n<h3 id=\"_7-禁止使用不含字段列表的-insert-语句\"> 7. 禁止使用不含字段列表的 INSERT 语句</h3>\n<p>如：</p>\n<div><pre><code>insert into values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);\n</code></pre>\n<div><span>1</span><br></div></div><p>应使用：</p>\n<div><pre><code>insert into t(c1,c2,c3) values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_8-避免使用子查询-可以把子查询优化为-join-操作\"> 8. 避免使用子查询，可以把子查询优化为 join 操作</h3>\n<p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p>\n<p><strong>子查询性能差的原因：</strong></p>\n<p>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>\n<p>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p>\n<h3 id=\"_9-避免使用-join-关联太多的表\"> 9. 避免使用 JOIN 关联太多的表</h3>\n<p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p>\n<p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p>\n<p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p>\n<p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p>\n<h3 id=\"_10-减少同数据库的交互次数\"> 10. 减少同数据库的交互次数</h3>\n<p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p>\n<h3 id=\"_11-对应同一列进行-or-判断时-使用-in-代替-or\"> 11. 对应同一列进行 or 判断时，使用 in 代替 or</h3>\n<p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p>\n<h3 id=\"_12-禁止使用-order-by-rand-进行随机排序\"> 12. 禁止使用 order by rand() 进行随机排序</h3>\n<p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p>\n<p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p>\n<h3 id=\"_13-where-从句中禁止对列进行函数转换和计算\"> 13. WHERE 从句中禁止对列进行函数转换和计算</h3>\n<p>对列进行函数转换或计算时会导致无法使用索引</p>\n<p><strong>不推荐：</strong></p>\n<div><pre><code>where date(create_time)=&#39;20190101&#39;\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>推荐：</strong></p>\n<div><pre><code>where create_time &gt;= &#39;20190101&#39; and create_time &lt; &#39;20190102&#39;\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_14-在明显不会有重复值时使用-union-all-而不是-union\"> 14. 在明显不会有重复值时使用 UNION ALL 而不是 UNION</h3>\n<ul>\n<li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li>\n<li>UNION ALL 不会再对结果集进行去重操作</li>\n</ul>\n<h3 id=\"_15-拆分复杂的大-sql-为多个小-sql\"> 15. 拆分复杂的大 SQL 为多个小 SQL</h3>\n<ul>\n<li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li>\n<li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li>\n<li>SQL 拆分后可以通过并行执行来提高处理效率</li>\n</ul>\n<hr>\n<h2 id=\"数据库操作行为规范\"> 数据库操作行为规范</h2>\n<h3 id=\"_1-超-100-万行的批量写-update-delete-insert-操作-要分批多次进行操作\"> 1. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h3>\n<p><strong>大批量操作可能会造成严重的主从延迟</strong></p>\n<p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，\n而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>\n<p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p>\n<p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>\n<p><strong>避免产生大事务操作</strong></p>\n<p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p>\n<p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p>\n<h3 id=\"_2-对于大表使用-pt-online-schema-change-修改表结构\"> 2. 对于大表使用 pt-online-schema-change 修改表结构</h3>\n<ul>\n<li>避免大表修改产生的主从延迟</li>\n<li>避免在对表字段进行修改时进行锁表</li>\n</ul>\n<p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p>\n<p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p>\n<h3 id=\"_3-禁止为程序使用的账号赋予-super-权限\"> 3. 禁止为程序使用的账号赋予 super 权限</h3>\n<ul>\n<li>当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li>\n<li>super 权限只能留给 DBA 处理问题的账号使用</li>\n</ul>\n<h3 id=\"_4-对于程序连接数据库账号-遵循权限最小原则\"> 4. 对于程序连接数据库账号,遵循权限最小原则</h3>\n<ul>\n<li>程序使用数据库账号只能在一个 DB 下使用，不准跨库</li>\n<li>程序使用的账号原则上不准有 drop 权限</li>\n</ul>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "InnoDB存储引擎对MVCC的实现",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/innodb-implementation-of-mvcc/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/innodb-implementation-of-mvcc/",
      "content_html": "<h2 id=\"一致性非锁定读和锁定读\"> 一致性非锁定读和锁定读</h2>\n<h3 id=\"一致性非锁定读\"> 一致性非锁定读</h3>\n<p>对于 <a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>一致性非锁定读（Consistent Nonlocking Reads）</strong> </a>的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见</p>\n<p>在 <code>InnoDB</code> 存储引擎中，<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html\" target=\"_blank\" rel=\"noopener noreferrer\">多版本控制 (multi versioning)</a> 就是对非锁定读的实现。如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，这时读取操作不会去等待行上锁的释放。相反地，<code>InnoDB</code> 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)</p>\n<p>在 <code>Repeatable Read</code> 和 <code>Read Committed</code> 两个隔离级别下，如果是执行普通的 <code>select</code> 语句（不包括 <code>select ... lock in share mode</code> ,<code>select ... for update</code>）则会使用 <code>一致性非锁定读（MVCC）</code>。并且在 <code>Repeatable Read</code> 下 <code>MVCC</code> 实现了可重复读和防止部分幻读</p>\n<h3 id=\"锁定读\"> 锁定读</h3>\n<p>如果执行的是下列语句，就是 <a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>锁定读（Locking Reads）</strong></a></p>\n<ul>\n<li><code>select ... lock in share mode</code></li>\n<li><code>select ... for update</code></li>\n<li><code>insert</code>、<code>update</code>、<code>delete</code> 操作</li>\n</ul>\n<p>在锁定读下，读取的是数据的最新版本，这种读也被称为 <code>当前读（current read）</code>。锁定读会对读取到的记录加锁：</p>\n<ul>\n<li>\n<p><code>select ... lock in share mode</code>：对记录加 <code>S</code> 锁，其它事务也可以加<code>S</code>锁，如果加 <code>x</code> 锁则会被阻塞</p>\n</li>\n<li>\n<p><code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</p>\n</li>\n</ul>\n<p>在一致性非锁定读下，即使读取的记录已被其它事务加上 <code>X</code> 锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在 <code>Repeatable Read</code> 下 <code>MVCC</code> 防止了部分幻读，这边的 “部分” 是指在 <code>一致性非锁定读</code> 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是！如果是 <code>当前读</code> ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， <strong><code>InnoDB</code> 在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据</strong></p>\n<h2 id=\"innodb-对-mvcc-的实现\"> InnoDB 对 MVCC 的实现</h2>\n<p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>\n<h3 id=\"隐藏字段\"> 隐藏字段</h3>\n<p>在内部，<code>InnoDB</code> 存储引擎为每行数据添加了三个 <a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html\" target=\"_blank\" rel=\"noopener noreferrer\">隐藏字段</a>：</p>\n<ul>\n<li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除</li>\n<li><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</li>\n<li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</li>\n</ul>\n<h3 id=\"readview\"> ReadView</h3>\n<div><pre><code>class ReadView <span>{</span>\n  <span>/* ... */</span>\nprivate<span>:</span>\n  <span>trx_id_t</span> m_low_limit_id<span>;</span>      <span>/* 大于等于这个 ID 的事务均不可见 */</span>\n\n  <span>trx_id_t</span> m_up_limit_id<span>;</span>       <span>/* 小于这个 ID 的事务均可见 */</span>\n\n  <span>trx_id_t</span> m_creator_trx_id<span>;</span>    <span>/* 创建该 Read View 的事务ID */</span>\n\n  <span>trx_id_t</span> m_low_limit_no<span>;</span>      <span>/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span>\n\n  <span>ids_t</span> m_ids<span>;</span>                  <span>/* 创建 Read View 时的活跃事务列表 */</span>\n\n  m_closed<span>;</span>                     <span>/* 标记 Read View 是否 close */</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><a href=\"https://github.com/facebook/mysql-8.0/blob/8.0/storage/innobase/include/read0types.h#L298\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Read View</code></a> 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”</p>\n<p>主要有以下字段：</p>\n<ul>\n<li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li>\n<li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li>\n<li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li>\n<li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li>\n</ul>\n<p><strong>事务可见性示意图</strong>（<a href=\"https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/#MVCC-1\" target=\"_blank\" rel=\"noopener noreferrer\">图源</a>）：</p>\n<p><img src=\"https://leviathan.vip/2019/03/20/InnoDB的事务分析-MVCC/trans_visible.jpg\" alt=\"trans_visible\" /></p>\n<h3 id=\"undo-log\"> undo-log</h3>\n<p><code>undo log</code> 主要有两个作用：</p>\n<ul>\n<li>当事务回滚时用于将数据恢复到修改前的样子</li>\n<li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li>\n</ul>\n<p><strong>在 <code>InnoDB</code> 存储引擎中 <code>undo log</code> 分为两种： <code>insert undo log</code> 和 <code>update undo log</code>：</strong></p>\n<ol>\n<li><strong><code>insert undo log</code></strong> ：指在 <code>insert</code> 操作中产生的 <code>undo log</code>。因为 <code>insert</code> 操作的记录只对事务本身可见，对其他事务不可见，故该 <code>undo log</code> 可以在事务提交后直接删除。不需要进行 <code>purge</code> 操作</li>\n</ol>\n<p><strong><code>insert</code> 时的数据初始状态：</strong></p>\n<p><img src=\"https://ddmcc-1255635056.file.myqcloud.com/317e91e1-1ee1-42ad-9412-9098d5c6a9ad.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li><strong><code>update undo log</code></strong> ：<code>update</code> 或 <code>delete</code> 操作中产生的 <code>undo log</code>。该 <code>undo log</code>可能需要提供 <code>MVCC</code> 机制，因此不能在事务提交时就进行删除。提交时放入 <code>undo log</code> 链表，等待 <code>purge线程</code> 进行最后的删除</li>\n</ol>\n<p><strong>数据第一次被修改时：</strong></p>\n<p><img src=\"https://ddmcc-1255635056.file.myqcloud.com/c52ff79f-10e6-46cb-b5d4-3c9cbcc1934a.png\" alt=\"\" /></p>\n<p><strong>数据第二次被修改时：</strong></p>\n<p><img src=\"https://ddmcc-1255635056.file.myqcloud.com/6a276e7a-b0da-4c7b-bdf7-c0c7b7b3b31c.png\" alt=\"\" /></p>\n<p>不同事务或者相同事务的对同一记录行的修改，会使该记录行的 <code>undo log</code> 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录。</p>\n<h3 id=\"数据可见性算法\"> 数据可见性算法</h3>\n<p>在 <code>InnoDB</code> 存储引擎中，创建一个新事务后，执行每个 <code>select</code> 语句前，都会创建一个快照（Read View），<strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>。其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code> 会将该记录行的 <code>DB_TRX_ID</code> 与 <code>Read View</code> 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件</p>\n<p><a href=\"https://github.com/facebook/mysql-8.0/blob/8.0/storage/innobase/include/read0types.h#L161\" target=\"_blank\" rel=\"noopener noreferrer\">具体的比较算法</a>如下：<a href=\"https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/#MVCC-1\" target=\"_blank\" rel=\"noopener noreferrer\">图源</a></p>\n<p><img src=\"https://ddmcc-1255635056.file.myqcloud.com/8778836b-34a8-480b-b8c7-654fe207a8c2.png\" alt=\"\" /></p>\n<ol>\n<li>\n<p>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</p>\n</li>\n<li>\n<p>如果 DB_TRX_ID &gt;= m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</p>\n</li>\n<li>\n<p>m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</p>\n</li>\n<li>\n<p>如果 m_up_limit_id &lt;= DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的二分查找，因为是有序的）</p>\n<ul>\n<li>\n<p>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5</p>\n</li>\n<li>\n<p>在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见</p>\n</li>\n</ul>\n</li>\n<li>\n<p>在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code> 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空</p>\n</li>\n</ol>\n<h2 id=\"rc-和-rr-隔离级别下-mvcc-的差异\"> RC 和 RR 隔离级别下 MVCC 的差异</h2>\n<p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p>\n<ul>\n<li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li>\n<li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表）</li>\n</ul>\n<h2 id=\"mvcc-解决不可重复读问题\"> MVCC 解决不可重复读问题</h2>\n<p>虽然 RC 和 RR 都通过 <code>MVCC</code> 来读取快照数据，但由于 <strong>生成 Read View 时机不同</strong>，从而在 RR 级别下实现可重复读</p>\n<p>举个例子：</p>\n<p><img src=\"https://ddmcc-1255635056.file.myqcloud.com/6fb2b9a1-5f14-4dec-a797-e4cf388ed413.png\" alt=\"\" /></p>\n<h3 id=\"在-rc-下-readview-生成情况\"> 在 RC 下 ReadView 生成情况</h3>\n<ol>\n<li>\n<p><strong><code>假设时间线来到 T4 ，那么此时数据行 id = 1 的版本链为</code>：</strong></p>\n<p><img src=\"https://ddmcc-1255635056.file.myqcloud.com/a3fd1ec6-8f37-42fa-b090-7446d488fd04.png\" alt=\"\" /></p>\n</li>\n</ol>\n<p>由于 RC 级别下每次查询都会生成<code>Read View</code> ，并且事务 101、102 并未提交，此时 <code>103</code> 事务生成的 <code>Read View</code> 中活跃的事务 <strong><code>m_ids</code> 为：[101,102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code> 为：103</p>\n<ul>\n<li>此时最新记录的 <code>DB_TRX_ID</code> 为 101，m_up_limit_id &lt;= 101 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</li>\n<li>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是 101，不可见</li>\n<li>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 <code>name = 菜花</code></li>\n</ul>\n<ol start=\"2\">\n<li>\n<p><strong><code>时间线来到 T6 ，数据的版本链为</code>：</strong></p>\n<p><img src=\"https://ddmcc-1255635056.file.myqcloud.com/528559e9-dae8-4d14-b78d-a5b657c88391.png\" alt=\"markdown\" /></p>\n</li>\n</ol>\n<p>因为在 RC 级别下，重新生成 <code>Read View</code>，这时事务 101 已经提交，102 并未提交，所以此时 <code>Read View</code> 中活跃的事务 <strong><code>m_ids</code>：[102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：102，<code>m_creator_trx_id</code>为：103</p>\n<ul>\n<li>\n<p>此时最新记录的 <code>DB_TRX_ID</code> 为 102，m_up_limit_id &lt;= 102 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</p>\n</li>\n<li>\n<p>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 为 101，满足 101 &lt; m_up_limit_id，记录可见，所以在 <code>T6</code> 时间点查询到数据为 <code>name = 李四</code>，与时间 T4 查询到的结果不一致，不可重复读！</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong><code>时间线来到 T9 ，数据的版本链为</code>：</strong></li>\n</ol>\n<p><img src=\"https://ddmcc-1255635056.file.myqcloud.com/6f82703c-36a1-4458-90fe-d7f4edbac71a.png\" alt=\"markdown\" /></p>\n<p>重新生成 <code>Read View</code>， 这时事务 101 和 102 都已经提交，所以 <strong>m_ids</strong> 为空，则 m_up_limit_id = m_low_limit_id = 104，最新版本事务 ID 为 102，满足 102 &lt; m_low_limit_id，可见，查询结果为 <code>name = 赵六</code></p>\n<blockquote>\n<p><strong>总结：</strong> <strong>在 RC 隔离级别下，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读</strong></p>\n</blockquote>\n<h3 id=\"在-rr-下-readview-生成情况\"> 在 RR 下 ReadView 生成情况</h3>\n<p><strong>在可重复读级别下，只会在事务开始后第一次读取数据时生成一个 Read View（m_ids 列表）</strong></p>\n<ol>\n<li><strong><code>在 T4 情况下的版本链为</code>：</strong></li>\n</ol>\n<p><img src=\"https://ddmcc-1255635056.file.myqcloud.com/0e906b95-c916-4f30-beda-9cb3e49746bf.png\" alt=\"markdown\" /></p>\n<p>在当前执行 <code>select</code> 语句时生成一个 <code>Read View</code>，此时 <strong><code>m_ids</code>：[101,102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code> 为：103</p>\n<p>此时和 RC 级别下一样：</p>\n<ul>\n<li>最新记录的 <code>DB_TRX_ID</code> 为 101，m_up_limit_id &lt;= 101 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</li>\n<li>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是 101，不可见</li>\n<li>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 <code>name = 菜花</code></li>\n</ul>\n<ol start=\"2\">\n<li>\n<p><strong><code>时间点 T6 情况下</code>：</strong></p>\n<p><img src=\"https://ddmcc-1255635056.file.myqcloud.com/79ed6142-7664-4e0b-9023-cf546586aa39.png\" alt=\"markdown\" /></p>\n<p>在 RR 级别下只会生成一次<code>Read View</code>，所以此时依然沿用 <strong><code>m_ids</code> ：[101,102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code> 为：103</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>最新记录的 <code>DB_TRX_ID</code> 为 102，m_up_limit_id &lt;= 102 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</p>\n</li>\n<li>\n<p>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 为 101，不可见</p>\n</li>\n<li>\n<p>继续根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是 101，不可见</p>\n</li>\n<li>\n<p>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 <code>name = 菜花</code></p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>时间点 T9 情况下：</strong></li>\n</ol>\n<p><img src=\"https://ddmcc-1255635056.file.myqcloud.com/cbbedbc5-0e3c-4711-aafd-7f3d68a4ed4e.png\" alt=\"markdown\" /></p>\n<p>此时情况跟 T6 完全一样，由于已经生成了 <code>Read View</code>，此时依然沿用 <strong><code>m_ids</code> ：[101,102]</strong> ，所以查询结果依然是 <code>name = 菜花</code></p>\n<h2 id=\"mvcc➕next-key-lock-防止幻读\"> MVCC➕Next-key-Lock 防止幻读</h2>\n<p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p>\n<p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p>\n<p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p>\n<p><strong>2、执行 select...for update/lock in share mode、insert、update、delete 等当前读</strong></p>\n<p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks\" target=\"_blank\" rel=\"noopener noreferrer\">Next-key Lock</a> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p>\n<h2 id=\"参考\"> 参考</h2>\n<ul>\n<li><strong>《MySQL 技术内幕 InnoDB 存储引擎第 2 版》</strong></li>\n<li><a href=\"https://tech.meituan.com/2014/08/20/innodb-lock.html\" target=\"_blank\" rel=\"noopener noreferrer\">Innodb 中的事务隔离级别和锁的关系</a></li>\n<li><a href=\"https://blog.csdn.net/qq_35190492/article/details/109044141\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL 事务与 MVCC 如何实现的隔离级别</a></li>\n<li><a href=\"https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/\" target=\"_blank\" rel=\"noopener noreferrer\">InnoDB 事务分析-MVCC</a></li>\n</ul>\n",
      "image": "https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/trans_visible.jpg",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL 索引详解",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/mysql-index/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/mysql-index/",
      "content_html": "<h2 id=\"何为索引-有什么作用\"> 何为索引？有什么作用？</h2>\n<p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p>\n<p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>\n<h2 id=\"索引的优缺点\"> 索引的优缺点</h2>\n<p><strong>优点</strong> ：</p>\n<ul>\n<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n</ul>\n<p><strong>缺点</strong> ：</p>\n<ul>\n<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p>\n<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>\n<h2 id=\"索引的底层数据结构\"> 索引的底层数据结构</h2>\n<h3 id=\"hash表-b-树\"> Hash表 &amp; B+树</h3>\n<p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p>\n<p><strong>为何能够通过 key 快速取出 value呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 value 对应的 index，找到了 index 也就找到了对应的 value。</p>\n<div><pre><code>hash <span>=</span> <span>hashfunc</span><span>(</span>key<span>)</span>\nindex <span>=</span> hash <span>%</span> array_size\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://img-blog.csdnimg.cn/20210513092328171.png\" alt=\"\" /></p>\n<p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的  key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210513092224836.png\" alt=\"\" /></p>\n<p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。</p>\n<p>既然哈希表这么快，<strong>为什么MySQL 没有使用其作为索引的数据结构呢？</strong></p>\n<p><strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</p>\n<p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p>\n<p>试想一种情况:</p>\n<div><pre><code>SELECT <span>*</span> FROM tb1 WHERE id <span>&lt;</span> <span>500</span><span>;</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。</p>\n<h3 id=\"b-树-b-树\"> B 树&amp; B+树</h3>\n<p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p>\n<p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p>\n<p><strong>B 树&amp; B+树两者有何异同呢？</strong></p>\n<ul>\n<li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>\n<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>\n<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20210420165409106.png\" alt=\"\" /></p>\n<p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p>\n<p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p>\n<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>\n<h2 id=\"索引类型\"> 索引类型</h2>\n<h3 id=\"主键索引-primary-key\"> 主键索引(Primary Key)</h3>\n<p>数据表的主键列使用的就是主键索引。</p>\n<p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>\n<p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p>\n<h3 id=\"二级索引-辅助索引\"> 二级索引(辅助索引)</h3>\n<p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>\n<p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p>\n<p><strong>PS:不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</strong></p>\n<ol>\n<li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>\n<li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li>\n<li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，\n因为只取前几个字符。</li>\n<li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>\n</ol>\n<p>二级索引:\n<img src=\"https://img-blog.csdnimg.cn/20210420165254215.png\" alt=\"\" /></p>\n<h2 id=\"聚集索引与非聚集索引\"> 聚集索引与非聚集索引</h2>\n<h3 id=\"聚集索引\"> 聚集索引</h3>\n<p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>\n<p>在 Mysql 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>\n<h4 id=\"聚集索引的优点\"> 聚集索引的优点</h4>\n<p>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>\n<h4 id=\"聚集索引的缺点\"> 聚集索引的缺点</h4>\n<ol>\n<li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>\n<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，\n而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，\n所以对于主键索引来说，主键一般都是不可被修改的。</li>\n</ol>\n<h3 id=\"非聚集索引\"> 非聚集索引</h3>\n<p><strong>非聚集索引即索引结构和数据分开存放的索引。</strong></p>\n<p><strong>二级索引属于非聚集索引。</strong></p>\n<blockquote>\n<p>MYISAM 引擎的表的.MYI 文件包含了表的索引，\n该表的索引(B+树)的每个叶子非叶子节点存储索引，\n叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。</p>\n<p><strong>非聚集索引的叶子节点并不一定存放数据的指针，\n因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p>\n</blockquote>\n<h4 id=\"非聚集索引的优点\"> 非聚集索引的优点</h4>\n<p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>\n<h4 id=\"非聚集索引的缺点\"> 非聚集索引的缺点</h4>\n<ol>\n<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>\n<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>\n</ol>\n<p>这是 MySQL 的表的文件截图:</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210420165311654.png\" alt=\"\" /></p>\n<p>聚集索引和非聚集索引:</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210420165326946.png\" alt=\"\" /></p>\n<h3 id=\"非聚集索引一定回表查询吗-覆盖索引\"> 非聚集索引一定回表查询吗(覆盖索引)?</h3>\n<p><strong>非聚集索引不一定回表查询。</strong></p>\n<blockquote>\n<p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p>\n</blockquote>\n<div><pre><code> SELECT name FROM table WHERE name=&#39;guang19&#39;;\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p>\n</blockquote>\n<p><strong>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，\n因为它的主键索引的叶子节点存放的是指针。但是如果 SQL 查的就是主键呢?</strong></p>\n<div><pre><code>SELECT id FROM table WHERE id=1;\n</code></pre>\n<div><span>1</span><br></div></div><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p>\n<h2 id=\"覆盖索引\"> 覆盖索引</h2>\n<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>\n<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，\n而无需回表查询。</strong></p>\n<blockquote>\n<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p>\n<p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，\n那么直接根据这个索引就可以查到数据，也无需回表。</p>\n</blockquote>\n<p>覆盖索引:\n<img src=\"https://img-blog.csdnimg.cn/20210420165341868.png\" alt=\"\" /></p>\n<h2 id=\"创建索引的注意事项\"> 创建索引的注意事项</h2>\n<p><strong>1.选择合适的字段创建索引：</strong></p>\n<ul>\n<li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>\n<li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li>\n<li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>\n<li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>\n<li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>\n</ul>\n<p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p>\n<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。\n如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>\n<p><strong>3.尽可能的考虑建立联合索引而不是单列索引。</strong></p>\n<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>\n<p><strong>4.注意避免冗余索引</strong> 。</p>\n<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>\n<p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p>\n<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>\n<h2 id=\"使用索引的一些建议\"> 使用索引的一些建议</h2>\n<ul>\n<li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li>\n<li>避免 where 子句中对字段施加函数，这会造成无法命中索引。</li>\n<li>在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li>\n<li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</li>\n<li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li>\n</ul>\n<h2 id=\"mysql-如何为表字段添加索引\"> MySQL 如何为表字段添加索引？</h2>\n<p>1.添加 PRIMARY KEY（主键索引）</p>\n<div><pre><code><span>ALTER</span> <span>TABLE</span> <span>`</span>table_name<span>`</span> <span>ADD</span> <span>PRIMARY</span> <span>KEY</span> <span>(</span> <span>`</span><span>column</span><span>`</span> <span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>2.添加 UNIQUE(唯一索引)</p>\n<div><pre><code>ALTER TABLE `table_name` ADD UNIQUE ( `column` )\n</code></pre>\n<div><span>1</span><br></div></div><p>3.添加 INDEX(普通索引)</p>\n<div><pre><code><span>ALTER</span> <span>TABLE</span> <span>`</span>table_name<span>`</span> <span>ADD</span> <span>INDEX</span> index_name <span>(</span> <span>`</span><span>column</span><span>`</span> <span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>4.添加 FULLTEXT(全文索引)</p>\n<div><pre><code><span>ALTER</span> <span>TABLE</span> <span>`</span>table_name<span>`</span> <span>ADD</span> FULLTEXT <span>(</span> <span>`</span><span>column</span><span>`</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>5.添加多列索引</p>\n<div><pre><code><span>ALTER</span> <span>TABLE</span> <span>`</span>table_name<span>`</span> <span>ADD</span> <span>INDEX</span> index_name <span>(</span> <span>`</span>column1<span>`</span><span>,</span> <span>`</span>column2<span>`</span><span>,</span> <span>`</span>column3<span>`</span> <span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div>",
      "image": "https://img-blog.csdnimg.cn/20210513092328171.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL三大日志(binlog、redo log和undo log)详解",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/mysql-logs/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/mysql-logs/",
      "content_html": "<blockquote>\n<p>本文来自公号程序猿阿星投稿，JavaGuide 对其做了补充完善。</p>\n</blockquote>\n<h2 id=\"前言\"> 前言</h2>\n<p><code>MySQL</code> 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/01.png\" alt=\"\" /></p>\n<p>今天就来聊聊 <code>redo log</code>（重做日志）、<code>binlog</code>（归档日志）、两阶段提交、<code>undo log</code> （回滚日志）。</p>\n<h2 id=\"redo-log\"> redo log</h2>\n<p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p>\n<p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/02.png\" alt=\"\" /></p>\n<p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p>\n<p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p>\n<p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p>\n<p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/03.png\" alt=\"\" /></p>\n<p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p>\n<blockquote>\n<p>小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p>\n</blockquote>\n<h3 id=\"刷盘时机\"> 刷盘时机</h3>\n<p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p>\n<ul>\n<li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li>\n<li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li>\n<li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li>\n</ul>\n<p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 redo log 进行刷盘</p>\n<p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/04.png\" alt=\"\" /></p>\n<p>也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘。</p>\n<p><strong>为什么呢？</strong></p>\n<p>因为在事务执行过程 <code>redo log</code> 记录是会写入<code>redo log buffer</code> 中，这些 <code>redo log</code> 记录会被后台线程刷盘。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/05.png\" alt=\"\" /></p>\n<p>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当 <code>redo log buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘。</p>\n<p>下面是不同刷盘策略的流程图。</p>\n<h4 id=\"innodb-flush-log-at-trx-commit-0\"> innodb_flush_log_at_trx_commit=0</h4>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/06.png\" alt=\"\" /></p>\n<p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。</p>\n<h4 id=\"innodb-flush-log-at-trx-commit-1\"> innodb_flush_log_at_trx_commit=1</h4>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/07.png\" alt=\"\" /></p>\n<p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p>\n<p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p>\n<h4 id=\"innodb-flush-log-at-trx-commit-2\"> innodb_flush_log_at_trx_commit=2</h4>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/09.png\" alt=\"\" /></p>\n<p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p>\n<p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p>\n<h3 id=\"日志文件组\"> 日志文件组</h3>\n<p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p>\n<p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code> 日志文件组可以记录<code>4G</code>的内容。</p>\n<p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/10.png\" alt=\"\" /></p>\n<p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <code>write pos、checkpoint</code></p>\n<ul>\n<li><strong>write pos</strong> 是当前记录的位置，一边写一边后移</li>\n<li><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</li>\n</ul>\n<p>每次刷盘 <code>redo log</code> 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。</p>\n<p>每次 <code>MySQL</code> 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 <code>redo log</code> 记录，并把 <code>checkpoint</code> 后移更新。</p>\n<p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/11.png\" alt=\"\" /></p>\n<p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 <code>redo log</code> 记录，<code>MySQL</code> 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/12.png\" alt=\"\" /></p>\n<h3 id=\"redo-log-小结\"> redo log 小结</h3>\n<p>相信大家都知道 <code>redo log</code> 的作用和它的刷盘时机、存储形式。</p>\n<p>现在我们来思考一个问题： <strong>只要每次把修改后的数据页直接刷盘不就好了，还有 <code>redo log</code> 什么事？</strong></p>\n<p>它们不都是刷盘么？差别在哪里？</p>\n<div><pre><code><span>1</span> <span>Byte</span> <span>=</span> <span>8</span>bit\n<span>1</span> KB <span>=</span> <span>1024</span> <span>Byte</span>\n<span>1</span> MB <span>=</span> <span>1024</span> KB\n<span>1</span> GB <span>=</span> <span>1024</span> MB\n<span>1</span> TB <span>=</span> <span>1024</span> GB\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，有必要把完整的数据页刷盘吗？</p>\n<p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p>\n<p>如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移\n量、更新值，再加上是顺序写，所以刷盘速度很快。</p>\n<p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p>\n<blockquote>\n<p>其实内存的数据页在一定时机也会刷盘，我们把这称为页合并，讲 <code>Buffer Pool</code>的时候会对这块细说</p>\n</blockquote>\n<h2 id=\"binlog\"> binlog</h2>\n<p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p>\n<p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p>\n<p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</p>\n<p>那 <code>binlog</code> 到底是用来干嘛的？</p>\n<p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/04/01.png\" alt=\"\" /></p>\n<p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p>\n<h3 id=\"记录格式\"> 记录格式</h3>\n<p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>\n<ul>\n<li><strong>statement</strong></li>\n<li><strong>row</strong></li>\n<li><strong>mixed</strong></li>\n</ul>\n<p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/04/02.png\" alt=\"\" /></p>\n<p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p>\n<p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/04/03.png\" alt=\"\" /></p>\n<p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p>\n<p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p>\n<p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p>\n<p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p>\n<p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p>\n<p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</p>\n<h3 id=\"写入机制\"> 写入机制</h3>\n<p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p>\n<p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p>\n<p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）。</p>\n<p><code>binlog</code>日志刷盘流程如下</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/04/04.png\" alt=\"\" /></p>\n<ul>\n<li><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li>\n<li><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></li>\n</ul>\n<p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。</p>\n<p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/04/05.png\" alt=\"\" /></p>\n<p>虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binglog 会丢失。</p>\n<p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同<strong>binlog 日志刷盘流程</strong>一样。</p>\n<p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/04/06.png\" alt=\"\" /></p>\n<p>在出现<code>IO</code>瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。</p>\n<p>同样的，如果机器宕机，会丢失最近<code>N</code>个事务的<code>binlog</code>日志。</p>\n<h2 id=\"两阶段提交\"> 两阶段提交</h2>\n<p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</p>\n<p><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p>\n<p>虽然它们都属于持久化的保证，但是侧重点不同。</p>\n<p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/05/01.png\" alt=\"\" /></p>\n<p>回到正题，<code>redo log</code>与<code>binlog</code>两份日志之间的逻辑不一致，会出现什么问题？</p>\n<p>我们以<code>update</code>语句为例，假设<code>id=2</code>的记录，字段<code>c</code>值是<code>0</code>，把字段<code>c</code>值更新成<code>1</code>，<code>SQL</code>语句为<code>update T set c=1 where id=2</code>。</p>\n<p>假设执行过程中写完<code>redo log</code>日志后，<code>binlog</code>日志写期间发生了异常，会出现什么情况呢？</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/05/02.png\" alt=\"\" /></p>\n<p>由于<code>binlog</code>没写完就异常，这时候<code>binlog</code>里面没有对应的修改记录。因此，之后用<code>binlog</code>日志恢复数据时，就会少这一次更新，恢复出来的这一行<code>c</code>值是<code>0</code>，而原库因为<code>redo log</code>日志恢复，这一行<code>c</code>值是<code>1</code>，最终数据不一致。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/05/03.png\" alt=\"\" /></p>\n<p>为了解决两份日志之间的逻辑一致问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案。</p>\n<p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/05/04.png\" alt=\"\" /></p>\n<p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/05/05.png\" alt=\"\" /></p>\n<p>再看一个场景，<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/05/06.png\" alt=\"\" /></p>\n<p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据。</p>\n<h2 id=\"undo-log\"> undo log</h2>\n<blockquote>\n<p>这部分内容为 JavaGuide 的补充：</p>\n</blockquote>\n<p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>\n<p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>\n<h2 id=\"总结\"> 总结</h2>\n<blockquote>\n<p>这部分内容为 JavaGuide 的补充：</p>\n</blockquote>\n<p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>\n<p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>\n<h2 id=\"站在巨人的肩膀上\"> 站在巨人的肩膀上</h2>\n<ul>\n<li>《MySQL 实战 45 讲》</li>\n<li>《从零开始带你成为 MySQL 实战优化高手》</li>\n<li>《MySQL 是怎样运行的：从根儿上理解 MySQL》</li>\n<li>《MySQL 技术 Innodb 存储引擎》</li>\n</ul>\n<h2 id=\"mysql-好文推荐\"> MySQL 好文推荐</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/R-1km7r0z3oWfwYQV8iiqA\" target=\"_blank\" rel=\"noopener noreferrer\">CURD 这么多年，你有了解过 MySQL 的架构设计吗？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/7Kab4IQsNcU_bZdbv_MuOg\" target=\"_blank\" rel=\"noopener noreferrer\">浅谈 MySQL InnoDB 的内存组件</a></li>\n</ul>\n",
      "image": "https://cdn.jsdelivr.net/gh/18702524676/CND5/image/mysql/03/01.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL知识点&面试题总结",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/mysql%E7%9F%A5%E8%AF%86%E7%82%B9&%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/mysql%E7%9F%A5%E8%AF%86%E7%82%B9&%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/",
      "content_html": "<h2 id=\"mysql-基础\"> MySQL 基础</h2>\n<h3 id=\"关系型数据库介绍\"> 关系型数据库介绍</h3>\n<p>顾名思义，关系型数据库就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p>\n<p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png\" alt=\"\" /></p>\n<p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。</p>\n<p><strong>有哪些常见的关系型数据库呢？</strong></p>\n<p>MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ......。</p>\n<h3 id=\"mysql-介绍\"> MySQL 介绍</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20210327143351823.png\" alt=\"\" /></p>\n<p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p>\n<p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<strong>3306</strong>。</p>\n<h2 id=\"存储引擎\"> 存储引擎</h2>\n<h3 id=\"存储引擎相关的命令\"> 存储引擎相关的命令</h3>\n<p><strong>查看 MySQL 提供的所有存储引擎</strong></p>\n<div><pre><code>mysql<span>></span> <span>show</span> engines<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/mysql-engines.png\" alt=\"查看MySQL提供的所有存储引擎\" /></p>\n<p>从上图我们可以查看出 MySQL 当前默认的存储引擎是 InnoDB，并且在 5.7 版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p>\n<p><strong>查看 MySQL 当前默认的存储引擎</strong></p>\n<p>我们也可以通过下面的命令查看默认的存储引擎。</p>\n<div><pre><code>mysql<span>></span> <span>show</span> variables <span>like</span> <span>'%storage_engine%'</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>查看表的存储引擎</strong></p>\n<div><pre><code><span>show</span> <span>table</span> <span>status</span> <span>like</span> <span>\"table_name\"</span> <span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/查看表的存储引擎.png\" alt=\"查看表的存储引擎\" /></p>\n<h3 id=\"myisam-和-innodb-的区别\"> MyISAM 和 InnoDB 的区别</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20210327145248960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70\" alt=\"\" /></p>\n<p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p>\n<p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。</p>\n<p>5.5 版本之后，MySQL 引入了 InnoDB（事务性数据库引擎），MySQL 5.5 版本后默认的存储引擎为 InnoDB。小伙子，一定要记好这个 InnoDB ，你每次使用 MySQL 数据库都是用的这个存储引擎吧？</p>\n<p>言归正传！咱们下面还是来简单对比一下两者：</p>\n<p><strong>1.是否支持行级锁</strong></p>\n<p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>\n<p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p>\n<p><strong>2.是否支持事务</strong></p>\n<p>MyISAM 不提供事务支持。</p>\n<p>InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。</p>\n<p><strong>3.是否支持外键</strong></p>\n<p>MyISAM 不支持，而 InnoDB 支持。</p>\n<p>🌈 拓展一下：</p>\n<p>一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p>\n<p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p>\n<p>MyISAM 不支持，而 InnoDB 支持。</p>\n<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p>\n<p>🌈 拓展一下：</p>\n<ul>\n<li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li>\n<li>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</li>\n<li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li>\n</ul>\n<p><strong>5.是否支持 MVCC</strong></p>\n<p>MyISAM 不支持，而 InnoDB 支持。</p>\n<p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。</p>\n<p>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能。</p>\n<h3 id=\"关于-myisam-和-innodb-的选择问题\"> 关于 MyISAM 和 InnoDB 的选择问题</h3>\n<p>大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意啊！）。</p>\n<p>《MySQL 高性能》上面有一句话这样写到:</p>\n<blockquote>\n<p>不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p>\n</blockquote>\n<p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p>\n<p>因此，对于咱们日常开发的业务系统来说，你几乎找不到什么理由再使用 MyISAM 作为自己的 MySQL 数据库的存储引擎。</p>\n<h2 id=\"锁机制与-innodb-锁算法\"> 锁机制与 InnoDB 锁算法</h2>\n<p><strong>MyISAM 和 InnoDB 存储引擎使用的锁：</strong></p>\n<ul>\n<li>MyISAM 采用表级锁(table-level locking)。</li>\n<li>InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁</li>\n</ul>\n<p><strong>表级锁和行级锁对比：</strong></p>\n<ul>\n<li><strong>表级锁：</strong> MySQL 中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li>\n<li><strong>行级锁：</strong> MySQL 中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>\n</ul>\n<p><strong>InnoDB 存储引擎的锁的算法有三种：</strong></p>\n<ul>\n<li>Record lock：记录锁，单个行记录上的锁</li>\n<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>\n<li>Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身</li>\n</ul>\n<h2 id=\"查询缓存\"> 查询缓存</h2>\n<p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用</p>\n<p><code>my.cnf</code> 加入以下配置，重启 MySQL 开启查询缓存</p>\n<div><pre><code><span>query_cache_type</span><span>=</span><span>1</span>\n<span>query_cache_size</span><span>=</span><span>600000</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>MySQL 执行以下命令也可以开启查询缓存</p>\n<div><pre><code><span>set</span> <span>global  query_cache_type=1;</span>\n<span>set</span> <span>global  query_cache_size=600000;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。（<strong>查询缓存不命中的情况：（1）</strong>）因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，（<strong>查询缓存不命中的情况：（2）</strong>）如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</p>\n<p>（<strong>查询缓存不命中的情况：（3）</strong>）<strong>缓存建立之后</strong>，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</p>\n<p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。此外，<strong>还可以通过 sql_cache 和 sql_no_cache 来控制某个查询语句是否需要缓存：</strong></p>\n<div><pre><code><span>select</span> sql_no_cache <span>count</span><span>(</span><span>*</span><span>)</span> <span>from</span> usr<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"事务\"> 事务</h2>\n<h3 id=\"何为事务\"> 何为事务？</h3>\n<p>一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>\n<p><strong>可以简单举一个例子不？</strong></p>\n<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：</p>\n<ol>\n<li>将小明的余额减少 1000 元</li>\n<li>将小红的余额增加 1000 元。</li>\n</ol>\n<p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。</p>\n<p>这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p>\n<h3 id=\"何为数据库事务\"> 何为数据库事务？</h3>\n<p>数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。</p>\n<p>平时，我们在谈论事务的时候，如果没有特指<strong>分布式事务</strong>，往往指的就是<strong>数据库事务</strong>。</p>\n<p><strong>那数据库事务有什么作用呢？</strong></p>\n<p>简单来说：数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p>\n<div><pre><code><span># 开启一个事务</span>\n<span>START</span> <span>TRANSACTION</span><span>;</span>\n<span># 多条 SQL 语句</span>\nSQL1<span>,</span>SQL2<span>.</span><span>.</span><span>.</span>\n<span>## 提交事务</span>\n<span>COMMIT</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/640-20201207160554677.png\" alt=\"\" /></p>\n<p>另外，关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/事务特性.png\" alt=\"事务的特性\" /></p>\n<h3 id=\"何为-acid-特性呢\"> 何为 ACID 特性呢？</h3>\n<ol>\n<li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>\n<li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>\n<li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>\n<li><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n</ol>\n<p><strong>数据事务的实现原理呢？</strong></p>\n<p>我们这里以 MySQL 的 InnoDB 引擎为例来简单说一下。</p>\n<p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>\n<p>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</p>\n<p>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</p>\n<h3 id=\"并发事务带来哪些问题\"> 并发事务带来哪些问题?</h3>\n<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<ul>\n<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>\n<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li>\n<li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>\n<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>\n</ul>\n<p><strong>不可重复读和幻读区别：</strong></p>\n<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p>\n<h3 id=\"事务隔离级别有哪些\"> 事务隔离级别有哪些?</h3>\n<p>SQL 标准定义了四个隔离级别：</p>\n<ul>\n<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>\n<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>\n<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>\n<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>\n</ul>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">隔离级别</th>\n<th style=\"text-align:center\">脏读</th>\n<th style=\"text-align:center\">不可重复读</th>\n<th style=\"text-align:center\">幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">READ-UNCOMMITTED</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">READ-COMMITTED</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">REPEATABLE-READ</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SERIALIZABLE</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"mysql-的默认隔离级别是什么\"> MySQL 的默认隔离级别是什么?</h3>\n<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>\n<div><pre><code>mysql<span>></span> <span>SELECT</span> @<span>@tx_isolation</span><span>;</span>\n<span>+</span><span>-----------------+</span>\n<span>|</span> @<span>@tx_isolation</span>  <span>|</span>\n<span>+</span><span>-----------------+</span>\n<span>|</span> <span>REPEATABLE</span><span>-</span><span>READ</span> <span>|</span>\n<span>+</span><span>-----------------+</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><s>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是 Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</s></p>\n<p>🐛 问题更正：<strong>MySQL InnoDB 的 REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是 Next-Key Locks。</strong></p>\n<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong> 并不会有任何性能损失。</p>\n<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>\n<p>🌈 拓展一下(以下内容摘自《MySQL 技术内幕：InnoDB 存储引擎(第 2 版)》7.7 章)：</p>\n<blockquote>\n<p>InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。</p>\n</blockquote>\n<h2 id=\"参考\"> 参考</h2>\n<ul>\n<li>《高性能 MySQL》</li>\n<li>https://www.omnisci.com/technical-glossary/relational-database</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "关于数据库中如何存储时间的一点思考",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/some-thoughts-on-database-storage-time/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/some-thoughts-on-database-storage-time/",
      "content_html": "<p>我们平时开发中不可避免的就是要存储时间，比如我们要记录操作表中这条记录的时间、记录转账的交易时间、记录出发时间等等。你会发现时间这个东西与我们开发的联系还是非常紧密的，用的好与不好会给我们的业务甚至功能带来很大的影响。所以，我们有必要重新出发，好好认识一下这个东西。</p>\n<p>这是一篇短小精悍的文章，仔细阅读一定能学到不少东西！</p>\n<h3 id=\"_1-切记不要用字符串存储日期\"> 1.切记不要用字符串存储日期</h3>\n<p>我记得我在大学的时候就这样干过，而且现在很多对数据库不太了解的新手也会这样干，可见，这种存储日期的方式的优点还是有的，就是简单直白，容易上手。</p>\n<p>但是，这是不正确的做法，主要会有下面两个问题：</p>\n<ol>\n<li>字符串占用的空间更大！</li>\n<li>字符串存储的日期效率比较低（逐个字符进行比对），无法用日期相关的 API 进行计算和比较。</li>\n</ol>\n<h3 id=\"_2-datetime-和-timestamp-之间抉择\"> 2.Datetime 和 Timestamp 之间抉择</h3>\n<p>Datetime 和 Timestamp 是 MySQL 提供的两种比较相似的保存时间的数据类型。他们两者究竟该如何选择呢？</p>\n<p><strong>通常我们都会首选 Timestamp。</strong> 下面说一下为什么这样做!</p>\n<h4 id=\"_2-1-datetime-类型没有时区信息\"> 2.1 DateTime 类型没有时区信息</h4>\n<p><strong>DateTime 类型是没有时区信息的（时区无关）</strong> ，DateTime 类型保存的时间都是当前会话所设置的时区对应的时间。这样就会有什么问题呢？当你的时区更换之后，比如你的服务器更换地址或者更换客户端连接时区设置的话，就会导致你从数据库中读出的时间错误。不要小看这个问题，很多系统就是因为这个问题闹出了很多笑话。</p>\n<p><strong>Timestamp 和时区有关</strong>。Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。</p>\n<p>下面实际演示一下！</p>\n<p>建表 SQL 语句：</p>\n<div><pre><code><span>CREATE</span> <span>TABLE</span> <span>`</span>time_zone_test<span>`</span> <span>(</span>\n  <span>`</span>id<span>`</span> <span>bigint</span><span>(</span><span>20</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>AUTO_INCREMENT</span><span>,</span>\n  <span>`</span>date_time<span>`</span> <span>datetime</span> <span>DEFAULT</span> <span>NULL</span><span>,</span>\n  <span>`</span>time_stamp<span>`</span> <span>timestamp</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>CURRENT_TIMESTAMP</span> <span>ON</span> <span>UPDATE</span> <span>CURRENT_TIMESTAMP</span><span>,</span>\n  <span>PRIMARY</span> <span>KEY</span> <span>(</span><span>`</span>id<span>`</span><span>)</span>\n<span>)</span> <span>ENGINE</span><span>=</span><span>InnoDB</span> <span>DEFAULT</span> <span>CHARSET</span><span>=</span>utf8<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>插入数据：</p>\n<div><pre><code><span>INSERT</span> <span>INTO</span> time_zone_test<span>(</span>date_time<span>,</span>time_stamp<span>)</span> <span>VALUES</span><span>(</span><span>NOW</span><span>(</span><span>)</span><span>,</span><span>NOW</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>查看数据：</p>\n<div><pre><code><span>select</span> date_time<span>,</span>time_stamp <span>from</span> time_zone_test<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>结果：</p>\n<div><pre><code>+---------------------+---------------------+\n| date_time           | time_stamp          |\n+---------------------+---------------------+\n| 2020-01-11 09:53:32 | 2020-01-11 09:53:32 |\n+---------------------+---------------------+\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>现在我们运行</p>\n<p>修改当前会话的时区:</p>\n<div><pre><code><span>set</span> time_zone<span>=</span><span>'+8:00'</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>再次查看数据：</p>\n<div><pre><code>+---------------------+---------------------+\n| date_time           | time_stamp          |\n+---------------------+---------------------+\n| 2020-01-11 09:53:32 | 2020-01-11 17:53:32 |\n+---------------------+---------------------+\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>扩展：一些关于 MySQL 时区设置的一个常用 sql 命令</strong></p>\n<div><pre><code><span># 查看当前会话时区</span>\n<span>SELECT</span> @<span>@session.time_zone</span><span>;</span>\n<span># 设置当前会话时区</span>\n<span>SET</span> time_zone <span>=</span> <span>'Europe/Helsinki'</span><span>;</span>\n<span>SET</span> time_zone <span>=</span> <span>\"+00:00\"</span><span>;</span>\n<span># 数据库全局时区设置</span>\n<span>SELECT</span> @<span>@global.time_zone</span><span>;</span>\n<span># 设置全局时区</span>\n<span>SET</span> <span>GLOBAL</span> time_zone <span>=</span> <span>'+8:00'</span><span>;</span>\n<span>SET</span> <span>GLOBAL</span> time_zone <span>=</span> <span>'Europe/Helsinki'</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id=\"_2-2-datetime-类型耗费空间更大\"> 2.2 DateTime 类型耗费空间更大</h4>\n<p>Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。</p>\n<ul>\n<li>DateTime ：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li>\n<li>Timestamp： 1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li>\n</ul>\n<blockquote>\n<p>Timestamp 在不同版本的 MySQL 中有细微差别。</p>\n</blockquote>\n<h3 id=\"_3-再看-mysql-日期类型存储空间\"> 3 再看 MySQL 日期类型存储空间</h3>\n<p>下图是 MySQL 5.6 版本中日期类型所占的存储空间：</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/FhRGUVHFK0ujRPNA75f6CuOXQHTE.jpeg\" alt=\"\" /></p>\n<p>可以看出 5.6.4 之后的 MySQL 多出了一个需要 0 ～ 3 字节的小数位。DateTime 和 Timestamp 会有几种不同的存储空间占用。</p>\n<p>为了方便，本文我们还是默认 Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间。</p>\n<h3 id=\"_4-数值型时间戳是更好的选择吗\"> 4.数值型时间戳是更好的选择吗？</h3>\n<p>很多时候，我们也会使用 int 或者 bigint 类型的数值也就是时间戳来表示时间。</p>\n<p>这种存储方式的具有 Timestamp 类型的所具有一些优点，并且使用它的进行日期排序以及对比等操作的效率会更高，跨系统也很方便，毕竟只是存放的数值。缺点也很明显，就是数据的可读性太差了，你无法直观的看到具体时间。</p>\n<p>时间戳的定义如下：</p>\n<blockquote>\n<p>时间戳的定义是从一个基准时间开始算起，这个基准时间是「1970-1-1 00:00:00 +0:00」，从这个时间开始，用整数表示，以秒计时，随着时间的流逝这个时间整数不断增加。这样一来，我只需要一个数值，就可以完美地表示时间了，而且这个数值是一个绝对数值，即无论的身处地球的任何角落，这个表示时间的时间戳，都是一样的，生成的数值都是一样的，并且没有时区的概念，所以在系统的中时间的传输中，都不需要进行额外的转换了，只有在显示给用户的时候，才转换为字符串格式的本地时间。</p>\n</blockquote>\n<p>数据库中实际操作：</p>\n<div><pre><code>mysql<span>></span> <span>select</span> UNIX_TIMESTAMP<span>(</span><span>'2020-01-11 09:53:32'</span><span>)</span><span>;</span>\n<span>+</span><span>---------------------------------------+</span>\n<span>|</span> UNIX_TIMESTAMP<span>(</span><span>'2020-01-11 09:53:32'</span><span>)</span> <span>|</span>\n<span>+</span><span>---------------------------------------+</span>\n<span>|</span>                            <span>1578707612</span> <span>|</span>\n<span>+</span><span>---------------------------------------+</span>\n<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>\n\nmysql<span>></span> <span>select</span> FROM_UNIXTIME<span>(</span><span>1578707612</span><span>)</span><span>;</span>\n<span>+</span><span>---------------------------+</span>\n<span>|</span> FROM_UNIXTIME<span>(</span><span>1578707612</span><span>)</span> <span>|</span>\n<span>+</span><span>---------------------------+</span>\n<span>|</span> <span>2020</span><span>-</span><span>01</span><span>-</span><span>11</span> <span>09</span>:<span>53</span>:<span>32</span>       <span>|</span>\n<span>+</span><span>---------------------------+</span>\n<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.01</span> sec<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"_5-总结\"> 5.总结</h3>\n<p>MySQL 中时间到底怎么存储才好？Datetime?Timestamp? 数值保存的时间戳？</p>\n<p>好像并没有一个银弹，很多程序员会觉得数值型时间戳是真的好，效率又高还各种兼容，但是很多人又觉得它表现的不够直观。这里插一嘴，《高性能 MySQL 》这本神书的作者就是推荐 Timestamp，原因是数值表示时间不够直观。下面是原文：</p>\n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/高性能mysql-不推荐用数值时间戳.jpg\" style=\"zoom:50%;\" />\n<p>每种方式都有各自的优势，根据实际场景才是王道。下面再对这三种方式做一个简单的对比，以供大家实际开发中选择正确的存放时间的数据类型：</p>\n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/总结-常用日期存储方式.jpg\" style=\"zoom:50%;\" />",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/FhRGUVHFK0ujRPNA75f6CuOXQHTE.jpeg",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "事务隔离级别(图文详解)",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/transaction-isolation-level/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/mysql/transaction-isolation-level/",
      "content_html": "<blockquote>\n<p>本文由 <a href=\"https://github.com/Snailclimb\" target=\"_blank\" rel=\"noopener noreferrer\">SnailClimb</a> 和 <a href=\"https://github.com/guang19\" target=\"_blank\" rel=\"noopener noreferrer\">guang19</a> 共同完成。</p>\n</blockquote>\n<h2 id=\"事务隔离级别-图文详解\"> 事务隔离级别(图文详解)</h2>\n<h3 id=\"什么是事务\"> 什么是事务?</h3>\n<p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>\n<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>\n<h3 id=\"事务的特性-acid\"> 事务的特性(ACID)</h3>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/事务特性.png\" alt=\"事务的特性\" /></p>\n<ol>\n<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>\n<li><strong>一致性：</strong> 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>\n<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>\n<li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n</ol>\n<h3 id=\"并发事务带来的问题\"> 并发事务带来的问题</h3>\n<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<ul>\n<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>\n<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。\t例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>\n<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>\n<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>\n</ul>\n<p><strong>不可重复度和幻读区别：</strong></p>\n<p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>\n<p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为     1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导        致A再读自己的工资时工资变为  2000；这就是不可重复读。</p>\n<p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p>\n<h3 id=\"事务隔离级别\"> 事务隔离级别</h3>\n<p><strong>SQL 标准定义了四个隔离级别：</strong></p>\n<ul>\n<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>\n<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>\n<li><strong>REPEATABLE-READ(可重复读)：</strong>  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>\n<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>\n</ul>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">隔离级别</th>\n<th style=\"text-align:center\">脏读</th>\n<th style=\"text-align:center\">不可重复读</th>\n<th style=\"text-align:center\">幻影读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">READ-UNCOMMITTED</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">READ-COMMITTED</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">REPEATABLE-READ</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SERIALIZABLE</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n</tbody>\n</table>\n<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>\n<div><pre><code>mysql<span>></span> <span>SELECT</span> @<span>@tx_isolation</span><span>;</span>\n<span>+</span><span>-----------------+</span>\n<span>|</span> @<span>@tx_isolation</span>  <span>|</span>\n<span>+</span><span>-----------------+</span>\n<span>|</span> <span>REPEATABLE</span><span>-</span><span>READ</span> <span>|</span>\n<span>+</span><span>-----------------+</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><s>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是 Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</s></p>\n<p>🐛 问题更正：<strong>MySQL InnoDB 的 REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是 Next-Key Locks。</strong></p>\n<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong> 并不会有任何性能损失。</p>\n<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>\n<p>🌈 拓展一下(以下内容摘自《MySQL 技术内幕：InnoDB 存储引擎(第 2 版)》7.7 章)：</p>\n<blockquote>\n<p>InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。</p>\n</blockquote>\n<h3 id=\"实际情况演示\"> 实际情况演示</h3>\n<p>在下面我会使用 2 个命令行mysql ，模拟多线程（多事务）对同一份数据的脏读问题。</p>\n<p>MySQL 命令行的默认配置中事务都是自动提交的，即执行SQL语句后就会马上执行 COMMIT 操作。如果要显式地开启一个事务需要使用命令：<code>START TARNSACTION</code>。</p>\n<p>我们可以通过下面的命令来设置隔离级别。</p>\n<div><pre><code><span>SET</span> <span>[</span><span>SESSION</span><span>|</span><span>GLOBAL</span><span>]</span> <span>TRANSACTION</span> <span>ISOLATION</span> <span>LEVEL</span> <span>[</span><span>READ</span> <span>UNCOMMITTED</span><span>|</span><span>READ</span> <span>COMMITTED</span><span>|</span><span>REPEATABLE</span> <span>READ</span><span>|</span><span>SERIALIZABLE</span><span>]</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>我们再来看一下我们在下面实际操作中使用到的一些并发控制语句:</p>\n<ul>\n<li><code>START TARNSACTION</code> |<code>BEGIN</code>：显式地开启一个事务。</li>\n<li><code>COMMIT</code>：提交事务，使得对数据库做的所有修改成为永久性。</li>\n<li><code>ROLLBACK</code>：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li>\n</ul>\n<h4 id=\"脏读-读未提交\"> 脏读(读未提交)</h4>\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-31-1脏读(读未提交)实例.jpg\" width=\"800px\"/>\n</div>\n<h4 id=\"避免脏读-读已提交\"> 避免脏读(读已提交)</h4>\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-31-2读已提交实例.jpg\" width=\"800px\"/>\n</div>\n<h4 id=\"不可重复读\"> 不可重复读</h4>\n<p>还是刚才上面的读已提交的图，虽然避免了读未提交，但是却出现了，一个事务还没有结束，就发生了 不可重复读问题。</p>\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-32-1不可重复读实例.jpg\"/>\n</div>\n<h4 id=\"可重复读\"> 可重复读</h4>\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-33-2可重复读.jpg\"/>\n</div>\n<h4 id=\"防止幻读-可重复读\"> 防止幻读(可重复读)</h4>\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-33防止幻读(使用可重复读).jpg\"/>\n</div>\n<p>一个事务对数据库进行操作，这种操作的范围是数据库的全部行，然后第二个事务也在对这个数据库操作，这种操作可以是插入一行记录或删除一行记录，那么第一个是事务就会觉得自己出现了幻觉，怎么还有没有处理的记录呢? 或者 怎么多处理了一行记录呢?</p>\n<p>幻读和不可重复读有些相似之处 ，但是不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>\n<h3 id=\"参考\"> 参考</h3>\n<ul>\n<li>《MySQL技术内幕：InnoDB存储引擎》</li>\n<li><a href=\"https://dev.mysql.com/doc/refman/5.7/en/\" target=\"_blank\" rel=\"noopener noreferrer\">https://dev.mysql.com/doc/refman/5.7/en/</a></li>\n<li><a href=\"https://tech.youzan.com/seven-questions-about-the-lock-of-mysql/\" target=\"_blank\" rel=\"noopener noreferrer\">Mysql 锁：灵魂七拷问</a></li>\n<li><a href=\"https://tech.meituan.com/2014/08/20/innodb-lock.html\" target=\"_blank\" rel=\"noopener noreferrer\">Innodb 中的事务隔离级别和锁的关系</a></li>\n</ul>\n",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/事务特性.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "3种常用的缓存读写策略",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/redis/3-commonly-used-cache-read-and-write-strategies/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/redis/3-commonly-used-cache-read-and-write-strategies/",
      "content_html": "<p>看到很多小伙伴简历上写了“<strong>熟练使用缓存</strong>”，但是被我问到“<strong>缓存常用的3种读写策略</strong>”的时候却一脸懵逼。</p>\n<p>在我看来，造成这个问题的原因是我们在学习 Redis 的时候，可能只是简单了写一些 Demo，并没有去关注缓存的读写策略，或者说压根不知道这回事。</p>\n<p>但是，搞懂3种常见的缓存读写策略对于实际工作中使用缓存以及面试中被问到缓存都是非常有帮助的！</p>\n<p>下面我会简单介绍一下自己对于这 3 种缓存读写策略的理解。</p>\n<p>另外，<strong>这3 种缓存读写策略各有优劣，不存在最佳，需要我们根据具体的业务场景选择更适合的。</strong></p>\n<p><em>个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！——爱你们的 Guide 哥</em></p>\n<h3 id=\"cache-aside-pattern-旁路缓存模式\"> Cache Aside Pattern（旁路缓存模式）</h3>\n<p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p>\n<p>Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。</p>\n<p>下面我们来看一下这个策略模式下的缓存读写步骤。</p>\n<p><strong>写</strong> ：</p>\n<ul>\n<li>先更新 DB</li>\n<li>然后直接删除 cache 。</li>\n</ul>\n<p>简单画了一张图帮助大家理解写的步骤。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5687fe759a1dac9ed9554d27e3a23b6d.png\" alt=\"\" /></p>\n<p><strong>读</strong> :</p>\n<ul>\n<li>从 cache 中读取数据，读取到就直接返回</li>\n<li>cache中读取不到的话，就从 DB 中读取数据返回</li>\n<li>再把数据放到 cache 中。</li>\n</ul>\n<p>简单画了一张图帮助大家理解读的步骤。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/a8c18b5f5b1aed03234bcbbd8c173a87.png\" alt=\"\" /></p>\n<p>你仅仅了解了上面这些内容的话是远远不够的，我们还要搞懂其中的原理。</p>\n<p>比如说面试官很可能会追问：“<strong>在写数据的过程中，可以先删除 cache ，后更新 DB 么？</strong>”</p>\n<p><strong>答案：</strong> 那肯定是不行的！因为这样可能会造成<strong>数据库（DB）和缓存（Cache）数据不一致</strong>的问题。为什么呢？比如说请求1 先写数据A，请求2随后读数据A的话就很有可能产生数据不一致性的问题。这个过程可以简单描述为：</p>\n<blockquote>\n<p>请求1先把cache中的A数据删除 -&gt; 请求2从DB中读取数据-&gt;请求1再把DB中的A数据更新。</p>\n</blockquote>\n<p>当你这样回答之后，面试官可能会紧接着就追问：“<strong>在写数据的过程中，先更新DB，后删除cache就没有问题了么？</strong>”</p>\n<p><strong>答案：</strong> 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多！</p>\n<p>比如请求1先读数据 A，请求2随后写数据A，并且数据A不在缓存中的话也有可能产生数据不一致性的问题。这个过程可以简单描述为：</p>\n<blockquote>\n<p>请求1从DB读数据A-&gt;请求2写更新数据 A 到数据库并把删除cache中的A数据-&gt;请求1将数据A写入cache。</p>\n</blockquote>\n<p>现在我们再来分析一下 <strong>Cache Aside Pattern 的缺陷</strong>。</p>\n<p><strong>缺陷1：首次请求数据一定不在 cache 的问题</strong></p>\n<p>解决办法：可以将热点数据可以提前放入cache 中。</p>\n<p><strong>缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p>\n<p>解决办法：</p>\n<ul>\n<li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</li>\n<li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>\n</ul>\n<h3 id=\"read-write-through-pattern-读写穿透\"> Read/Write Through Pattern（读写穿透）</h3>\n<p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</p>\n<p>这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入DB的功能。</p>\n<p><strong>写（Write Through）：</strong></p>\n<ul>\n<li>先查 cache，cache 中不存在，直接更新 DB。</li>\n<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</li>\n</ul>\n<p>简单画了一张图帮助大家理解写的步骤。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210201100340808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70\" alt=\"\" /></p>\n<p><strong>读(Read Through)：</strong></p>\n<ul>\n<li>从 cache 中读取数据，读取到就直接返回 。</li>\n<li>读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</li>\n</ul>\n<p>简单画了一张图帮助大家理解读的步骤。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9ada757c78614934aca11306f334638d.png\" alt=\"\" /></p>\n<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>\n<p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>\n<h3 id=\"write-behind-pattern-异步缓存写入\"> Write Behind Pattern（异步缓存写入）</h3>\n<p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。</p>\n<p>但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p>\n<p>很明显，这种方式对数据一致性带来了更大的挑战，比如cache数据可能还没异步更新DB的话，cache服务可能就就挂掉了。</p>\n<p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 InnoDB Buffer Pool 机制都用到了这种策略。</p>\n<p>Write Behind Pattern 下 DB 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/5687fe759a1dac9ed9554d27e3a23b6d.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "数据库基础知识",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
      "content_html": "<p>数据库知识基础，这部分内容一定要理解记忆。虽然这部分内容只是理论知识，但是非常重要，这是后面学习 MySQL 数据库的基础。PS: 这部分内容由于涉及太多概念性内容，所以参考了维基百科和百度百科相应的介绍。</p>\n<h2 id=\"什么是数据库-数据库管理系统-数据库系统-数据库管理员\"> 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h2>\n<ul>\n<li><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li>\n<li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li>\n<li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li>\n<li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</li>\n</ul>\n<p>数据库系统基本构成如下图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e21120184e63406526a4e873cacd23f2.png\" alt=\"数据库系统基本构成\" /></p>\n<h2 id=\"什么是元组-码-候选码-主码-外码-主属性-非主属性\"> 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h2>\n<ul>\n<li><strong>元组</strong> ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li>\n<li><strong>码</strong> ：码就是能唯一标识实体的属性，对应表中的列。</li>\n<li><strong>候选码</strong> ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li>\n<li><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li>\n<li><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li>\n<li><strong>主属性</strong> ： 候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li>\n<li><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li>\n</ul>\n<h2 id=\"主键和外键有什么区别\"> 主键和外键有什么区别?</h2>\n<ul>\n<li><strong>主键(主码)</strong> ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li>\n<li><strong>外键(外码)</strong> ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li>\n</ul>\n<h2 id=\"为什么不推荐使用外键与级联\"> 为什么不推荐使用外键与级联？</h2>\n<p>对于外键和级联，阿里巴巴开发手册这样说到：</p>\n<blockquote>\n<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>\n<p>说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风 险; 外键影响数据库的插入速度</p>\n</blockquote>\n<p>为什么不要用外键呢？大部分人可能会这样回答：</p>\n<blockquote>\n<ol>\n<li><strong>增加了复杂性：</strong> a. 每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li>\n<li><strong>增加了额外工作</strong>： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li>\n<li>外键还会因为需要请求对其他表内部加锁而容易出现死锁情况；</li>\n<li><strong>对分库分表不友好</strong> ：因为分库分表下外键是无法生效的。</li>\n<li>......</li>\n</ol>\n</blockquote>\n<p>我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：</p>\n<ol>\n<li>保证了数据库数据的一致性和完整性；</li>\n<li>级联操作方便，减轻了程序代码量；</li>\n<li>......</li>\n</ol>\n<p>所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。</p>\n<h2 id=\"什么是-er-图\"> 什么是 ER 图？</h2>\n<blockquote>\n<p>我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问道的。</p>\n</blockquote>\n<p><strong>E-R 图</strong> 也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 它是描述现实世界关系概念模型的有效方法。 是表示概念关系模型的一种方式。</p>\n<p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种关系是：1 对 1（1:1）、1 对多（1: N）。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/4717673e36966e0e4b33fccfd753f6ea.png\" alt=\"ER图示例\" /></p>\n<p>我们试着将上面的 ER 图转换成数据库实际的关系模型(实际设计中，我们通常会将任课教师也作为一个实体来处理)：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5897753dfb301dfa3a814ab06e718a5e.png\" alt=\"关系模型\" /></p>\n<h2 id=\"数据库范式了解吗\"> 数据库范式了解吗?</h2>\n<p><strong>1NF(第一范式)</strong></p>\n<p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p>\n<p><strong>2NF(第二范式)</strong></p>\n<p>2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/bd1d31be3779342427fc9e462bf7f05c.png\" alt=\"第二范式\" /></p>\n<p>一些重要的概念：</p>\n<ul>\n<li><strong>函数依赖（functional dependency）</strong> ：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。</li>\n<li><strong>部分函数依赖（partial functional dependency）</strong> ：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</li>\n<li><strong>完全函数依赖(Full functional dependency)</strong> ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li>\n<li><strong>传递函数依赖</strong> ： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li>\n</ul>\n<p><strong>3NF(第三范式)</strong></p>\n<p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p>\n<p><strong>总结</strong></p>\n<ul>\n<li>1NF：属性不可再分。</li>\n<li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li>\n<li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li>\n</ul>\n<h2 id=\"什么是存储过程\"> 什么是存储过程?</h2>\n<p>我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。</p>\n<p>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p>\n<p>阿里巴巴 Java 开发手册里要求禁止使用存储过程。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/0fa082bc4d4f919065767476a41b2156.png\" alt=\"阿里巴巴Java开发手册: 禁止存储过程\" /></p>\n<h2 id=\"drop、delete-与-truncate-区别\"> drop、delete 与 truncate 区别？</h2>\n<h3 id=\"用法不同\"> 用法不同</h3>\n<ul>\n<li>drop(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li>\n<li>truncate (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li>\n<li>delete（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一列的数据，如果不加 where 子句和<code>truncate table 表名</code>作用类似。</li>\n</ul>\n<p>truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据，但是 <strong>truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。</strong></p>\n<h3 id=\"属于不同的数据库语言\"> 属于不同的数据库语言</h3>\n<p>truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。</p>\n<p><strong>DML 语句和 DDL 语句区别：</strong></p>\n<ul>\n<li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。</li>\n<li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li>\n</ul>\n<h3 id=\"执行速度不同\"> 执行速度不同</h3>\n<p>一般来说:drop&gt;truncate&gt;delete（这个我没有设计测试过）。</p>\n<h2 id=\"数据库设计通常分为哪几步\"> 数据库设计通常分为哪几步?</h2>\n<ol>\n<li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li>\n<li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li>\n<li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>\n<li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li>\n<li><strong>数据库实施</strong> : 包括编程、测试和试运行</li>\n<li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li>\n</ol>\n<h2 id=\"参考\"> 参考</h2>\n<ul>\n<li><a href=\"https://blog.csdn.net/rl529014/article/details/48391465\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/rl529014/article/details/48391465</a></li>\n<li><a href=\"https://www.zhihu.com/question/24696366/answer/29189700\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.zhihu.com/question/24696366/answer/29189700</a></li>\n<li><a href=\"https://blog.csdn.net/bieleyang/article/details/77149954\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/bieleyang/article/details/77149954</a></li>\n</ul>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/e21120184e63406526a4e873cacd23f2.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Redis知识点&面试题总结",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/redis/redis-all/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/redis/redis-all/",
      "content_html": "<h3 id=\"简单介绍一下-redis-呗\"> 简单介绍一下 Redis 呗!</h3>\n<p>简单来说 <strong>Redis 就是一个使用 C 语言开发的数据库</strong>，不过与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p>\n<p>另外，<strong>Redis 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。</strong></p>\n<p><strong>Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</strong></p>\n<h3 id=\"分布式缓存常见的技术选型方案有哪些\"> 分布式缓存常见的技术选型方案有哪些？</h3>\n<p>分布式缓存的话，使用的比较多的主要是 <strong>Memcached</strong> 和 <strong>Redis</strong>。不过，现在基本没有看过还有项目使用 <strong>Memcached</strong> 来做缓存，都是直接用 <strong>Redis</strong>。</p>\n<p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。</p>\n<p>分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用信息的问题。因为，本地缓存只在当前服务里有效，比如如果你部署了两个相同的服务，他们两者之间的缓存数据是无法共同的。</p>\n<h3 id=\"说一下-redis-和-memcached-的区别和共同点\"> 说一下 Redis 和 Memcached 的区别和共同点</h3>\n<p>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！</p>\n<p><strong>共同点</strong> ：</p>\n<ol>\n<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>\n<li>都有过期策略。</li>\n<li>两者的性能都非常高。</li>\n</ol>\n<p><strong>区别</strong> ：</p>\n<ol>\n<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>\n<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。</strong></li>\n<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>\n<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>\n<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li>\n<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li>\n<li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li>\n<li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li>\n</ol>\n<p>相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。</p>\n<h3 id=\"缓存数据的处理流程是怎样的\"> 缓存数据的处理流程是怎样的？</h3>\n<p>作为暖男一号，我给大家画了一个草图。</p>\n<p><img src=\"./images/redis-all/缓存的处理流程.png\" alt=\"正常缓存处理流程\" /></p>\n<p>简单来说就是:</p>\n<ol>\n<li>如果用户请求的数据在缓存中就直接返回。</li>\n<li>缓存中不存在的话就看数据库中是否存在。</li>\n<li>数据库中存在的话就更新缓存中的数据。</li>\n<li>数据库中不存在的话就返回空数据。</li>\n</ol>\n<h3 id=\"为什么要用-redis-为什么要用缓存\"> 为什么要用 Redis/为什么要用缓存？</h3>\n<p><em>简单，来说使用缓存主要是为了提升用户体验以及应对更多的用户。</em></p>\n<p>下面我们主要从“高性能”和“高并发”这两点来看待这个问题。</p>\n<p><img src=\"./images/redis-all/使用缓存之后.png\" alt=\"\" /></p>\n<p><strong>高性能</strong> ：</p>\n<p>对照上面 👆 我画的图。我们设想这样的场景：</p>\n<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p>\n<p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p>\n<p>不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>\n<p><strong>高并发：</strong></p>\n<p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</p>\n<blockquote>\n<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p>\n</blockquote>\n<p>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p>\n<h3 id=\"redis-除了做缓存-还能做什么\"> Redis 除了做缓存，还能做什么？</h3>\n<ul>\n<li><strong>分布式锁</strong> ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。相关阅读：<a href=\"https://mp.weixin.qq.com/s/CbnPRfvq4m1sqo2uKI6qQw\" target=\"_blank\" rel=\"noopener noreferrer\">《分布式锁中的王者方案 - Redisson》</a>。</li>\n<li><strong>限流</strong> ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：<a href=\"https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA\" target=\"_blank\" rel=\"noopener noreferrer\">《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》</a>。</li>\n<li><strong>消息队列</strong> ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>\n<li><strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li>\n<li>......</li>\n</ul>\n<h3 id=\"redis-常见数据结构以及使用场景分析\"> Redis 常见数据结构以及使用场景分析</h3>\n<p>你可以自己本机安装 redis 或者通过 redis 官网提供的<a href=\"https://try.redis.io/\" target=\"_blank\" rel=\"noopener noreferrer\">在线 redis 环境</a>。</p>\n<p><img src=\"./images/redis-all/try-redis.png\" alt=\"try-redis\" /></p>\n<h4 id=\"string\"> string</h4>\n<ol>\n<li><strong>介绍</strong> ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（simple dynamic string，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</li>\n<li><strong>常用命令：</strong> <code>set,get,strlen,exists,decr,incr,setex</code> 等等。</li>\n<li><strong>应用场景：</strong> 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</li>\n</ol>\n<p>下面我们简单看看它的使用！</p>\n<p><strong>普通字符串的基本操作：</strong></p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> key value <span>#设置 key-value 类型的值</span>\nOK\n<span>127.0</span>.0.1:637<span><span>9</span>></span> get key <span># 根据 key 获得对应的 value</span>\n<span>\"value\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> exists key  <span># 判断某个 key 是否存在</span>\n<span>(</span>integer<span>)</span> <span>1</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> strlen key <span># 返回 key 所储存的字符串值的长度。</span>\n<span>(</span>integer<span>)</span> <span>5</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> del key <span># 删除某个 key 对应的值</span>\n<span>(</span>integer<span>)</span> <span>1</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> get key\n<span>(</span>nil<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>批量设置</strong> :</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> mset key1 value1 key2 value2 <span># 批量设置 key-value 类型的值</span>\nOK\n<span>127.0</span>.0.1:637<span><span>9</span>></span> mget key1 key2 <span># 批量获取多个 key 对应的 value</span>\n<span>1</span><span>)</span> <span>\"value1\"</span>\n<span>2</span><span>)</span> <span>\"value2\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>set</span> number <span>1</span>\nOK\n<span>127.0</span>.0.1:637<span><span>9</span>></span> incr number <span># 将 key 中储存的数字值增一</span>\n<span>(</span>integer<span>)</span> <span>2</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> get number\n<span>\"2\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> decr number <span># 将 key 中储存的数字值减一</span>\n<span>(</span>integer<span>)</span> <span>1</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> get number\n<span>\"1\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>过期（默认为永不过期）</strong>：</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> expire key  <span>60</span> <span># 数据在 60s 后过期</span>\n<span>(</span>integer<span>)</span> <span>1</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> setex key <span>60</span> value <span># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span>\nOK\n<span>127.0</span>.0.1:637<span><span>9</span>></span> ttl key <span># 查看数据还有多久过期</span>\n<span>(</span>integer<span>)</span> <span>56</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id=\"list\"> list</h4>\n<ol>\n<li><strong>介绍</strong> ：<strong>list</strong> 即是 <strong>链表</strong>。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 <strong>LinkedList</strong>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</li>\n<li><strong>常用命令:</strong> <code>rpush,lpop,lpush,rpop,lrange,llen</code> 等。</li>\n<li><strong>应用场景:</strong> 发布与订阅或者说消息队列、慢查询。</li>\n</ol>\n<p>下面我们简单看看它的使用！</p>\n<p><strong>通过 <code>rpush/lpop</code> 实现队列：</strong></p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> rpush myList value1 <span># 向 list 的头部（右边）添加元素</span>\n<span>(</span>integer<span>)</span> <span>1</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> rpush myList value2 value3 <span># 向list的头部（最右边）添加多个元素</span>\n<span>(</span>integer<span>)</span> <span>3</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> lpop myList <span># 将 list的尾部(最左边)元素取出</span>\n<span>\"value1\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange myList <span>0</span> <span>1</span> <span># 查看对应下标的list列表， 0 为 start,1为 end</span>\n<span>1</span><span>)</span> <span>\"value2\"</span>\n<span>2</span><span>)</span> <span>\"value3\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange myList <span>0</span> -1 <span># 查看列表中的所有元素，-1表示倒数第一</span>\n<span>1</span><span>)</span> <span>\"value2\"</span>\n<span>2</span><span>)</span> <span>\"value3\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>通过 <code>rpush/rpop</code> 实现栈：</strong></p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> rpush myList2 value1 value2 value3\n<span>(</span>integer<span>)</span> <span>3</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> rpop myList2 <span># 将 list的头部(最右边)元素取出</span>\n<span>\"value3\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>我专门画了一个图方便小伙伴们来理解：</p>\n<p><img src=\"./images/redis-all/redis-list.png\" alt=\"redis list\" /></p>\n<p><strong>通过 <code>lrange</code> 查看对应下标范围的列表元素：</strong></p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> rpush myList value1 value2 value3\n<span>(</span>integer<span>)</span> <span>3</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange myList <span>0</span> <span>1</span> <span># 查看对应下标的list列表， 0 为 start,1为 end</span>\n<span>1</span><span>)</span> <span>\"value1\"</span>\n<span>2</span><span>)</span> <span>\"value2\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> lrange myList <span>0</span> -1 <span># 查看列表中的所有元素，-1表示倒数第一</span>\n<span>1</span><span>)</span> <span>\"value1\"</span>\n<span>2</span><span>)</span> <span>\"value2\"</span>\n<span>3</span><span>)</span> <span>\"value3\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>通过 <code>lrange</code> 命令，你可以基于 list 实现分页查询，性能非常高！</p>\n<p><strong>通过 <code>llen</code> 查看链表长度：</strong></p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> llen myList\n<span>(</span>integer<span>)</span> <span>3</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"hash\"> hash</h4>\n<ol>\n<li><strong>介绍</strong> ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</li>\n<li><strong>常用命令：</strong> <code>hset,hmset,hexists,hget,hgetall,hkeys,hvals</code> 等。</li>\n<li><strong>应用场景:</strong> 系统中对象数据的存储。</li>\n</ol>\n<p>下面我们简单看看它的使用！</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> hmset userInfoKey name <span>\"guide\"</span> description <span>\"dev\"</span> age <span>\"24\"</span>\nOK\n<span>127.0</span>.0.1:637<span><span>9</span>></span> hexists userInfoKey name <span># 查看 key 对应的 value中指定的字段是否存在。</span>\n<span>(</span>integer<span>)</span> <span>1</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> hget userInfoKey name <span># 获取存储在哈希表中指定字段的值。</span>\n<span>\"guide\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> hget userInfoKey age\n<span>\"24\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> hgetall userInfoKey <span># 获取在哈希表中指定 key 的所有字段和值</span>\n<span>1</span><span>)</span> <span>\"name\"</span>\n<span>2</span><span>)</span> <span>\"guide\"</span>\n<span>3</span><span>)</span> <span>\"description\"</span>\n<span>4</span><span>)</span> <span>\"dev\"</span>\n<span>5</span><span>)</span> <span>\"age\"</span>\n<span>6</span><span>)</span> <span>\"24\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> hkeys userInfoKey <span># 获取 key 列表</span>\n<span>1</span><span>)</span> <span>\"name\"</span>\n<span>2</span><span>)</span> <span>\"description\"</span>\n<span>3</span><span>)</span> <span>\"age\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> hvals userInfoKey <span># 获取 value 列表</span>\n<span>1</span><span>)</span> <span>\"guide\"</span>\n<span>2</span><span>)</span> <span>\"dev\"</span>\n<span>3</span><span>)</span> <span>\"24\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> hset userInfoKey name <span>\"GuideGeGe\"</span> <span># 修改某个字段对应的值</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> hget userInfoKey name\n<span>\"GuideGeGe\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h4 id=\"set\"> set</h4>\n<ol>\n<li><strong>介绍 ：</strong> set 类似于 Java 中的 <code>HashSet</code> 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</li>\n<li><strong>常用命令：</strong> <code>sadd,spop,smembers,sismember,scard,sinterstore,sunion</code> 等。</li>\n<li><strong>应用场景:</strong> 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</li>\n</ol>\n<p>下面我们简单看看它的使用！</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> sadd mySet value1 value2 <span># 添加元素进去</span>\n<span>(</span>integer<span>)</span> <span>2</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> sadd mySet value1 <span># 不允许有重复元素</span>\n<span>(</span>integer<span>)</span> <span>0</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> smembers mySet <span># 查看 set 中所有的元素</span>\n<span>1</span><span>)</span> <span>\"value1\"</span>\n<span>2</span><span>)</span> <span>\"value2\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> scard mySet <span># 查看 set 的长度</span>\n<span>(</span>integer<span>)</span> <span>2</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> sismember mySet value1 <span># 检查某个元素是否存在set 中，只能接收单个元素</span>\n<span>(</span>integer<span>)</span> <span>1</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> sadd mySet2 value2 value3\n<span>(</span>integer<span>)</span> <span>2</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> sinterstore mySet3 mySet mySet2 <span># 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span>\n<span>(</span>integer<span>)</span> <span>1</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> smembers mySet3\n<span>1</span><span>)</span> <span>\"value2\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id=\"sorted-set\"> sorted set</h4>\n<ol>\n<li><strong>介绍：</strong> 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。</li>\n<li><strong>常用命令：</strong> <code>zadd,zcard,zscore,zrange,zrevrange,zrem</code> 等。</li>\n<li><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</li>\n</ol>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> zadd myZset <span>3.0</span> value1 <span># 添加元素到 sorted set 中 3.0 为权重</span>\n<span>(</span>integer<span>)</span> <span>1</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> zadd myZset <span>2.0</span> value2 <span>1.0</span> value3 <span># 一次添加多个元素</span>\n<span>(</span>integer<span>)</span> <span>2</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> zcard myZset <span># 查看 sorted set 中的元素数量</span>\n<span>(</span>integer<span>)</span> <span>3</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> zscore myZset value1 <span># 查看某个 value 的权重</span>\n<span>\"3\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> zrange  myZset <span>0</span> -1 <span># 顺序输出某个范围区间的元素，0 -1 表示输出所有元素</span>\n<span>1</span><span>)</span> <span>\"value3\"</span>\n<span>2</span><span>)</span> <span>\"value2\"</span>\n<span>3</span><span>)</span> <span>\"value1\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> zrange  myZset <span>0</span> <span>1</span> <span># 顺序输出某个范围区间的元素，0 为 start  1 为 stop</span>\n<span>1</span><span>)</span> <span>\"value3\"</span>\n<span>2</span><span>)</span> <span>\"value2\"</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> zrevrange  myZset <span>0</span> <span>1</span> <span># 逆序输出某个范围区间的元素，0 为 start  1 为 stop</span>\n<span>1</span><span>)</span> <span>\"value1\"</span>\n<span>2</span><span>)</span> <span>\"value2\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id=\"bitmap\"> bitmap</h4>\n<ol>\n<li><strong>介绍：</strong> bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 bitmap 本身会极大的节省储存空间。</li>\n<li><strong>常用命令：</strong> <code>setbit</code> 、<code>getbit</code> 、<code>bitcount</code>、<code>bitop</code></li>\n<li><strong>应用场景：</strong> 适合需要保存状态信息（比如是否签到、是否登录...）并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li>\n</ol>\n<div><pre><code><span># SETBIT 会返回之前位的值（默认是 0）这里会生成 7 个位</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit mykey <span>7</span> <span>1</span>\n<span>(</span>integer<span>)</span> <span>0</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit mykey <span>7</span> <span>0</span>\n<span>(</span>integer<span>)</span> <span>1</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> getbit mykey <span>7</span>\n<span>(</span>integer<span>)</span> <span>0</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit mykey <span>6</span> <span>1</span>\n<span>(</span>integer<span>)</span> <span>0</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit mykey <span>8</span> <span>1</span>\n<span>(</span>integer<span>)</span> <span>0</span>\n<span># 通过 bitcount 统计被被设置为 1 的位的数量。</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> bitcount mykey\n<span>(</span>integer<span>)</span> <span>2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>针对上面提到的一些场景，这里进行进一步说明。</p>\n<p><strong>使用场景一：用户行为分析</strong>\n很多网站为了分析你的喜好，需要研究你点赞过的内容。</p>\n<div><pre><code><span># 记录你喜欢过 001 号小姐姐</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit beauty_girl_001 uid <span>1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><strong>使用场景二：统计活跃用户</strong></p>\n<p>使用时间作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1</p>\n<p>那么我该如何计算某几天/月/年的活跃用户呢(暂且约定，统计时间内只要有一天在线就称为活跃)，有请下一个 redis 的命令</p>\n<div><pre><code><span># 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</span>\n<span># BITOP 命令支持 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种参数</span>\nBITOP operation destkey key <span>[</span>key <span>..</span>.<span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>初始化数据：</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> setbit <span>20210308</span> <span>1</span> <span>1</span>\n<span>(</span>integer<span>)</span> <span>0</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit <span>20210308</span> <span>2</span> <span>1</span>\n<span>(</span>integer<span>)</span> <span>0</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> setbit <span>20210309</span> <span>1</span> <span>1</span>\n<span>(</span>integer<span>)</span> <span>0</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>统计 20210308~20210309 总活跃用户数: 1</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> bitop and desk1 <span>20210308</span> <span>20210309</span>\n<span>(</span>integer<span>)</span> <span>1</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> bitcount desk1\n<span>(</span>integer<span>)</span> <span>1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>统计 20210308~20210309 在线活跃用户数: 2</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> bitop or desk2 <span>20210308</span> <span>20210309</span>\n<span>(</span>integer<span>)</span> <span>1</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> bitcount desk2\n<span>(</span>integer<span>)</span> <span>2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>使用场景三：用户在线状态</strong></p>\n<p>对于获取或者统计用户在线状态，使用 bitmap 是一个节约空间且效率又高的一种方法。</p>\n<p>只需要一个 key，然后用户 ID 为 offset，如果在线就设置为 1，不在线就设置为 0。</p>\n<h3 id=\"redis-单线程模型详解\"> Redis 单线程模型详解</h3>\n<p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p>\n<p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>\n<p>Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p>\n<p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p>\n<p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：1. 文件事件; 2. 时间事件。</p>\n<p>时间事件不需要多花时间了解，我们接触最多的还是 <strong>文件事件</strong>（客户端进行读取写入等操作，涉及一系列网络通信）。</p>\n<p>《Redis 设计与实现》有一段话是如是介绍文件事件的，我觉得写得挺不错。</p>\n<blockquote>\n<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>\n<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>\n<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>\n</blockquote>\n<p>可以看出，文件事件处理器（file event handler）主要是包含 4 个部分：</p>\n<ul>\n<li>多个 socket（客户端连接）</li>\n<li>IO 多路复用程序（支持多个客户端连接的关键）</li>\n<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>\n<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>\n</ul>\n<p><img src=\"./images/redis-all/redis事件处理器.png\" alt=\"\" /></p>\n<p style=\"text-align:right; font-size:14px; color:gray\">《Redis设计与实现：12章》</p>\n<h3 id=\"redis-没有使用多线程-为什么不使用多线程\"> Redis 没有使用多线程？为什么不使用多线程？</h3>\n<p>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p>\n<p><img src=\"./images/redis-all/redis4.0-more-thread.png\" alt=\"redis4.0 more thread\" /></p>\n<p>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。</p>\n<p>大体上来说，<strong>Redis 6.0 之前主要还是单线程处理。</strong></p>\n<p><strong>那，Redis6.0 之前 为什么不使用多线程？</strong></p>\n<p>我觉得主要原因有下面 3 个：</p>\n<ol>\n<li>单线程编程容易并且更容易维护；</li>\n<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>\n<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>\n</ol>\n<h3 id=\"redis6-0-之后为何引入了多线程\"> Redis6.0 之后为何引入了多线程？</h3>\n<p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>\n<p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>\n<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 <code>redis.conf</code> ：</p>\n<div><pre><code>io-threads-do-reads <span>yes</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 <code>redis.conf</code> :</p>\n<div><pre><code>io-threads <span>4</span> <span>#官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>推荐阅读：</p>\n<ol>\n<li><a href=\"https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 6.0 新特性-多线程连环 13 问！</a></li>\n<li><a href=\"https://draveness.me/whys-the-design-redis-single-thread/\" target=\"_blank\" rel=\"noopener noreferrer\">为什么 Redis 选择单线程模型</a></li>\n</ol>\n<h3 id=\"redis-给缓存数据设置过期时间有啥用\"> Redis 给缓存数据设置过期时间有啥用？</h3>\n<p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p>\n<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p>\n<p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p>\n<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> exp key <span>60</span> <span># 数据在 60s 后过期</span>\n<span>(</span>integer<span>)</span> <span>1</span>\n<span>127.0</span>.0.1:637<span><span>9</span>></span> setex key <span>60</span> value <span># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span>\nOK\n<span>127.0</span>.0.1:637<span><span>9</span>></span> ttl key <span># 查看数据还有多久过期</span>\n<span>(</span>integer<span>)</span> <span>56</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>注意：**Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。 **</p>\n<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>\n<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>\n<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>\n<h3 id=\"redis-是如何判断数据是否过期的呢\"> Redis 是如何判断数据是否过期的呢？</h3>\n<p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>\n<p><img src=\"./images/redis-all/redis过期时间.png\" alt=\"redis过期字典\" /></p>\n<p>过期字典是存储在 redisDb 这个结构里的：</p>\n<div><pre><code><span>typedef</span> <span>struct</span> <span>redisDb</span> <span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n\n    dict <span>*</span>dict<span>;</span>     <span>//数据库键空间,保存着数据库中所有键值对</span>\n    dict <span>*</span>expires   <span>// 过期字典,保存着键的过期时间</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span> redisDb<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"过期的数据的删除策略了解么\"> 过期的数据的删除策略了解么？</h3>\n<p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p>\n<p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>\n<ol>\n<li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>\n<li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>\n</ol>\n<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p>\n<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>\n<p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p>\n<h3 id=\"redis-内存淘汰机制了解么\"> Redis 内存淘汰机制了解么？</h3>\n<blockquote>\n<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p>\n</blockquote>\n<p>Redis 提供 6 种数据淘汰策略：</p>\n<ol>\n<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>\n<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>\n<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>\n<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>\n<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>\n<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>\n</ol>\n<p>4.0 版本后增加以下两种：</p>\n<ol start=\"7\">\n<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li>\n<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>\n</ol>\n<h3 id=\"redis-持久化机制-怎么保证-redis-挂掉之后再重启数据可以进行恢复\"> Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)</h3>\n<p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>\n<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p>\n<p><strong>快照（snapshotting）持久化（RDB）</strong></p>\n<p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>\n<p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p>\n<div><pre><code>save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n\nsave 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n\nsave 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>AOF（append-only file）持久化</strong></p>\n<p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p>\n<div><pre><code>appendonly yes\n</code></pre>\n<div><span>1</span><br></div></div><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>\n<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>\n<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>\n<div><pre><code>appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度\nappendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘\nappendfsync no        #让操作系统决定何时进行同步\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>\n<p><strong>相关 issue</strong> ：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/783\" target=\"_blank\" rel=\"noopener noreferrer\">783：Redis 的 AOF 方式</a></p>\n<p><strong>拓展：Redis 4.0 对于持久化机制的优化</strong></p>\n<p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>\n<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>\n<p>官方文档地址：https://redis.io/topics/persistence</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/javaguide-tech/image-host-github-stars-01@main/webfunny_monitor/image-20210807145107290.png\" alt=\"\" /></p>\n<p><strong>补充内容：AOF 重写</strong></p>\n<p>AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>\n<p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p>\n<p>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>\n<h3 id=\"redis-事务\"> Redis 事务</h3>\n<p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p>\n<div><pre><code><span>></span> MULTI\nOK\n<span>></span> SET <span>USER</span> <span>\"Guide哥\"</span>\nQUEUED\n<span>></span> GET <span>USER</span>\nQUEUED\n<span>></span> EXEC\n<span>1</span><span>)</span> OK\n<span>2</span><span>)</span> <span>\"Guide哥\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>使用 <a href=\"https://redis.io/commands/multi\" target=\"_blank\" rel=\"noopener noreferrer\"><code>MULTI</code></a> 命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href=\"https://redis.io/commands/exec\" target=\"_blank\" rel=\"noopener noreferrer\"><code>EXEC</code></a> 命令将执行所有命令。</p>\n<p>这个过程是这样的：</p>\n<ol>\n<li>开始事务（<code>MULTI</code>）。</li>\n<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</li>\n<li>执行事务(<code>EXEC</code>)。</li>\n</ol>\n<p>你也可以通过 <a href=\"https://redis.io/commands/discard\" target=\"_blank\" rel=\"noopener noreferrer\"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>\n<div><pre><code><span>></span> MULTI\nOK\n<span>></span> SET <span>USER</span> <span>\"Guide哥\"</span>\nQUEUED\n<span>></span> GET <span>USER</span>\nQUEUED\n<span>></span> DISCARD\nOK\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><a href=\"https://redis.io/commands/watch\" target=\"_blank\" rel=\"noopener noreferrer\"><code>WATCH</code></a> 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。</p>\n<div><pre><code><span>></span> WATCH <span>USER</span>\nOK\n<span>></span> MULTI\n<span>></span> SET <span>USER</span> <span>\"Guide哥\"</span>\nOK\n<span>></span> GET <span>USER</span>\nGuide哥\n<span>></span> EXEC\nERR EXEC without MULTI\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Redis 官网相关介绍 <a href=\"https://redis.io/topics/transactions\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/topics/transactions</a> 如下：</p>\n<p><img src=\"./images/redis-all/redis事务.png\" alt=\"redis事务\" /></p>\n<p>但是，Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： <strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p>\n<ol>\n<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>\n<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>\n<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>\n</ol>\n<p><strong>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。</strong></p>\n<p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>\n<p><img src=\"./images/redis-all/redis-rollBack.png\" alt=\"redis roll back\" /></p>\n<p>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>\n<p><strong>相关 issue</strong> :</p>\n<ul>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/issues/452\" target=\"_blank\" rel=\"noopener noreferrer\">issue452: 关于 Redis 事务不满足原子性的问题</a> 。</li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/issues/491\" target=\"_blank\" rel=\"noopener noreferrer\">Issue491:关于 redis 没有事务回滚？</a></li>\n</ul>\n<h3 id=\"缓存穿透\"> 缓存穿透</h3>\n<h4 id=\"什么是缓存穿透\"> 什么是缓存穿透？</h4>\n<p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>\n<h4 id=\"缓存穿透情况的处理流程是怎样的\"> 缓存穿透情况的处理流程是怎样的？</h4>\n<p>如下图所示，用户的请求最终都要跑到数据库中查询一遍。</p>\n<p><img src=\"./images/redis-all/缓存穿透情况.png\" alt=\"缓存穿透情况\" /></p>\n<h4 id=\"有哪些解决办法\"> 有哪些解决办法？</h4>\n<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>\n<p><strong>1）缓存无效 key</strong></p>\n<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>\n<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p>\n<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>\n<div><pre><code><span>public</span> <span>Object</span> <span>getObjectInclNullById</span><span>(</span><span>Integer</span> id<span>)</span> <span>{</span>\n    <span>// 从缓存中获取数据</span>\n    <span>Object</span> cacheValue <span>=</span> cache<span>.</span><span>get</span><span>(</span>id<span>)</span><span>;</span>\n    <span>// 缓存为空</span>\n    <span>if</span> <span>(</span>cacheValue <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        <span>// 从数据库中获取</span>\n        <span>Object</span> storageValue <span>=</span> storage<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>\n        <span>// 缓存空对象</span>\n        cache<span>.</span><span>set</span><span>(</span>key<span>,</span> storageValue<span>)</span><span>;</span>\n        <span>// 如果存储数据为空，需要设置一个过期时间(300秒)</span>\n        <span>if</span> <span>(</span>storageValue <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>// 必须设置过期时间，否则有被攻击的风险</span>\n            cache<span>.</span><span>expire</span><span>(</span>key<span>,</span> <span>60</span> <span>*</span> <span>5</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> storageValue<span>;</span>\n    <span>}</span>\n    <span>return</span> cacheValue<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>2）布隆过滤器</strong></p>\n<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>\n<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>\n<p>加入布隆过滤器之后的缓存处理流程图如下。</p>\n<p><img src=\"./images/redis-all/加入布隆过滤器后的缓存处理流程.png\" alt=\"image\" /></p>\n<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>\n<p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p>\n<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>\n<ol>\n<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>\n<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>\n</ol>\n<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>\n<ol>\n<li>对给定元素再次进行相同的哈希计算；</li>\n<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>\n</ol>\n<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>\n<p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/cs-basics/data-structure/bloom-filter.md\" target=\"_blank\" rel=\"noopener noreferrer\">《不了解布隆过滤器？一文给你整的明明白白！》</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p>\n<h3 id=\"缓存雪崩\"> 缓存雪崩</h3>\n<h4 id=\"什么是缓存雪崩\"> 什么是缓存雪崩？</h4>\n<p>我发现缓存雪崩这名字起的有点意思，哈哈。</p>\n<p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>\n<p>举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p>\n<p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong> 这样的情况，有下面几种解决办法：</p>\n<p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p>\n<h4 id=\"有哪些解决办法-2\"> 有哪些解决办法？</h4>\n<p><strong>针对 Redis 服务不可用的情况：</strong></p>\n<ol>\n<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>\n<li>限流，避免同时处理大量的请求。</li>\n</ol>\n<p><strong>针对热点缓存失效的情况：</strong></p>\n<ol>\n<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>\n<li>缓存永不失效。</li>\n</ol>\n<h3 id=\"如何保证缓存和数据库数据的一致性\"> 如何保证缓存和数据库数据的一致性？</h3>\n<p>细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p>\n<p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p>\n<p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>\n<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>\n<ol>\n<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>\n<li><strong>增加 cache 更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>\n</ol>\n<h3 id=\"参考\"> 参考</h3>\n<ul>\n<li>《Redis 开发与运维》</li>\n<li>《Redis 设计与实现》</li>\n<li>Redis 命令总结：http://Redisdoc.com/string/set.html</li>\n<li>通俗易懂的 Redis 数据结构基础教程：<a href=\"https://juejin.im/post/5b53ee7e5188251aaa2d2e16\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.im/post/5b53ee7e5188251aaa2d2e16</a></li>\n<li>WHY Redis choose single thread (vs multi threads): <a href=\"https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153\" target=\"_blank\" rel=\"noopener noreferrer\">https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153</a></li>\n</ul>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "字符集",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/%E5%AD%97%E7%AC%A6%E9%9B%86/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/database/%E5%AD%97%E7%AC%A6%E9%9B%86/",
      "content_html": "<p>MySQL 字符编码集中有两套 UTF-8 编码实现：<strong><code>utf8</code></strong> 和 <strong><code>utf8mb4</code></strong>。</p>\n<p>如果使用 <strong><code>utf8</code></strong>  的话，存储emoji 符号和一些比较复杂的汉字、繁体字就会出错。</p>\n<p>为什么会这样呢？这篇文章可以从源头给你解答。</p>\n<h2 id=\"何为字符集\"> 何为字符集？</h2>\n<p>字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 <strong>字符集</strong> 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。</p>\n<p><strong>计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？</strong></p>\n<p>我们要将这些字符和二级制的数据一一对应起来，比如说字符“a”对应“01100001”，反之，“01100001”对应 “a”。我们将字符对应二进制数据的过程称为&quot;<strong>字符编码</strong>&quot;，反之，二进制数据解析成字符的过程称为“<strong>字符解码</strong>”。</p>\n<h2 id=\"有哪些常见的字符集\"> 有哪些常见的字符集？</h2>\n<p>常见的字符集有 ASCII、GB2312、GBK、UTF-8......。</p>\n<p>不同的字符集的主要区别在于：</p>\n<ul>\n<li>可以表示的字符范围</li>\n<li>编码方式</li>\n</ul>\n<h3 id=\"ascii\"> ASCII</h3>\n<p><strong>ASCII</strong> (<strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange，美国信息交换标准代码) 是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。</p>\n<p><strong>为什么 ASCII 字符集没有考虑到中文等其他字符呢？</strong> 因为计算机是美国人发明的，当时，计算机的发展还处于比较雏形的时代，还未在其他国家大规模使用。因此，美国发布 ASCII 字符集的时候没有考虑兼容其他国家的语言。</p>\n<p>ASCII 字符集至今为止共定义了 128 个字符，其中有 33 个控制字符（比如回车、删除）无法显示。</p>\n<p>一个 ASCII 码长度是一个字节也就是 8 个 bit，比如“a”对应的 ASCII 码是“01100001”。不过，最高位是 0 仅仅作为校验位，其余 7 位使用 0 和 1 进行组合，所以，ASCII 字符集可以定义 128（2^7）个字符。</p>\n<p>由于，ASCII 码可以表示的字符实在是太少了。后来，人们对其进行了扩展得到了 <strong>ASCII 扩展字符集</strong> 。ASCII 扩展字符集使用 8 位（bits）表示一个字符，所以，ASCII 扩展字符集可以定义 256（2^8）个字符。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c1c6375d08ca268690cef2b13591a5b4.png\" alt=\"ASCII字符编码\" /></p>\n<h3 id=\"gb2312\"> GB2312</h3>\n<p>我们上面说了，ASCII 字符集是一种现代美国英语适用的字符集。因此，很多国家都捣鼓了一个适合自己国家语言的字符集。</p>\n<p>GB2312 字符集是一种对汉字比较友好的字符集，共收录 6700 多个汉字，基本涵盖了绝大部分常用汉字。不过，GB2312 字符集不支持绝大部分的生僻字和繁体字。</p>\n<p>对于英语字符，GB2312 编码和 ASCII 码是相同的，1 字节编码即可。对于非英字符，需要 2 字节编码。</p>\n<h3 id=\"gbk\"> GBK</h3>\n<p>GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 GB2312 字符集，共收录了 20000 多个汉字。</p>\n<p>GBK 中 K 是汉语拼音 Kuo Zhan（扩展）中的“Kuo”的首字母。</p>\n<h3 id=\"gb18030\"> GB18030</h3>\n<p>GB18030 完全兼容 GB2312 和 GBK 字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字 70000 多个。</p>\n<h3 id=\"big5\"> BIG5</h3>\n<p>BIG5 主要针对的是繁体中文，收录了 13000 多个汉字。</p>\n<h3 id=\"unicode-utf-8编码\"> Unicode &amp; UTF-8编码</h3>\n<p>为了更加适合本国语言，诞生了很多种字符集。</p>\n<p>我们上面也说了不同的字符集可以表示的字符范围以及编码规则存在差异。这就导致了一个非常严重的问题：<strong>使用错误的编码方式查看一个包含字符的文件就会产生乱码现象。</strong></p>\n<p>就比如说你使用 UTF-8 编码方式打开 GB2312 编码格式的文件就会出现乱码。示例：“牛”这个汉字 GB2312 编码后的十六进制数值为 “C5A3”，而 “C5A3” 用 UTF-8 解码之后得到的却是 “ţ”。</p>\n<p>你可以通过这个网站在线进行编码和解码：https://www.haomeili.net/HanZi/ZiFuBianMaZhuanHuan</p>\n<p><img src=\"https://img-blog.csdnimg.cn/836c49b117ee4408871b0020b74c991d.png\" alt=\"\" /></p>\n<p>这样我们就搞懂了乱码的本质： <strong>编码和解码时用了不同或者不兼容的字符集</strong> 。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/a8808cbabeea49caa3af27d314fa3c02-1.jpg\" alt=\"\" /></p>\n<p>为了解决这个问题，人们就想：“如果我们能够有一种字符集将世界上所有的字符都纳入其中就好了！”。</p>\n<p>然后，<strong>Unicode</strong> 带着这个使命诞生了。</p>\n<p>Unicode 字符集中包含了世界上几乎所有已知的字符。不过，Unicode 字符集并没有规定如何存储这些字符（也就是如何使用二进制数据表示这些字符）。</p>\n<p>然后，就有了 <strong>UTF-8</strong>（<strong>8</strong>-bit <strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat）。类似的还有 UTF-16、 UTF-32。</p>\n<p>UTF-8 使用 1 到 4 个字节为每个字符编码， UTF-16 使用 2 或 4 个字节为每个字符编码，UTF-32 固定位 4 个字节为每个字符编码。</p>\n<p>UTF-8 可以根据不同的符号自动选择编码的长短，像英文字符只需要 1 个字节就够了，这一点 ASCII 字符集一样 。因此，对于英语字符，UTF-8 编码和 ASCII 码是相同的。</p>\n<p>UTF-32 的规则最简单，不过缺陷也比较明显，对于英文字母这类字符消耗的空间是 UTF-8 的 4 倍之多。</p>\n<p><strong>UTF-8</strong> 是目前使用最广的一种字符编码，。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/1280px-Utf8webgrowth.svg.png\" alt=\"\" /></p>\n<h2 id=\"mysql-字符集\"> MySQL 字符集</h2>\n<p>MySQL 支持很多种字符编码的方式，比如 UTF-8、GB2312、GBK、BIG5。</p>\n<p>你可以通过 <code>SHOW CHARSET</code> 命令来查看。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20211008164229671.png\" alt=\"\" /></p>\n<p>通常情况下，我们建议使用 UTF-8 作为默认的字符编码方式。</p>\n<p>不过，这里有一个小坑。</p>\n<p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p>\n<ul>\n<li><strong><code>utf8</code></strong> ： <code>utf8</code>编码只支持<code>1-3</code>个字节 。 在 <code>utf8</code> 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li>\n<li><strong><code>utf8mb4</code></strong> ： UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li>\n</ul>\n<p><strong>为什么有两套 UTF-8 编码实现呢？</strong> 原因如下：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20211008164542347.png\" alt=\"\" /></p>\n<p>因此，如果你需要存储<code>emoji</code>类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为<code>utf8mb4</code> 而不是<code>utf8</code> ，要不然存储的时候就会报错了。</p>\n<p>演示一下吧！（环境：MySQL 5.7+）</p>\n<p>建表语句如下，我们指定数据库 CHARSET 为 <code>utf8</code> 。</p>\n<div><pre><code><span>CREATE</span> <span>TABLE</span> <span>`</span><span>user</span><span>`</span> <span>(</span>\n  <span>`</span>id<span>`</span> <span>varchar</span><span>(</span><span>66</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>NOT</span> <span>NULL</span><span>,</span>\n  <span>`</span>name<span>`</span> <span>varchar</span><span>(</span><span>33</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>NOT</span> <span>NULL</span><span>,</span>\n  <span>`</span>phone<span>`</span> <span>varchar</span><span>(</span><span>33</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>DEFAULT</span> <span>NULL</span><span>,</span>\n  <span>`</span>password<span>`</span> <span>varchar</span><span>(</span><span>100</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8mb4 <span>DEFAULT</span> <span>NULL</span>\n<span>)</span> <span>ENGINE</span><span>=</span><span>InnoDB</span> <span>DEFAULT</span> <span>CHARSET</span><span>=</span>utf8<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>当我们执行下面的 insert 语句插入数据到数据库时，果然报错！</p>\n<div><pre><code><span>INSERT</span> <span>INTO</span> <span>`</span><span>user</span><span>`</span> <span>(</span><span>`</span>id<span>`</span><span>,</span> <span>`</span>name<span>`</span><span>,</span> <span>`</span>phone<span>`</span><span>,</span> <span>`</span>password<span>`</span><span>)</span>\n<span>VALUES</span>\n\t<span>(</span><span>'A00003'</span><span>,</span> <span>'guide哥😘😘😘'</span><span>,</span> <span>'181631312312'</span><span>,</span> <span>'123456'</span><span>)</span><span>;</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>报错信息如下：</p>\n<div><pre><code>Incorrect string value: &#39;\\xF0\\x9F\\x98\\x98\\xF0\\x9F...&#39; for column &#39;name&#39; at row 1\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"参考\"> 参考</h2>\n<ul>\n<li>字符集和字符编码（Charset &amp; Encoding）： https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html</li>\n<li>十分钟搞清字符集和字符编码：http://cenalulu.github.io/linux/character-encoding/</li>\n<li>Unicode-维基百科：https://zh.wikipedia.org/wiki/Unicode</li>\n<li>GB2312-维基百科：https://zh.wikipedia.org/wiki/GB_2312</li>\n<li>UTF-8-维基百科：https://zh.wikipedia.org/wiki/UTF-8</li>\n<li>GB18030-维基百科: https://zh.wikipedia.org/wiki/GB_18030</li>\n</ul>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/c1c6375d08ca268690cef2b13591a5b4.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "IO模型详解",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/basis/IO%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/basis/IO%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/",
      "content_html": "<p>IO 模型这块确实挺难理解的，需要太多计算机底层知识。写这篇文章用了挺久，就非常希望能把我所知道的讲出来吧!希望朋友们能有收获！为了写这篇文章，还翻看了一下《UNIX 网络编程》这本书，太难了，我滴乖乖！心痛~</p>\n<p><em>个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！</em></p>\n<h2 id=\"前言\"> 前言</h2>\n<p>I/O 一直是很多小伙伴难以理解的一个知识点，这篇文章我会将我所理解的 I/O 讲给你听，希望可以对你有所帮助。</p>\n<h2 id=\"i-o\"> I/O</h2>\n<h3 id=\"何为-i-o\"> 何为 I/O?</h3>\n<p>I/O（<strong>I</strong>nput/<strong>O</strong>utpu） 即<strong>输入／输出</strong> 。</p>\n<p><strong>我们先从计算机结构的角度来解读一下 I/O。</strong></p>\n<p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190624122126398.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcy1jbG91ZC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70\" alt=\"冯诺依曼体系结构\" /></p>\n<p>输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。</p>\n<p>输入设备向计算机输入数据，输出设备接收计算机输出的数据。</p>\n<p><strong>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。</strong></p>\n<p><strong>我们再先从应用程序的角度来解读一下 I/O。</strong></p>\n<p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p>\n<p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</p>\n<p>并且，用户空间的程序不能直接访问内核空间。</p>\n<p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p>\n<p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p>\n<p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。</p>\n<p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p>\n<p>当应用程序发起 I/O 调用后，会经历两个步骤：</p>\n<ol>\n<li>内核等待 I/O 设备准备好数据</li>\n<li>内核将数据从内核空间拷贝到用户空间。</li>\n</ol>\n<h3 id=\"有哪些常见的-io-模型\"> 有哪些常见的 IO 模型?</h3>\n<p>UNIX 系统下， IO 模型一共有 5 种： <strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong>。</p>\n<p>这也是我们经常提到的 5 种 IO 模型。</p>\n<h2 id=\"java-中-3-种常见-io-模型\"> Java 中 3 种常见 IO 模型</h2>\n<h3 id=\"bio-blocking-i-o\"> BIO (Blocking I/O)</h3>\n<p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p>\n<p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image\" alt=\"图源：《深入拆解Tomcat &amp; Jetty》\" /></p>\n<p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>\n<h3 id=\"nio-non-blocking-new-i-o\"> NIO (Non-blocking/New I/O)</h3>\n<p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>\n<p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p>\n<p>跟着我的思路往下看看，相信你会得到答案！</p>\n<p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image\" alt=\"图源：《深入拆解Tomcat &amp; Jetty》\" /></p>\n<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>\n<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>\n<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>\n<p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p>\n<blockquote>\n<p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持</p>\n<ul>\n<li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li>\n<li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li>\n</ul>\n</blockquote>\n<p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p>\n<p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f483f2437ce4ecdb180134270a00144~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<h3 id=\"aio-asynchronous-i-o\"> AIO (Asynchronous I/O)</h3>\n<p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p>\n<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p>\n<p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p>\n<p><img src=\"https://images.xiaozhuanlan.com/photo/2020/33b193457c928ae02217480f994814b6.png\" alt=\"\" /></p>\n<h2 id=\"参考\"> 参考</h2>\n<ul>\n<li>《深入拆解 Tomcat &amp; Jetty》</li>\n<li>如何完成一次 IO：<a href=\"https://llc687.top/post/%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E4%B8%80%E6%AC%A1-io/\" target=\"_blank\" rel=\"noopener noreferrer\">https://llc687.top/post/如何完成一次-io/</a></li>\n<li>程序员应该这样理解 IO：<a href=\"https://www.jianshu.com/p/fa7bdc4f3de7\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/fa7bdc4f3de7</a></li>\n<li>10 分钟看懂， Java NIO 底层原理：https://www.cnblogs.com/crazymakercircle/p/10225159.html</li>\n<li>IO 模型知多少 | 理论篇：https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html</li>\n<li>《UNIX 网络编程 卷 1；套接字联网 API 》6.2 节 IO 模型</li>\n</ul>\n",
      "image": "https://img-blog.csdnimg.cn/20190624122126398.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcy1jbG91ZC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "代理详解！静态代理+JDK/CGLIB 动态代理实战",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/basis/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/basis/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/",
      "content_html": "<h2 id=\"_1-代理模式\"> 1. 代理模式</h2>\n<p>代理模式是一种比较好理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>\n<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>\n<p>举个例子：你找了小红来帮你问话，小红就可以看作是代理你的代理对象，代理的行为（方法）是问话。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/1*DjWCgTFm-xqbhbNQVsaWQw.png\" alt=\"Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium\" /></p>\n<p style=\"text-align:right;font-size:13px;color:gray\">https://medium.com/@mithunsasidharan/understanding-the-proxy-design-pattern-5e63fe38052a</p>\n<p>代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。</p>\n<h2 id=\"_2-静态代理\"> 2. 静态代理</h2>\n<p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（<em>后面会具体演示代码</em>），非常不灵活（<em>比如接口一旦新增加方法，目标对象和代理对象都要进行修改</em>）且麻烦(<em>需要对每个目标类都单独写一个代理类</em>)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>\n<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p>\n<p>静态代理实现步骤:</p>\n<ol>\n<li>定义一个接口及其实现类；</li>\n<li>创建一个代理类同样实现这个接口</li>\n<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>\n</ol>\n<p>下面通过代码展示！</p>\n<p><strong>1.定义发送短信的接口</strong></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>SmsService</span> <span>{</span>\n    <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>2.实现发送短信的接口</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>SmsServiceImpl</span> <span>implements</span> <span>SmsService</span> <span>{</span>\n    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"send message:\"</span> <span>+</span> message<span>)</span><span>;</span>\n        <span>return</span> message<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>SmsProxy</span> <span>implements</span> <span>SmsService</span> <span>{</span>\n\n    <span>private</span> <span>final</span> <span>SmsService</span> smsService<span>;</span>\n\n    <span>public</span> <span>SmsProxy</span><span>(</span><span>SmsService</span> smsService<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>smsService <span>=</span> smsService<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n        <span>//调用方法之前，我们可以添加自己的操作</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before method send()\"</span><span>)</span><span>;</span>\n        smsService<span>.</span><span>send</span><span>(</span>message<span>)</span><span>;</span>\n        <span>//调用方法之后，我们同样可以添加自己的操作</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after method send()\"</span><span>)</span><span>;</span>\n        <span>return</span> <span>null</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>4.实际使用</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>SmsService</span> smsService <span>=</span> <span>new</span> <span>SmsServiceImpl</span><span>(</span><span>)</span><span>;</span>\n        <span>SmsProxy</span> smsProxy <span>=</span> <span>new</span> <span>SmsProxy</span><span>(</span>smsService<span>)</span><span>;</span>\n        smsProxy<span>.</span><span>send</span><span>(</span><span>\"java\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>\n<div><pre><code>before method send<span>(</span><span>)</span>\nsend message:java\nafter method send<span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p>\n<h2 id=\"_3-动态代理\"> 3. 动态代理</h2>\n<p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p>\n<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>\n<p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。</p>\n<p><strong>动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p>\n<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>\n<p><a href=\"https://github.com/Snailclimb/guide-rpc-framework\" target=\"_blank\" rel=\"noopener noreferrer\">guide-rpc-framework</a> 使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。</p>\n<p>另外，虽然 <a href=\"https://github.com/Snailclimb/guide-rpc-framework\" target=\"_blank\" rel=\"noopener noreferrer\">guide-rpc-framework</a> 没有用到 <strong>CGLIB 动态代理</strong> ，我们这里还是简单介绍一下其使用以及和<strong>JDK 动态代理</strong>的对比。</p>\n<h3 id=\"_3-1-jdk-动态代理机制\"> 3.1. JDK 动态代理机制</h3>\n<h4 id=\"_3-1-1-介绍\"> 3.1.1. 介绍</h4>\n<p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>\n<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>Object</span> <span>newProxyInstance</span><span>(</span><span>ClassLoader</span> loader<span>,</span>\n                                          <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> interfaces<span>,</span>\n                                          <span>InvocationHandler</span> h<span>)</span>\n        <span>throws</span> <span>IllegalArgumentException</span>\n    <span>{</span>\n        <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这个方法一共有 3 个参数：</p>\n<ol>\n<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>\n<li><strong>interfaces</strong> : 被代理类实现的一些接口；</li>\n<li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li>\n</ol>\n<p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>InvocationHandler</span> <span>{</span>\n\n    <span>/**\n     * 当你使用代理对象调用方法的时候实际会调用到这个方法\n     */</span>\n    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span>\n        <span>throws</span> <span>Throwable</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>invoke()</code> 方法有下面三个参数：</p>\n<ol>\n<li><strong>proxy</strong> :动态生成的代理类</li>\n<li><strong>method</strong> : 与代理类对象调用的方法相对应</li>\n<li><strong>args</strong> : 当前 method 方法的参数</li>\n</ol>\n<p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>\n<h4 id=\"_3-1-2-jdk-动态代理类使用步骤\"> 3.1.2. JDK 动态代理类使用步骤</h4>\n<ol>\n<li>定义一个接口及其实现类；</li>\n<li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>\n<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>\n</ol>\n<h4 id=\"_3-1-3-代码示例\"> 3.1.3. 代码示例</h4>\n<p>这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！</p>\n<p><strong>1.定义发送短信的接口</strong></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>SmsService</span> <span>{</span>\n    <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>2.实现发送短信的接口</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>SmsServiceImpl</span> <span>implements</span> <span>SmsService</span> <span>{</span>\n    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"send message:\"</span> <span>+</span> message<span>)</span><span>;</span>\n        <span>return</span> message<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3.定义一个 JDK 动态代理类</strong></p>\n<div><pre><code><span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>InvocationHandler</span><span>;</span>\n<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>InvocationTargetException</span><span>;</span>\n<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>\n\n<span>/**\n * @author shuang.kou\n * @createTime 2020年05月11日 11:23:00\n */</span>\n<span>public</span> <span>class</span> <span>DebugInvocationHandler</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>\n    <span>/**\n     * 代理类中的真实对象\n     */</span>\n    <span>private</span> <span>final</span> <span>Object</span> target<span>;</span>\n\n    <span>public</span> <span>DebugInvocationHandler</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>target <span>=</span> target<span>;</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InvocationTargetException</span><span>,</span> <span>IllegalAccessException</span> <span>{</span>\n        <span>//调用方法之前，我们可以添加自己的操作</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before method \"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Object</span> result <span>=</span> method<span>.</span><span>invoke</span><span>(</span>target<span>,</span> args<span>)</span><span>;</span>\n        <span>//调用方法之后，我们同样可以添加自己的操作</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after method \"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> result<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p>\n<p><strong>4.获取代理对象的工厂类</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>JdkProxyFactory</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>Object</span> <span>getProxy</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>\n        <span>return</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>\n                target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>,</span> <span>// 目标类的类加载</span>\n                target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getInterfaces</span><span>(</span><span>)</span><span>,</span>  <span>// 代理需要实现的接口，可指定多个</span>\n                <span>new</span> <span>DebugInvocationHandler</span><span>(</span>target<span>)</span>   <span>// 代理对象对应的自定义 InvocationHandler</span>\n        <span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p>\n<p><strong>5.实际使用</strong></p>\n<div><pre><code><span>SmsService</span> smsService <span>=</span> <span>(</span><span>SmsService</span><span>)</span> <span>JdkProxyFactory</span><span>.</span><span>getProxy</span><span>(</span><span>new</span> <span>SmsServiceImpl</span><span>(</span><span>)</span><span>)</span><span>;</span>\nsmsService<span>.</span><span>send</span><span>(</span><span>\"java\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>\n<div><pre><code>before method send\nsend message:java\nafter method send\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_3-2-cglib-动态代理机制\"> 3.2. CGLIB 动态代理机制</h3>\n<h4 id=\"_3-2-1-介绍\"> 3.2.1. 介绍</h4>\n<p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p>\n<p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p>\n<p><a href=\"https://github.com/cglib/cglib\" target=\"_blank\" rel=\"noopener noreferrer\">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href=\"http://www.baeldung.com/java-asm\" target=\"_blank\" rel=\"noopener noreferrer\">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a href=\"https://github.com/cglib/cglib\" target=\"_blank\" rel=\"noopener noreferrer\">CGLIB</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>\n<p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p>\n<p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>MethodInterceptor</span>\n<span>extends</span> <span>Callback</span><span>{</span>\n    <span>// 拦截被代理类中的方法</span>\n    <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Object</span> obj<span>,</span> <span><span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>,</span>\n                               <span>MethodProxy</span> proxy<span>)</span> <span>throws</span> <span>Throwable</span><span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ol>\n<li><strong>obj</strong> :被代理的对象（需要增强的对象）</li>\n<li><strong>method</strong> :被拦截的方法（需要增强的方法）</li>\n<li><strong>args</strong> :方法入参</li>\n<li><strong>proxy</strong> :用于调用原始方法</li>\n</ol>\n<p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p>\n<h4 id=\"_3-2-2-cglib-动态代理类使用步骤\"> 3.2.2. CGLIB 动态代理类使用步骤</h4>\n<ol>\n<li>定义一个类；</li>\n<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>\n<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>\n</ol>\n<h4 id=\"_3-2-3-代码示例\"> 3.2.3. 代码示例</h4>\n<p>不同于 JDK 动态代理不需要额外的依赖。<a href=\"https://github.com/cglib/cglib\" target=\"_blank\" rel=\"noopener noreferrer\">CGLIB</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n  <span><span><span>&lt;</span>groupId</span><span>></span></span>cglib<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n  <span><span><span>&lt;</span>artifactId</span><span>></span></span>cglib<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n  <span><span><span>&lt;</span>version</span><span>></span></span>3.3.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>1.实现一个使用阿里云发送短信的类</strong></p>\n<div><pre><code><span>package</span> <span>github<span>.</span>javaguide<span>.</span>dynamicProxy<span>.</span>cglibDynamicProxy</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>AliSmsService</span> <span>{</span>\n    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"send message:\"</span> <span>+</span> message<span>)</span><span>;</span>\n        <span>return</span> message<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p>\n<div><pre><code><span>import</span> <span>net<span>.</span>sf<span>.</span>cglib<span>.</span>proxy<span>.</span></span><span>MethodInterceptor</span><span>;</span>\n<span>import</span> <span>net<span>.</span>sf<span>.</span>cglib<span>.</span>proxy<span>.</span></span><span>MethodProxy</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>\n\n<span>/**\n * 自定义MethodInterceptor\n */</span>\n<span>public</span> <span>class</span> <span>DebugMethodInterceptor</span> <span>implements</span> <span>MethodInterceptor</span> <span>{</span>\n\n\n    <span>/**\n     * @param o           代理对象（增强的对象）\n     * @param method      被拦截的方法（需要增强的方法）\n     * @param args        方法入参\n     * @param methodProxy 用于调用原始方法\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Object</span> o<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>,</span> <span>MethodProxy</span> methodProxy<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n        <span>//调用方法之前，我们可以添加自己的操作</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before method \"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Object</span> object <span>=</span> methodProxy<span>.</span><span>invokeSuper</span><span>(</span>o<span>,</span> args<span>)</span><span>;</span>\n        <span>//调用方法之后，我们同样可以添加自己的操作</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after method \"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> object<span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><strong>3.获取代理类</strong></p>\n<div><pre><code><span>import</span> <span>net<span>.</span>sf<span>.</span>cglib<span>.</span>proxy<span>.</span></span><span>Enhancer</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>CglibProxyFactory</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>Object</span> <span>getProxy</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz<span>)</span> <span>{</span>\n        <span>// 创建动态代理增强类</span>\n        <span>Enhancer</span> enhancer <span>=</span> <span>new</span> <span>Enhancer</span><span>(</span><span>)</span><span>;</span>\n        <span>// 设置类加载器</span>\n        enhancer<span>.</span><span>setClassLoader</span><span>(</span>clazz<span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 设置被代理类</span>\n        enhancer<span>.</span><span>setSuperclass</span><span>(</span>clazz<span>)</span><span>;</span>\n        <span>// 设置方法拦截器</span>\n        enhancer<span>.</span><span>setCallback</span><span>(</span><span>new</span> <span>DebugMethodInterceptor</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 创建代理类</span>\n        <span>return</span> enhancer<span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>4.实际使用</strong></p>\n<div><pre><code><span>AliSmsService</span> aliSmsService <span>=</span> <span>(</span><span>AliSmsService</span><span>)</span> <span>CglibProxyFactory</span><span>.</span><span>getProxy</span><span>(</span><span>AliSmsService</span><span>.</span><span>class</span><span>)</span><span>;</span>\naliSmsService<span>.</span><span>send</span><span>(</span><span>\"java\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>\n<div><pre><code>before method send\nsend message:java\nafter method send\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_3-3-jdk-动态代理和-cglib-动态代理对比\"> 3.3. JDK 动态代理和 CGLIB 动态代理对比</h3>\n<ol>\n<li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>\n<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>\n</ol>\n<h2 id=\"_4-静态代理和动态代理的对比\"> 4. 静态代理和动态代理的对比</h2>\n<ol>\n<li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>\n<li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>\n</ol>\n<h2 id=\"_5-总结\"> 5. 总结</h2>\n<p>这篇文章中主要介绍了代理模式的两种实现：静态代理以及动态代理。涵盖了静态代理和动态代理实战、静态代理和动态代理的区别、JDK 动态代理和 Cglib 动态代理区别等内容。</p>\n<p>文中涉及到的所有源码，你可以在这里找到：<a href=\"https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy</a> 。</p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/1*DjWCgTFm-xqbhbNQVsaWQw.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "ArrayList 源码+扩容机制分析",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/collection/arraylist-source-code/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/collection/arraylist-source-code/",
      "content_html": "<h2 id=\"_1-arraylist-简介\"> 1. ArrayList 简介</h2>\n<p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p>\n<p><code>ArrayList</code>继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口。</p>\n<div><pre><code>\n<span>public</span> <span>class</span> <span>ArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>AbstractList</span><span><span>&lt;</span><span>E</span><span>></span></span>\n        <span>implements</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>RandomAccess</span><span>,</span> <span>Cloneable</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>{</span>\n\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>\n<li><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。</li>\n<li><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li>\n</ul>\n<h3 id=\"_1-1-arraylist-和-vector-的区别\"> 1.1. Arraylist 和 Vector 的区别?</h3>\n<ol>\n<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li>\n<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 <code>Object[ ]</code>存储，线程安全的。</li>\n</ol>\n<h3 id=\"_1-2-arraylist-与-linkedlist-区别\"> 1.2. Arraylist 与 LinkedList 区别?</h3>\n<ol>\n<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>\n<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>\n<li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li>\n<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>\n<li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>\n</ol>\n<h2 id=\"_2-arraylist-核心源码解读\"> 2. ArrayList 核心源码解读</h2>\n<div><pre><code><span>package</span> <span>java<span>.</span>util</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>Consumer</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>Predicate</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>UnaryOperator</span><span>;</span>\n\n\n<span>public</span> <span>class</span> <span>ArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>AbstractList</span><span><span>&lt;</span><span>E</span><span>></span></span>\n        <span>implements</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>RandomAccess</span><span>,</span> <span>Cloneable</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span>\n<span>{</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>8683452581122892189L</span><span>;</span>\n\n    <span>/**\n     * 默认初始容量大小\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_CAPACITY <span>=</span> <span>10</span><span>;</span>\n\n    <span>/**\n     * 空数组（用于空实例）。\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>\n\n     <span>//用于默认大小空实例的共享空数组实例。</span>\n      <span>//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>\n\n    <span>/**\n     * 保存ArrayList数据的数组\n     */</span>\n    <span>transient</span> <span>Object</span><span>[</span><span>]</span> elementData<span>;</span> <span>// non-private to simplify nested class access</span>\n\n    <span>/**\n     * ArrayList 所包含的元素个数\n     */</span>\n    <span>private</span> <span>int</span> size<span>;</span>\n\n    <span>/**\n     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）\n     */</span>\n    <span>public</span> <span>ArrayList</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>initialCapacity <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>//如果传入的参数大于0，创建initialCapacity大小的数组</span>\n            <span>this</span><span>.</span>elementData <span>=</span> <span>new</span> <span>Object</span><span>[</span>initialCapacity<span>]</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>initialCapacity <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            <span>//如果传入的参数等于0，创建空数组</span>\n            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>//其他情况，抛出异常</span>\n            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal Capacity: \"</span><span>+</span>\n                                               initialCapacity<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     *默认无参构造函数\n     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10\n     */</span>\n    <span>public</span> <span>ArrayList</span><span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>elementData <span>=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。\n     */</span>\n    <span>public</span> <span>ArrayList</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>\n        <span>//将指定集合转换为数组</span>\n        elementData <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>\n        <span>//如果elementData数组的长度不为0</span>\n        <span>if</span> <span>(</span><span>(</span>size <span>=</span> elementData<span>.</span>length<span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n            <span>// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span>\n            <span>if</span> <span>(</span>elementData<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>!=</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span>\n                <span>//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span>\n                elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>// 其他情况，用空数组代替</span>\n            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。\n     */</span>\n    <span>public</span> <span>void</span> <span>trimToSize</span><span>(</span><span>)</span> <span>{</span>\n        modCount<span>++</span><span>;</span>\n        <span>if</span> <span>(</span>size <span>&lt;</span> elementData<span>.</span>length<span>)</span> <span>{</span>\n            elementData <span>=</span> <span>(</span>size <span>==</span> <span>0</span><span>)</span>\n              <span>?</span> EMPTY_ELEMENTDATA\n              <span>:</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>//下面是ArrayList的扩容机制</span>\n<span>//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span>\n<span>//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span>\n    <span>/**\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\n     * @param   minCapacity   所需的最小容量\n     */</span>\n    <span>public</span> <span>void</span> <span>ensureCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span>\n        <span>int</span> minExpand <span>=</span> <span>(</span>elementData <span>!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span>\n            <span>// any size if not default element table</span>\n            <span>?</span> <span>0</span>\n            <span>// larger than default for default empty table. It's already</span>\n            <span>// supposed to be at default size.</span>\n            <span>:</span> DEFAULT_CAPACITY<span>;</span>\n        <span>//如果最小容量大于已有的最大容量</span>\n        <span>if</span> <span>(</span>minCapacity <span>></span> minExpand<span>)</span> <span>{</span>\n            <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n   <span>//得到最小扩容量</span>\n    <span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>elementData <span>==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span> <span>{</span>\n              <span>// 获取“默认的容量”和“传入参数”两者之间的最大值</span>\n            minCapacity <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>DEFAULT_CAPACITY<span>,</span> minCapacity<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n    <span>}</span>\n  <span>//判断是否需要扩容</span>\n    <span>private</span> <span>void</span> <span>ensureExplicitCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        modCount<span>++</span><span>;</span>\n\n        <span>// overflow-conscious code</span>\n        <span>if</span> <span>(</span>minCapacity <span>-</span> elementData<span>.</span>length <span>></span> <span>0</span><span>)</span>\n            <span>//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>\n            <span>grow</span><span>(</span>minCapacity<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 要分配的最大数组大小\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_ARRAY_SIZE <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>8</span><span>;</span>\n\n    <span>/**\n     * ArrayList扩容的核心方法。\n     */</span>\n    <span>private</span> <span>void</span> <span>grow</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>// oldCapacity为旧容量，newCapacity为新容量</span>\n        <span>int</span> oldCapacity <span>=</span> elementData<span>.</span>length<span>;</span>\n        <span>//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>\n        <span>//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>\n        <span>int</span> newCapacity <span>=</span> oldCapacity <span>+</span> <span>(</span>oldCapacity <span>>></span> <span>1</span><span>)</span><span>;</span>\n        <span>//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>\n        <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span>\n            newCapacity <span>=</span> minCapacity<span>;</span>\n        <span>//再检查新容量是否超出了ArrayList所定义的最大容量，</span>\n        <span>//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span>\n        <span>//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span>\n        <span>if</span> <span>(</span>newCapacity <span>-</span> MAX_ARRAY_SIZE <span>></span> <span>0</span><span>)</span>\n            newCapacity <span>=</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n        <span>// minCapacity is usually close to size, so this is a win:</span>\n        elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> newCapacity<span>)</span><span>;</span>\n    <span>}</span>\n    <span>//比较minCapacity和 MAX_ARRAY_SIZE</span>\n    <span>private</span> <span>static</span> <span>int</span> <span>hugeCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>\n            <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> <span>(</span>minCapacity <span>></span> MAX_ARRAY_SIZE<span>)</span> <span>?</span>\n            <span>Integer</span><span>.</span>MAX_VALUE <span>:</span>\n            MAX_ARRAY_SIZE<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     *返回此列表中的元素数。\n     */</span>\n    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> size<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 如果此列表不包含元素，则返回 true 。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>\n        <span>//注意=和==的区别</span>\n        <span>return</span> size <span>==</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 如果此列表包含指定的元素，则返回true 。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n        <span>//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span>\n        <span>return</span> <span>indexOf</span><span>(</span>o<span>)</span> <span>>=</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1\n     */</span>\n    <span>public</span> <span>int</span> <span>indexOf</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>\n                <span>if</span> <span>(</span>elementData<span>[</span>i<span>]</span><span>==</span><span>null</span><span>)</span>\n                    <span>return</span> i<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>\n                <span>//equals()方法比较</span>\n                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>)</span>\n                    <span>return</span> i<span>;</span>\n        <span>}</span>\n        <span>return</span> <span>-</span><span>1</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.\n     */</span>\n    <span>public</span> <span>int</span> <span>lastIndexOf</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> size<span>-</span><span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span>\n                <span>if</span> <span>(</span>elementData<span>[</span>i<span>]</span><span>==</span><span>null</span><span>)</span>\n                    <span>return</span> i<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> size<span>-</span><span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span>\n                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>)</span>\n                    <span>return</span> i<span>;</span>\n        <span>}</span>\n        <span>return</span> <span>-</span><span>1</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）\n     */</span>\n    <span>public</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>ArrayList</span><span><span>&lt;</span><span>?</span><span>></span></span> v <span>=</span> <span>(</span><span>ArrayList</span><span><span>&lt;</span><span>?</span><span>></span></span><span>)</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>\n            <span>//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span>\n            v<span>.</span>elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>\n            v<span>.</span>modCount <span>=</span> <span>0</span><span>;</span>\n            <span>return</span> v<span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>CloneNotSupportedException</span> e<span>)</span> <span>{</span>\n            <span>// 这不应该发生，因为我们是可以克隆的</span>\n            <span>throw</span> <span>new</span> <span>InternalError</span><span>(</span>e<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。\n     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。\n     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。\n     */</span>\n    <span>public</span> <span>Object</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;\n     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。\n     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。\n     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。\n     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）\n     */</span>\n    <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n    <span>public</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>T</span><span>[</span><span>]</span> a<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>a<span>.</span>length <span>&lt;</span> size<span>)</span>\n            <span>// 新建一个运行时类型的数组，但是ArrayList数组的内容</span>\n            <span>return</span> <span>(</span><span>T</span><span>[</span><span>]</span><span>)</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> a<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>//调用System提供的arraycopy()方法实现数组之间的复制</span>\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> <span>0</span><span>,</span> a<span>,</span> <span>0</span><span>,</span> size<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>a<span>.</span>length <span>></span> size<span>)</span>\n            a<span>[</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span>\n        <span>return</span> a<span>;</span>\n    <span>}</span>\n\n    <span>// Positional Access Operations</span>\n\n    <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n    <span>E</span> <span>elementData</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>E</span><span>)</span> elementData<span>[</span>index<span>]</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 返回此列表中指定位置的元素。\n     */</span>\n    <span>public</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>\n\n        <span>return</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 用指定的元素替换此列表中指定位置的元素。\n     */</span>\n    <span>public</span> <span>E</span> <span>set</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>\n        <span>//对index进行界限检查</span>\n        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>\n\n        <span>E</span> oldValue <span>=</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>\n        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>\n        <span>//返回原来在这个位置的元素</span>\n        <span>return</span> oldValue<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 将指定的元素追加到此列表的末尾。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>\n        <span>//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>\n        elementData<span>[</span>size<span>++</span><span>]</span> <span>=</span> e<span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 在此列表中的指定位置插入指定的元素。\n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */</span>\n    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>\n        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>\n\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>\n        <span>//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span>\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> <span>1</span><span>,</span>\n                         size <span>-</span> index<span>)</span><span>;</span>\n        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>\n        size<span>++</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。\n     */</span>\n    <span>public</span> <span>E</span> <span>remove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>\n\n        modCount<span>++</span><span>;</span>\n        <span>E</span> oldValue <span>=</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>\n\n        <span>int</span> numMoved <span>=</span> size <span>-</span> index <span>-</span> <span>1</span><span>;</span>\n        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>\n            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>+</span><span>1</span><span>,</span> elementData<span>,</span> index<span>,</span>\n                             numMoved<span>)</span><span>;</span>\n        elementData<span>[</span><span>--</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span> <span>// clear to let GC do its work</span>\n      <span>//从列表中删除的元素</span>\n        <span>return</span> oldValue<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。\n     *返回true，如果此列表包含指定的元素\n     */</span>\n    <span>public</span> <span>boolean</span> <span>remove</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> size<span>;</span> index<span>++</span><span>)</span>\n                <span>if</span> <span>(</span>elementData<span>[</span>index<span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                    <span>fastRemove</span><span>(</span>index<span>)</span><span>;</span>\n                    <span>return</span> <span>true</span><span>;</span>\n                <span>}</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> size<span>;</span> index<span>++</span><span>)</span>\n                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>index<span>]</span><span>)</span><span>)</span> <span>{</span>\n                    <span>fastRemove</span><span>(</span>index<span>)</span><span>;</span>\n                    <span>return</span> <span>true</span><span>;</span>\n                <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n\n    <span>/*\n     * Private remove method that skips bounds checking and does not\n     * return the value removed.\n     */</span>\n    <span>private</span> <span>void</span> <span>fastRemove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        modCount<span>++</span><span>;</span>\n        <span>int</span> numMoved <span>=</span> size <span>-</span> index <span>-</span> <span>1</span><span>;</span>\n        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>\n            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>+</span><span>1</span><span>,</span> elementData<span>,</span> index<span>,</span>\n                             numMoved<span>)</span><span>;</span>\n        elementData<span>[</span><span>--</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span> <span>// clear to let GC do its work</span>\n    <span>}</span>\n\n    <span>/**\n     * 从列表中删除所有元素。\n     */</span>\n    <span>public</span> <span>void</span> <span>clear</span><span>(</span><span>)</span> <span>{</span>\n        modCount<span>++</span><span>;</span>\n\n        <span>// 把数组中所有的元素的值设为null</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>\n            elementData<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>\n\n        size <span>=</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>addAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>\n        <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> numNew <span>=</span> a<span>.</span>length<span>;</span>\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> numNew<span>)</span><span>;</span>  <span>// Increments modCount</span>\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>0</span><span>,</span> elementData<span>,</span> size<span>,</span> numNew<span>)</span><span>;</span>\n        size <span>+=</span> numNew<span>;</span>\n        <span>return</span> numNew <span>!=</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>addAll</span><span>(</span><span>int</span> index<span>,</span> <span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>\n        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>\n\n        <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> numNew <span>=</span> a<span>.</span>length<span>;</span>\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> numNew<span>)</span><span>;</span>  <span>// Increments modCount</span>\n\n        <span>int</span> numMoved <span>=</span> size <span>-</span> index<span>;</span>\n        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>\n            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> numNew<span>,</span>\n                             numMoved<span>)</span><span>;</span>\n\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>0</span><span>,</span> elementData<span>,</span> index<span>,</span> numNew<span>)</span><span>;</span>\n        size <span>+=</span> numNew<span>;</span>\n        <span>return</span> numNew <span>!=</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。\n     *将任何后续元素移动到左侧（减少其索引）。\n     */</span>\n    <span>protected</span> <span>void</span> <span>removeRange</span><span>(</span><span>int</span> fromIndex<span>,</span> <span>int</span> toIndex<span>)</span> <span>{</span>\n        modCount<span>++</span><span>;</span>\n        <span>int</span> numMoved <span>=</span> size <span>-</span> toIndex<span>;</span>\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> toIndex<span>,</span> elementData<span>,</span> fromIndex<span>,</span>\n                         numMoved<span>)</span><span>;</span>\n\n        <span>// clear to let GC do its work</span>\n        <span>int</span> newSize <span>=</span> size <span>-</span> <span>(</span>toIndex<span>-</span>fromIndex<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> newSize<span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            elementData<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>\n        <span>}</span>\n        size <span>=</span> newSize<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 检查给定的索引是否在范围内。\n     */</span>\n    <span>private</span> <span>void</span> <span>rangeCheck</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>index <span>>=</span> size<span>)</span>\n            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>outOfBoundsMsg</span><span>(</span>index<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * add和addAll使用的rangeCheck的一个版本\n     */</span>\n    <span>private</span> <span>void</span> <span>rangeCheckForAdd</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>index <span>></span> size <span>||</span> index <span>&lt;</span> <span>0</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>outOfBoundsMsg</span><span>(</span>index<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 返回IndexOutOfBoundsException细节信息\n     */</span>\n    <span>private</span> <span>String</span> <span>outOfBoundsMsg</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>return</span> <span>\"Index: \"</span><span>+</span>index<span>+</span><span>\", Size: \"</span><span>+</span>size<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 从此列表中删除指定集合中包含的所有元素。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>removeAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span><span>></span></span> c<span>)</span> <span>{</span>\n        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>c<span>)</span><span>;</span>\n        <span>//如果此列表被修改则返回true</span>\n        <span>return</span> <span>batchRemove</span><span>(</span>c<span>,</span> <span>false</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 仅保留此列表中包含在指定集合中的元素。\n     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>retainAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span><span>></span></span> c<span>)</span> <span>{</span>\n        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>c<span>)</span><span>;</span>\n        <span>return</span> <span>batchRemove</span><span>(</span>c<span>,</span> <span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\n     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。\n     *返回的列表迭代器是fail-fast 。\n     */</span>\n    <span>public</span> <span>ListIterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>listIterator</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>index <span>&lt;</span> <span>0</span> <span>||</span> index <span>></span> size<span>)</span>\n            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>\"Index: \"</span><span>+</span>index<span>)</span><span>;</span>\n        <span>return</span> <span>new</span> <span>ListItr</span><span>(</span>index<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     *返回列表中的列表迭代器（按适当的顺序）。\n     *返回的列表迭代器是fail-fast 。\n     */</span>\n    <span>public</span> <span>ListIterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>listIterator</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>ListItr</span><span>(</span><span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     *以正确的顺序返回该列表中的元素的迭代器。\n     *返回的迭代器是fail-fast 。\n     */</span>\n    <span>public</span> <span>Iterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>iterator</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>Itr</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br><span>301</span><br><span>302</span><br><span>303</span><br><span>304</span><br><span>305</span><br><span>306</span><br><span>307</span><br><span>308</span><br><span>309</span><br><span>310</span><br><span>311</span><br><span>312</span><br><span>313</span><br><span>314</span><br><span>315</span><br><span>316</span><br><span>317</span><br><span>318</span><br><span>319</span><br><span>320</span><br><span>321</span><br><span>322</span><br><span>323</span><br><span>324</span><br><span>325</span><br><span>326</span><br><span>327</span><br><span>328</span><br><span>329</span><br><span>330</span><br><span>331</span><br><span>332</span><br><span>333</span><br><span>334</span><br><span>335</span><br><span>336</span><br><span>337</span><br><span>338</span><br><span>339</span><br><span>340</span><br><span>341</span><br><span>342</span><br><span>343</span><br><span>344</span><br><span>345</span><br><span>346</span><br><span>347</span><br><span>348</span><br><span>349</span><br><span>350</span><br><span>351</span><br><span>352</span><br><span>353</span><br><span>354</span><br><span>355</span><br><span>356</span><br><span>357</span><br><span>358</span><br><span>359</span><br><span>360</span><br><span>361</span><br><span>362</span><br><span>363</span><br><span>364</span><br><span>365</span><br><span>366</span><br><span>367</span><br><span>368</span><br><span>369</span><br><span>370</span><br><span>371</span><br><span>372</span><br><span>373</span><br><span>374</span><br><span>375</span><br><span>376</span><br><span>377</span><br><span>378</span><br><span>379</span><br><span>380</span><br><span>381</span><br><span>382</span><br><span>383</span><br><span>384</span><br><span>385</span><br><span>386</span><br><span>387</span><br><span>388</span><br><span>389</span><br><span>390</span><br><span>391</span><br><span>392</span><br><span>393</span><br><span>394</span><br><span>395</span><br><span>396</span><br><span>397</span><br><span>398</span><br><span>399</span><br><span>400</span><br><span>401</span><br><span>402</span><br><span>403</span><br><span>404</span><br><span>405</span><br><span>406</span><br><span>407</span><br><span>408</span><br><span>409</span><br><span>410</span><br><span>411</span><br><span>412</span><br><span>413</span><br><span>414</span><br><span>415</span><br><span>416</span><br><span>417</span><br><span>418</span><br><span>419</span><br><span>420</span><br><span>421</span><br><span>422</span><br><span>423</span><br><span>424</span><br><span>425</span><br><span>426</span><br><span>427</span><br><span>428</span><br><span>429</span><br><span>430</span><br><span>431</span><br><span>432</span><br><span>433</span><br><span>434</span><br><span>435</span><br><span>436</span><br><span>437</span><br><span>438</span><br><span>439</span><br><span>440</span><br><span>441</span><br><span>442</span><br><span>443</span><br><span>444</span><br><span>445</span><br><span>446</span><br><span>447</span><br><span>448</span><br><span>449</span><br><span>450</span><br><span>451</span><br><span>452</span><br><span>453</span><br><span>454</span><br><span>455</span><br><span>456</span><br><span>457</span><br><span>458</span><br><span>459</span><br><span>460</span><br><span>461</span><br><span>462</span><br><span>463</span><br><span>464</span><br><span>465</span><br><span>466</span><br><span>467</span><br><span>468</span><br><span>469</span><br><span>470</span><br><span>471</span><br><span>472</span><br><span>473</span><br><span>474</span><br><span>475</span><br><span>476</span><br><span>477</span><br><span>478</span><br><span>479</span><br><span>480</span><br><span>481</span><br><span>482</span><br><span>483</span><br><span>484</span><br><span>485</span><br><span>486</span><br><span>487</span><br><span>488</span><br><span>489</span><br><span>490</span><br><span>491</span><br><span>492</span><br><span>493</span><br><span>494</span><br><span>495</span><br><span>496</span><br><span>497</span><br><span>498</span><br><span>499</span><br><span>500</span><br><span>501</span><br><span>502</span><br><span>503</span><br></div></div><h2 id=\"_3-arraylist-扩容机制分析\"> 3. ArrayList 扩容机制分析</h2>\n<h3 id=\"_3-1-先从-arraylist-的构造函数说起\"> 3.1. 先从 ArrayList 的构造函数说起</h3>\n<p><strong>（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p>\n<div><pre><code>   <span>/**\n     * 默认初始容量大小\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_CAPACITY <span>=</span> <span>10</span><span>;</span>\n\n\n    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>\n\n    <span>/**\n     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */</span>\n    <span>public</span> <span>ArrayList</span><span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>elementData <span>=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */</span>\n    <span>public</span> <span>ArrayList</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>initialCapacity <span>></span> <span>0</span><span>)</span> <span>{</span><span>//初始容量大于0</span>\n            <span>//创建initialCapacity大小的数组</span>\n            <span>this</span><span>.</span>elementData <span>=</span> <span>new</span> <span>Object</span><span>[</span>initialCapacity<span>]</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>initialCapacity <span>==</span> <span>0</span><span>)</span> <span>{</span><span>//初始容量等于0</span>\n            <span>//创建空数组</span>\n            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span><span>//初始容量小于0，抛出异常</span>\n            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal Capacity: \"</span><span>+</span>\n                                               initialCapacity<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n   <span>/**\n    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n    *如果指定的集合为null，throws NullPointerException。\n    */</span>\n     <span>public</span> <span>ArrayList</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>\n        elementData <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>(</span>size <span>=</span> elementData<span>.</span>length<span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n            <span>// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>\n            <span>if</span> <span>(</span>elementData<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>!=</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span>\n                elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>// replace with empty array.</span>\n            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p>\n<blockquote>\n<p>补充：JDK6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 elementData 。</p>\n</blockquote>\n<h3 id=\"_3-2-一步一步分析-arraylist-扩容机制\"> 3.2. 一步一步分析 ArrayList 扩容机制</h3>\n<p>这里以无参构造函数创建的 ArrayList 为例分析</p>\n<h4 id=\"_3-2-1-先来看-add-方法\"> 3.2.1. 先来看 <code>add</code> 方法</h4>\n<div><pre><code>    <span>/**\n     * 将指定的元素追加到此列表的末尾。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>\n   <span>//添加元素之前，先调用ensureCapacityInternal方法</span>\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>\n        <span>//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>\n        elementData<span>[</span>size<span>++</span><span>]</span> <span>=</span> e<span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>\n<p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p>\n</blockquote>\n<h4 id=\"_3-2-2-再来看看-ensurecapacityinternal-方法\"> 3.2.2. 再来看看 <code>ensureCapacityInternal()</code> 方法</h4>\n<p>（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>\n<div><pre><code>   <span>//得到最小扩容量</span>\n    <span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>elementData <span>==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span> <span>{</span>\n              <span>// 获取默认的容量和传入参数的较大值</span>\n            minCapacity <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>DEFAULT_CAPACITY<span>,</span> minCapacity<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p>\n<blockquote>\n<p>此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。</p>\n</blockquote>\n<h4 id=\"_3-2-3-ensureexplicitcapacity-方法\"> 3.2.3. <code>ensureExplicitCapacity()</code> 方法</h4>\n<p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法，下面我们来研究一下这个方法的源码！</p>\n<div><pre><code>  <span>//判断是否需要扩容</span>\n    <span>private</span> <span>void</span> <span>ensureExplicitCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        modCount<span>++</span><span>;</span>\n\n        <span>// overflow-conscious code</span>\n        <span>if</span> <span>(</span>minCapacity <span>-</span> elementData<span>.</span>length <span>></span> <span>0</span><span>)</span>\n            <span>//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>\n            <span>grow</span><span>(</span>minCapacity<span>)</span><span>;</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>我们来仔细分析一下：</p>\n<ul>\n<li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>\n<li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>\n<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>\n</ul>\n<p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p>\n<h4 id=\"_3-2-4-grow-方法\"> 3.2.4. <code>grow()</code> 方法</h4>\n<div><pre><code>    <span>/**\n     * 要分配的最大数组大小\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_ARRAY_SIZE <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>8</span><span>;</span>\n\n    <span>/**\n     * ArrayList扩容的核心方法。\n     */</span>\n    <span>private</span> <span>void</span> <span>grow</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>// oldCapacity为旧容量，newCapacity为新容量</span>\n        <span>int</span> oldCapacity <span>=</span> elementData<span>.</span>length<span>;</span>\n        <span>//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>\n        <span>//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>\n        <span>int</span> newCapacity <span>=</span> oldCapacity <span>+</span> <span>(</span>oldCapacity <span>>></span> <span>1</span><span>)</span><span>;</span>\n        <span>//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>\n        <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span>\n            newCapacity <span>=</span> minCapacity<span>;</span>\n       <span>// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span>\n       <span>//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span>\n        <span>if</span> <span>(</span>newCapacity <span>-</span> MAX_ARRAY_SIZE <span>></span> <span>0</span><span>)</span>\n            newCapacity <span>=</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n        <span>// minCapacity is usually close to size, so this is a win:</span>\n        elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> newCapacity<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p>\n<blockquote>\n<p>&quot;&gt;&gt;&quot;（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p>\n</blockquote>\n<p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p>\n<ul>\n<li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li>\n<li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>\n<li>以此类推······</li>\n</ul>\n<p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p>\n<ul>\n<li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>\n<li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>\n<li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>\n</ul>\n<h4 id=\"_3-2-5-hugecapacity-方法。\"> 3.2.5. <code>hugeCapacity()</code> 方法。</h4>\n<p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p>\n<div><pre><code>    <span>private</span> <span>static</span> <span>int</span> <span>hugeCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>\n            <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>\n        <span>//对minCapacity和MAX_ARRAY_SIZE进行比较</span>\n        <span>//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span>\n        <span>//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span>\n        <span>//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>\n        <span>return</span> <span>(</span>minCapacity <span>></span> MAX_ARRAY_SIZE<span>)</span> <span>?</span>\n            <span>Integer</span><span>.</span>MAX_VALUE <span>:</span>\n            MAX_ARRAY_SIZE<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_3-3-system-arraycopy-和-arrays-copyof-方法\"> 3.3. <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h3>\n<p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p>\n<h4 id=\"_3-3-1-system-arraycopy-方法\"> 3.3.1. <code>System.arraycopy()</code> 方法</h4>\n<p>源码：</p>\n<div><pre><code>    <span>// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span>\n    <span>/**\n    *   复制数组\n    * @param src 源数组\n    * @param srcPos 源数组中的起始位置\n    * @param dest 目标数组\n    * @param destPos 目标数组中的起始位置\n    * @param length 要复制的数组元素的数量\n    */</span>\n    <span>public</span> <span>static</span> <span>native</span> <span>void</span> <span>arraycopy</span><span>(</span><span>Object</span> src<span>,</span>  <span>int</span>  srcPos<span>,</span>\n                                        <span>Object</span> dest<span>,</span> <span>int</span> destPos<span>,</span>\n                                        <span>int</span> length<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>场景：</p>\n<div><pre><code>    <span>/**\n     * 在此列表中的指定位置插入指定的元素。\n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */</span>\n    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>\n        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>\n\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>\n        <span>//arraycopy()方法实现数组自己复制自己</span>\n        <span>//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span>\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> <span>1</span><span>,</span> size <span>-</span> index<span>)</span><span>;</span>\n        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>\n        size<span>++</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>我们写一个简单的方法测试以下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ArraycopyTest</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>// TODO Auto-generated method stub</span>\n\t\t<span>int</span><span>[</span><span>]</span> a <span>=</span> <span>new</span> <span>int</span><span>[</span><span>10</span><span>]</span><span>;</span>\n\t\ta<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>\n\t\ta<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>\n\t\ta<span>[</span><span>2</span><span>]</span> <span>=</span> <span>2</span><span>;</span>\n\t\ta<span>[</span><span>3</span><span>]</span> <span>=</span> <span>3</span><span>;</span>\n\t\t<span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>2</span><span>,</span> a<span>,</span> <span>3</span><span>,</span> <span>3</span><span>)</span><span>;</span>\n\t\ta<span>[</span><span>2</span><span>]</span><span>=</span><span>99</span><span>;</span>\n\t\t<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> a<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n\t\t\t<span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>a<span>[</span>i<span>]</span> <span>+</span> <span>\" \"</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>结果：</p>\n<div><pre><code>0 1 99 2 3 0 0 0 0 0\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_3-3-2-arrays-copyof-方法\"> 3.3.2. <code>Arrays.copyOf()</code>方法</h4>\n<p>源码：</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>int</span><span>[</span><span>]</span> <span>copyOf</span><span>(</span><span>int</span><span>[</span><span>]</span> original<span>,</span> <span>int</span> newLength<span>)</span> <span>{</span>\n    \t<span>// 申请一个新的数组</span>\n        <span>int</span><span>[</span><span>]</span> copy <span>=</span> <span>new</span> <span>int</span><span>[</span>newLength<span>]</span><span>;</span>\n\t<span>// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span>\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>original<span>,</span> <span>0</span><span>,</span> copy<span>,</span> <span>0</span><span>,</span>\n                         <span>Math</span><span>.</span><span>min</span><span>(</span>original<span>.</span>length<span>,</span> newLength<span>)</span><span>)</span><span>;</span>\n        <span>return</span> copy<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>场景：</p>\n<div><pre><code>   <span>/**\n     以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。\n     */</span>\n    <span>public</span> <span>Object</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>)</span> <span>{</span>\n    <span>//elementData：要复制的数组；size：要复制的长度</span>\n        <span>return</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ArrayscopyOfTest</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>int</span><span>[</span><span>]</span> a <span>=</span> <span>new</span> <span>int</span><span>[</span><span>3</span><span>]</span><span>;</span>\n\t\ta<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>\n\t\ta<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>\n\t\ta<span>[</span><span>2</span><span>]</span> <span>=</span> <span>2</span><span>;</span>\n\t\t<span>int</span><span>[</span><span>]</span> b <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>a<span>,</span> <span>10</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"b.length\"</span><span>+</span>b<span>.</span>length<span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>结果：</p>\n<div><pre><code>10\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_3-3-3-两者联系和区别\"> 3.3.3. 两者联系和区别</h4>\n<p><strong>联系：</strong></p>\n<p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p>\n<p><strong>区别：</strong></p>\n<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>\n<h3 id=\"_3-4-ensurecapacity方法\"> 3.4. <code>ensureCapacity</code>方法</h3>\n<p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>\n<div><pre><code>    <span>/**\n    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。\n     *\n     * @param   minCapacity   所需的最小容量\n     */</span>\n    <span>public</span> <span>void</span> <span>ensureCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>int</span> minExpand <span>=</span> <span>(</span>elementData <span>!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span>\n            <span>// any size if not default element table</span>\n            <span>?</span> <span>0</span>\n            <span>// larger than default for default empty table. It's already</span>\n            <span>// supposed to be at default size.</span>\n            <span>:</span> DEFAULT_CAPACITY<span>;</span>\n\n        <span>if</span> <span>(</span>minCapacity <span>></span> minExpand<span>)</span> <span>{</span>\n            <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p>\n<p>我们通过下面的代码实际测试以下这个方法的效果：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>EnsureCapacityTest</span> <span>{</span>\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\t\t<span>final</span> <span>int</span> <span>N</span> <span>=</span> <span>10000000</span><span>;</span>\n\t\t<span>long</span> startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n\t\t\tlist<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>long</span> endTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"使用ensureCapacity方法前：\"</span><span>+</span><span>(</span>endTime <span>-</span> startTime<span>)</span><span>)</span><span>;</span>\n\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>运行结果：</p>\n<div><pre><code>使用ensureCapacity方法前：2158\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>EnsureCapacityTest</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>final</span> <span>int</span> <span>N</span> <span>=</span> <span>10000000</span><span>;</span>\n        list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>long</span> startTime1 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n        list<span>.</span><span>ensureCapacity</span><span>(</span><span>N</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>\n        <span>}</span>\n        <span>long</span> endTime1 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"使用ensureCapacity方法后：\"</span><span>+</span><span>(</span>endTime1 <span>-</span> startTime1<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>运行结果：</p>\n<div><pre><code>使用ensureCapacity方法后：1773\n</code></pre>\n<div><span>1</span><br></div></div><p>通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "ConcurrentHashMap源码+底层数据结构分析",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/collection/concurrent-hash-map-source-code/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/collection/concurrent-hash-map-source-code/",
      "content_html": "<blockquote>\n<p>本文来自公众号：末读代码的投稿，原文地址：https://mp.weixin.qq.com/s/AHWzboztt53ZfFZmsSnMSw  。</p>\n</blockquote>\n<p>上一篇文章介绍了 HashMap 源码，反响不错，也有很多同学发表了自己的观点，这次又来了，这次是 <code>ConcurrentHashMap</code> 了，作为线程安全的HashMap ，它的使用频率也是很高。那么它的存储结构和实现原理是怎么样的呢？</p>\n<h2 id=\"_1-concurrenthashmap-1-7\"> 1. ConcurrentHashMap 1.7</h2>\n<h3 id=\"_1-存储结构\"> 1. 存储结构</h3>\n<blockquote>\n<p>下图存在一个笔误 Segmeng -&gt; Segment</p>\n</blockquote>\n<p><img src=\"./images/image-20200405151029416.png\" alt=\"Java 7 ConcurrentHashMap 存储结构\" /></p>\n<p>Java 7 中 <code>ConcurrentHashMap</code> 的存储结构如上图，<code>ConcurrnetHashMap</code> 由很多个 <code>Segment</code>  组合，而每一个 <code>Segment</code> 是一个类似于 HashMap 的结构，所以每一个 <code>HashMap</code> 的内部可以进行扩容。但是 <code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code> 的个数是 16 个，你也可以认为 <code>ConcurrentHashMap</code> 默认支持最多 16 个线程并发。</p>\n<h3 id=\"_2-初始化\"> 2. 初始化</h3>\n<p>通过 ConcurrentHashMap 的无参构造探寻 ConcurrentHashMap 的初始化流程。</p>\n<div><pre><code>    <span>/**\n     * Creates a new, empty map with a default initial capacity (16),\n     * load factor (0.75) and concurrencyLevel (16).\n     */</span>\n    <span>public</span> <span>ConcurrentHashMap</span><span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>(</span>DEFAULT_INITIAL_CAPACITY<span>,</span> DEFAULT_LOAD_FACTOR<span>,</span> DEFAULT_CONCURRENCY_LEVEL<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是。</p>\n<div><pre><code>    <span>/**\n     * 默认初始化容量\n     */</span>\n    <span>static</span> <span>final</span> <span>int</span> DEFAULT_INITIAL_CAPACITY <span>=</span> <span>16</span><span>;</span>\n\n    <span>/**\n     * 默认负载因子\n     */</span>\n    <span>static</span> <span>final</span> <span>float</span> DEFAULT_LOAD_FACTOR <span>=</span> <span>0.75f</span><span>;</span>\n\n    <span>/**\n     * 默认并发级别\n     */</span>\n    <span>static</span> <span>final</span> <span>int</span> DEFAULT_CONCURRENCY_LEVEL <span>=</span> <span>16</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>接着看下这个有参构造函数的内部实现逻辑。</p>\n<div><pre><code><span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n<span>public</span> <span>ConcurrentHashMap</span><span>(</span><span>int</span> initialCapacity<span>,</span><span>float</span> loadFactor<span>,</span> <span>int</span> concurrencyLevel<span>)</span> <span>{</span>\n    <span>// 参数校验</span>\n    <span>if</span> <span>(</span><span>!</span><span>(</span>loadFactor <span>></span> <span>0</span><span>)</span> <span>||</span> initialCapacity <span>&lt;</span> <span>0</span> <span>||</span> concurrencyLevel <span>&lt;=</span> <span>0</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>\n    <span>// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span>\n    <span>if</span> <span>(</span>concurrencyLevel <span>></span> MAX_SEGMENTS<span>)</span>\n        concurrencyLevel <span>=</span> MAX_SEGMENTS<span>;</span>\n    <span>// Find power-of-two sizes best matching arguments</span>\n    <span>// 2的多少次方</span>\n    <span>int</span> sshift <span>=</span> <span>0</span><span>;</span>\n    <span>int</span> ssize <span>=</span> <span>1</span><span>;</span>\n    <span>// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span>\n    <span>while</span> <span>(</span>ssize <span>&lt;</span> concurrencyLevel<span>)</span> <span>{</span>\n        <span>++</span>sshift<span>;</span>\n        ssize <span>&lt;&lt;=</span> <span>1</span><span>;</span>\n    <span>}</span>\n    <span>// 记录段偏移量</span>\n    <span>this</span><span>.</span>segmentShift <span>=</span> <span>32</span> <span>-</span> sshift<span>;</span>\n    <span>// 记录段掩码</span>\n    <span>this</span><span>.</span>segmentMask <span>=</span> ssize <span>-</span> <span>1</span><span>;</span>\n    <span>// 设置容量</span>\n    <span>if</span> <span>(</span>initialCapacity <span>></span> MAXIMUM_CAPACITY<span>)</span>\n        initialCapacity <span>=</span> MAXIMUM_CAPACITY<span>;</span>\n    <span>// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span>\n    <span>int</span> c <span>=</span> initialCapacity <span>/</span> ssize<span>;</span>\n    <span>if</span> <span>(</span>c <span>*</span> ssize <span>&lt;</span> initialCapacity<span>)</span>\n        <span>++</span>c<span>;</span>\n    <span>int</span> cap <span>=</span> MIN_SEGMENT_TABLE_CAPACITY<span>;</span>\n    <span>//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span>\n    <span>while</span> <span>(</span>cap <span>&lt;</span> c<span>)</span>\n        cap <span>&lt;&lt;=</span> <span>1</span><span>;</span>\n    <span>// create segments and segments[0]</span>\n    <span>// 创建 Segment 数组，设置 segments[0]</span>\n    <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> s0 <span>=</span> <span>new</span> <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>loadFactor<span>,</span> <span>(</span><span>int</span><span>)</span><span>(</span>cap <span>*</span> loadFactor<span>)</span><span>,</span>\n                         <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>HashEntry</span><span>[</span>cap<span>]</span><span>)</span><span>;</span>\n    <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> ss <span>=</span> <span>(</span><span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>Segment</span><span>[</span>ssize<span>]</span><span>;</span>\n    UNSAFE<span>.</span><span>putOrderedObject</span><span>(</span>ss<span>,</span> SBASE<span>,</span> s0<span>)</span><span>;</span> <span>// ordered write of segments[0]</span>\n    <span>this</span><span>.</span>segments <span>=</span> ss<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑。</p>\n<ol>\n<li>必要参数校验。</li>\n<li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值是 16.</strong></li>\n<li>寻找并发级别 concurrencyLevel 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li>\n<li>记录 segmentShift 偏移量，这个值为【容量 =  2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</li>\n<li>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15.</li>\n<li><strong>初始化 segments[0]</strong>，<strong>默认大小为 2</strong>，<strong>负载因子 0.75</strong>，<strong>扩容阀值是 2*0.75=1.5</strong>，插入第二个值时才会进行扩容。</li>\n</ol>\n<h3 id=\"_3-put\"> 3. put</h3>\n<p>接着上面的初始化参数继续查看 put 方法源码。</p>\n<div><pre><code><span>/**\n * Maps the specified key to the specified value in this table.\n * Neither the key nor the value can be null.\n *\n * &lt;p> The value can be retrieved by calling the &lt;tt>get&lt;/tt> method\n * with a key that is equal to the original key.\n *\n * @param key key with which the specified value is to be associated\n * @param value value to be associated with the specified key\n * @return the previous value associated with &lt;tt>key&lt;/tt>, or\n *         &lt;tt>null&lt;/tt> if there was no mapping for &lt;tt>key&lt;/tt>\n * @throws NullPointerException if the specified key or value is null\n */</span>\n<span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>\n    <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> s<span>;</span>\n    <span>if</span> <span>(</span>value <span>==</span> <span>null</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>\n    <span>int</span> hash <span>=</span> <span>hash</span><span>(</span>key<span>)</span><span>;</span>\n    <span>// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span>\n    <span>// 其实也就是把高4位与segmentMask（1111）做与运算</span>\n    <span>int</span> j <span>=</span> <span>(</span>hash <span>>>></span> segmentShift<span>)</span> <span>&amp;</span> segmentMask<span>;</span>\n    <span>if</span> <span>(</span><span>(</span>s <span>=</span> <span>(</span><span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>UNSAFE<span>.</span>getObject          <span>// nonvolatile; recheck</span>\n         <span>(</span>segments<span>,</span> <span>(</span>j <span>&lt;&lt;</span> SSHIFT<span>)</span> <span>+</span> SBASE<span>)</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>//  in ensureSegment</span>\n        <span>// 如果查找到的 Segment 为空，初始化</span>\n        s <span>=</span> <span>ensureSegment</span><span>(</span>j<span>)</span><span>;</span>\n    <span>return</span> s<span>.</span><span>put</span><span>(</span>key<span>,</span> hash<span>,</span> value<span>,</span> <span>false</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>/**\n * Returns the segment for the given index, creating it and\n * recording in segment table (via CAS) if not already present.\n *\n * @param k the index\n * @return the segment\n */</span>\n<span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n<span>private</span> <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>ensureSegment</span><span>(</span><span>int</span> k<span>)</span> <span>{</span>\n    <span>final</span> <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> ss <span>=</span> <span>this</span><span>.</span>segments<span>;</span>\n    <span>long</span> u <span>=</span> <span>(</span>k <span>&lt;&lt;</span> SSHIFT<span>)</span> <span>+</span> SBASE<span>;</span> <span>// raw offset</span>\n    <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> seg<span>;</span>\n    <span>// 判断 u 位置的 Segment 是否为null</span>\n    <span>if</span> <span>(</span><span>(</span>seg <span>=</span> <span>(</span><span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>UNSAFE<span>.</span><span>getObjectVolatile</span><span>(</span>ss<span>,</span> u<span>)</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> proto <span>=</span> ss<span>[</span><span>0</span><span>]</span><span>;</span> <span>// use segment 0 as prototype</span>\n        <span>// 获取0号 segment 里的 HashEntry&lt;K,V> 初始化长度</span>\n        <span>int</span> cap <span>=</span> proto<span>.</span>table<span>.</span>length<span>;</span>\n        <span>// 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span>\n        <span>float</span> lf <span>=</span> proto<span>.</span>loadFactor<span>;</span>\n        <span>// 计算扩容阀值</span>\n        <span>int</span> threshold <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span>cap <span>*</span> lf<span>)</span><span>;</span>\n        <span>// 创建一个 cap 容量的 HashEntry 数组</span>\n        <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab <span>=</span> <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>HashEntry</span><span>[</span>cap<span>]</span><span>;</span>\n        <span>if</span> <span>(</span><span>(</span>seg <span>=</span> <span>(</span><span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>UNSAFE<span>.</span><span>getObjectVolatile</span><span>(</span>ss<span>,</span> u<span>)</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span> <span>// recheck</span>\n            <span>// 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span>\n            <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> s <span>=</span> <span>new</span> <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>lf<span>,</span> threshold<span>,</span> tab<span>)</span><span>;</span>\n            <span>// 自旋检查 u 位置的 Segment 是否为null</span>\n            <span>while</span> <span>(</span><span>(</span>seg <span>=</span> <span>(</span><span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>UNSAFE<span>.</span><span>getObjectVolatile</span><span>(</span>ss<span>,</span> u<span>)</span><span>)</span>\n                   <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                <span>// 使用CAS 赋值，只会成功一次</span>\n                <span>if</span> <span>(</span>UNSAFE<span>.</span><span>compareAndSwapObject</span><span>(</span>ss<span>,</span> u<span>,</span> <span>null</span><span>,</span> seg <span>=</span> s<span>)</span><span>)</span>\n                    <span>break</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> seg<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><p>上面的源码分析了 ConcurrentHashMap 在 put 一个数据时的处理流程，下面梳理下具体流程。</p>\n<ol>\n<li>\n<p>计算要 put 的 key 的位置，获取指定位置的 Segment。</p>\n</li>\n<li>\n<p>如果指定位置的 Segment 为空，则初始化这个 Segment.</p>\n<p><strong>初始化 Segment 流程：</strong></p>\n<ol>\n<li>检查计算得到的位置的 Segment 是否为null.</li>\n<li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</li>\n<li>再次检查计算得到的指定位置的 Segment 是否为null.</li>\n<li>使用创建的 HashEntry 数组初始化这个 Segment.</li>\n<li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.</li>\n</ol>\n</li>\n<li>\n<p>Segment.put 插入 key,value 值。</p>\n</li>\n</ol>\n<p>上面探究了获取 Segment 段和初始化 Segment 段的操作。最后一行的 Segment 的 put 方法还没有查看，继续分析。</p>\n<div><pre><code><span>final</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>int</span> hash<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>)</span> <span>{</span>\n    <span>// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span>\n    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> node <span>=</span> <span>tryLock</span><span>(</span><span>)</span> <span>?</span> <span>null</span> <span>:</span> <span>scanAndLockForPut</span><span>(</span>key<span>,</span> hash<span>,</span> value<span>)</span><span>;</span>\n    <span>V</span> oldValue<span>;</span>\n    <span>try</span> <span>{</span>\n        <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab <span>=</span> table<span>;</span>\n        <span>// 计算要put的数据位置</span>\n        <span>int</span> index <span>=</span> <span>(</span>tab<span>.</span>length <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>;</span>\n        <span>// CAS 获取 index 坐标的值</span>\n        <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> first <span>=</span> <span>entryAt</span><span>(</span>tab<span>,</span> index<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> first<span>;</span><span>;</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                <span>// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span>\n                <span>K</span> k<span>;</span>\n                <span>if</span> <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span>\n                    <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span> <span>{</span>\n                    oldValue <span>=</span> e<span>.</span>value<span>;</span>\n                    <span>if</span> <span>(</span><span>!</span>onlyIfAbsent<span>)</span> <span>{</span>\n                        e<span>.</span>value <span>=</span> value<span>;</span>\n                        <span>++</span>modCount<span>;</span>\n                    <span>}</span>\n                    <span>break</span><span>;</span>\n                <span>}</span>\n                e <span>=</span> e<span>.</span>next<span>;</span>\n            <span>}</span>\n            <span>else</span> <span>{</span>\n                <span>// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span>\n                <span>if</span> <span>(</span>node <span>!=</span> <span>null</span><span>)</span>\n                    node<span>.</span><span>setNext</span><span>(</span>first<span>)</span><span>;</span>\n                <span>else</span>\n                    node <span>=</span> <span>new</span> <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> first<span>)</span><span>;</span>\n                <span>int</span> c <span>=</span> count <span>+</span> <span>1</span><span>;</span>\n                <span>// 容量大于扩容阀值，小于最大容量，进行扩容</span>\n                <span>if</span> <span>(</span>c <span>></span> threshold <span>&amp;&amp;</span> tab<span>.</span>length <span>&lt;</span> MAXIMUM_CAPACITY<span>)</span>\n                    <span>rehash</span><span>(</span>node<span>)</span><span>;</span>\n                <span>else</span>\n                    <span>// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span>\n                    <span>setEntryAt</span><span>(</span>tab<span>,</span> index<span>,</span> node<span>)</span><span>;</span>\n                <span>++</span>modCount<span>;</span>\n                count <span>=</span> c<span>;</span>\n                oldValue <span>=</span> <span>null</span><span>;</span>\n                <span>break</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        <span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> oldValue<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><p>由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p>\n<ol>\n<li>\n<p>tryLock() 获取锁，获取不到使用  <strong><code>scanAndLockForPut</code></strong> 方法继续获取。</p>\n</li>\n<li>\n<p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。</p>\n</li>\n<li>\n<p>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p>\n<p>如果这个位置上的 <strong>HashEntry 不存在</strong>：</p>\n<ol>\n<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>\n<li>直接头插法插入。</li>\n</ol>\n<p>如果这个位置上的 <strong>HashEntry 存在</strong>：</p>\n<ol>\n<li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li>\n<li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。\n<ol>\n<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>\n<li>直接链表头插法插入。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p>\n</li>\n</ol>\n<p>这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。在自旋时顺表获取下 hash 位置的 HashEntry。</p>\n<div><pre><code><span>private</span> <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>scanAndLockForPut</span><span>(</span><span>K</span> key<span>,</span> <span>int</span> hash<span>,</span> <span>V</span> value<span>)</span> <span>{</span>\n    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> first <span>=</span> <span>entryForHash</span><span>(</span><span>this</span><span>,</span> hash<span>)</span><span>;</span>\n    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> first<span>;</span>\n    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> node <span>=</span> <span>null</span><span>;</span>\n    <span>int</span> retries <span>=</span> <span>-</span><span>1</span><span>;</span> <span>// negative while locating node</span>\n    <span>// 自旋获取锁</span>\n    <span>while</span> <span>(</span><span>!</span><span>tryLock</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> f<span>;</span> <span>// to recheck first below</span>\n        <span>if</span> <span>(</span>retries <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>e <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>// speculatively create node</span>\n                    node <span>=</span> <span>new</span> <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>\n                retries <span>=</span> <span>0</span><span>;</span>\n            <span>}</span>\n            <span>else</span> <span>if</span> <span>(</span>key<span>.</span><span>equals</span><span>(</span>e<span>.</span>key<span>)</span><span>)</span>\n                retries <span>=</span> <span>0</span><span>;</span>\n            <span>else</span>\n                e <span>=</span> e<span>.</span>next<span>;</span>\n        <span>}</span>\n        <span>else</span> <span>if</span> <span>(</span><span>++</span>retries <span>></span> MAX_SCAN_RETRIES<span>)</span> <span>{</span>\n            <span>// 自旋达到指定次数后，阻塞等到只到获取到锁</span>\n            <span>lock</span><span>(</span><span>)</span><span>;</span>\n            <span>break</span><span>;</span>\n        <span>}</span>\n        <span>else</span> <span>if</span> <span>(</span><span>(</span>retries <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span>\n                 <span>(</span>f <span>=</span> <span>entryForHash</span><span>(</span><span>this</span><span>,</span> hash<span>)</span><span>)</span> <span>!=</span> first<span>)</span> <span>{</span>\n            e <span>=</span> first <span>=</span> f<span>;</span> <span>// re-traverse if entry changed</span>\n            retries <span>=</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> node<span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id=\"_4-扩容-rehash\"> 4. 扩容 rehash</h3>\n<p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p>\n<div><pre><code><span>private</span> <span>void</span> <span>rehash</span><span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> node<span>)</span> <span>{</span>\n    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> oldTable <span>=</span> table<span>;</span>\n    <span>// 老容量</span>\n    <span>int</span> oldCapacity <span>=</span> oldTable<span>.</span>length<span>;</span>\n    <span>// 新容量，扩大两倍</span>\n    <span>int</span> newCapacity <span>=</span> oldCapacity <span>&lt;&lt;</span> <span>1</span><span>;</span>\n    <span>// 新的扩容阀值 </span>\n    threshold <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span>newCapacity <span>*</span> loadFactor<span>)</span><span>;</span>\n    <span>// 创建新的数组</span>\n    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> newTable <span>=</span> <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span> <span>new</span> <span>HashEntry</span><span>[</span>newCapacity<span>]</span><span>;</span>\n    <span>// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span>\n    <span>int</span> sizeMask <span>=</span> newCapacity <span>-</span> <span>1</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> oldCapacity <span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>// 遍历老数组</span>\n        <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> oldTable<span>[</span>i<span>]</span><span>;</span>\n        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next <span>=</span> e<span>.</span>next<span>;</span>\n            <span>// 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。</span>\n            <span>int</span> idx <span>=</span> e<span>.</span>hash <span>&amp;</span> sizeMask<span>;</span>\n            <span>if</span> <span>(</span>next <span>==</span> <span>null</span><span>)</span>   <span>//  Single node on list</span>\n                <span>// 如果当前位置还不是链表，只是一个元素，直接赋值</span>\n                newTable<span>[</span>idx<span>]</span> <span>=</span> e<span>;</span>\n            <span>else</span> <span>{</span> <span>// Reuse consecutive sequence at same slot</span>\n                <span>// 如果是链表了</span>\n                <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> lastRun <span>=</span> e<span>;</span>\n                <span>int</span> lastIdx <span>=</span> idx<span>;</span>\n                <span>// 新的位置只可能是不便或者是老的位置+老的容量。</span>\n                <span>// 遍历结束后，lastRun 后面的元素位置都是相同的</span>\n                <span>for</span> <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> last <span>=</span> next<span>;</span> last <span>!=</span> <span>null</span><span>;</span> last <span>=</span> last<span>.</span>next<span>)</span> <span>{</span>\n                    <span>int</span> k <span>=</span> last<span>.</span>hash <span>&amp;</span> sizeMask<span>;</span>\n                    <span>if</span> <span>(</span>k <span>!=</span> lastIdx<span>)</span> <span>{</span>\n                        lastIdx <span>=</span> k<span>;</span>\n                        lastRun <span>=</span> last<span>;</span>\n                    <span>}</span>\n                <span>}</span>\n                <span>// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span>\n                newTable<span>[</span>lastIdx<span>]</span> <span>=</span> lastRun<span>;</span>\n                <span>// Clone remaining nodes</span>\n                <span>for</span> <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p <span>=</span> e<span>;</span> p <span>!=</span> lastRun<span>;</span> p <span>=</span> p<span>.</span>next<span>)</span> <span>{</span>\n                    <span>// 遍历剩余元素，头插法到指定 k 位置。</span>\n                    <span>V</span> v <span>=</span> p<span>.</span>value<span>;</span>\n                    <span>int</span> h <span>=</span> p<span>.</span>hash<span>;</span>\n                    <span>int</span> k <span>=</span> h <span>&amp;</span> sizeMask<span>;</span>\n                    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> n <span>=</span> newTable<span>[</span>k<span>]</span><span>;</span>\n                    newTable<span>[</span>k<span>]</span> <span>=</span> <span>new</span> <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>h<span>,</span> p<span>.</span>key<span>,</span> v<span>,</span> n<span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n    <span>// 头插法插入新的节点</span>\n    <span>int</span> nodeIndex <span>=</span> node<span>.</span>hash <span>&amp;</span> sizeMask<span>;</span> <span>// add the new node</span>\n    node<span>.</span><span>setNext</span><span>(</span>newTable<span>[</span>nodeIndex<span>]</span><span>)</span><span>;</span>\n    newTable<span>[</span>nodeIndex<span>]</span> <span>=</span> node<span>;</span>\n    table <span>=</span> newTable<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><p>有些同学可能会对最后的两个 for 循环有疑惑，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计，有深入研究的同学可以发表下意见。</p>\n<h3 id=\"_5-get\"> 5. get</h3>\n<p>到这里就很简单了，get 方法只需要两步即可。</p>\n<ol>\n<li>计算得到 key 的存放位置。</li>\n<li>遍历指定位置查找相同 key 的 value 值。</li>\n</ol>\n<div><pre><code><span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> s<span>;</span> <span>// manually integrate access methods to reduce overhead</span>\n    <span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span>\n    <span>int</span> h <span>=</span> <span>hash</span><span>(</span>key<span>)</span><span>;</span>\n    <span>long</span> u <span>=</span> <span>(</span><span>(</span><span>(</span>h <span>>>></span> segmentShift<span>)</span> <span>&amp;</span> segmentMask<span>)</span> <span>&lt;&lt;</span> SSHIFT<span>)</span> <span>+</span> SBASE<span>;</span>\n    <span>// 计算得到 key 的存放位置</span>\n    <span>if</span> <span>(</span><span>(</span>s <span>=</span> <span>(</span><span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>UNSAFE<span>.</span><span>getObjectVolatile</span><span>(</span>segments<span>,</span> u<span>)</span><span>)</span> <span>!=</span> <span>null</span> <span>&amp;&amp;</span>\n        <span>(</span>tab <span>=</span> s<span>.</span>table<span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> <span>(</span><span>HashEntry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span> UNSAFE<span>.</span>getObjectVolatile\n                 <span>(</span>tab<span>,</span> <span>(</span><span>(</span><span>long</span><span>)</span><span>(</span><span>(</span><span>(</span>tab<span>.</span>length <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> h<span>)</span><span>)</span> <span>&lt;&lt;</span> TSHIFT<span>)</span> <span>+</span> TBASE<span>)</span><span>;</span>\n             e <span>!=</span> <span>null</span><span>;</span> e <span>=</span> e<span>.</span>next<span>)</span> <span>{</span>\n            <span>// 如果是链表，遍历查找到相同 key 的 value。</span>\n            <span>K</span> k<span>;</span>\n            <span>if</span> <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>e<span>.</span>hash <span>==</span> h <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span>\n                <span>return</span> e<span>.</span>value<span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"_2-concurrenthashmap-1-8\"> 2. ConcurrentHashMap 1.8</h2>\n<h3 id=\"_1-存储结构-2\"> 1. 存储结构</h3>\n<p><img src=\"./images/java8_concurrenthashmap.png\" alt=\"Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）\" /></p>\n<p>可以发现 Java8 的 ConcurrentHashMap  相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>\n<h3 id=\"_2-初始化-inittable\"> 2. 初始化 initTable</h3>\n<div><pre><code><span>/**\n * Initializes table, using the size recorded in sizeCtl.\n */</span>\n<span>private</span> <span>final</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> <span>initTable</span><span>(</span><span>)</span> <span>{</span>\n    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>int</span> sc<span>;</span>\n    <span>while</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>==</span> <span>null</span> <span>||</span> tab<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        ／／　如果 sizeCtl <span>&lt;</span> <span>0</span> <span>,</span>说明另外的线程执行CAS 成功，正在进行初始化。\n        <span>if</span> <span>(</span><span>(</span>sc <span>=</span> sizeCtl<span>)</span> <span>&lt;</span> <span>0</span><span>)</span>\n            <span>// 让出 CPU 使用权</span>\n            <span>Thread</span><span>.</span><span>yield</span><span>(</span><span>)</span><span>;</span> <span>// lost initialization race; just spin</span>\n        <span>else</span> <span>if</span> <span>(</span><span>U</span><span>.</span><span>compareAndSwapInt</span><span>(</span><span>this</span><span>,</span> SIZECTL<span>,</span> sc<span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>==</span> <span>null</span> <span>||</span> tab<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                    <span>int</span> n <span>=</span> <span>(</span>sc <span>></span> <span>0</span><span>)</span> <span>?</span> sc <span>:</span> DEFAULT_CAPACITY<span>;</span>\n                    <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> nt <span>=</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>Node</span><span><span>&lt;</span><span>?</span><span>,</span><span>?</span><span>></span></span><span>[</span>n<span>]</span><span>;</span>\n                    table <span>=</span> tab <span>=</span> nt<span>;</span>\n                    sc <span>=</span> n <span>-</span> <span>(</span>n <span>>>></span> <span>2</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span> <span>finally</span> <span>{</span>\n                sizeCtl <span>=</span> sc<span>;</span>\n            <span>}</span>\n            <span>break</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> tab<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>从源码中可以发现 ConcurrentHashMap 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p>\n<ol>\n<li>-1  说明正在初始化</li>\n<li>-N 说明有N-1个线程正在进行扩容</li>\n<li>表示 table 初始化大小，如果 table 没有初始化</li>\n<li>表示 table 容量，如果 table　已经初始化。</li>\n</ol>\n<h3 id=\"_3-put-2\"> 3. put</h3>\n<p>直接过一遍 put 源码。</p>\n<div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>\n    <span>return</span> <span>putVal</span><span>(</span>key<span>,</span> value<span>,</span> <span>false</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>/** Implementation for put and putIfAbsent */</span>\n<span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>)</span> <span>{</span>\n    <span>// key 和 value 不能为空</span>\n    <span>if</span> <span>(</span>key <span>==</span> <span>null</span> <span>||</span> value <span>==</span> <span>null</span><span>)</span> <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>\n    <span>int</span> hash <span>=</span> <span>spread</span><span>(</span>key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>int</span> binCount <span>=</span> <span>0</span><span>;</span>\n    <span>for</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab <span>=</span> table<span>;</span><span>;</span><span>)</span> <span>{</span>\n        <span>// f = 目标位置元素</span>\n        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> f<span>;</span> <span>int</span> n<span>,</span> i<span>,</span> fh<span>;</span><span>// fh 后面存放目标位置的元素 hash 值</span>\n        <span>if</span> <span>(</span>tab <span>==</span> <span>null</span> <span>||</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>==</span> <span>0</span><span>)</span>\n            <span>// 数组桶为空，初始化数组桶（自旋+CAS)</span>\n            tab <span>=</span> <span>initTable</span><span>(</span><span>)</span><span>;</span>\n        <span>else</span> <span>if</span> <span>(</span><span>(</span>f <span>=</span> <span>tabAt</span><span>(</span>tab<span>,</span> i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>)</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span>\n            <span>if</span> <span>(</span><span>casTabAt</span><span>(</span>tab<span>,</span> i<span>,</span> <span>null</span><span>,</span><span>new</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>)</span><span>)</span>\n                <span>break</span><span>;</span>  <span>// no lock when adding to empty bin</span>\n        <span>}</span>\n        <span>else</span> <span>if</span> <span>(</span><span>(</span>fh <span>=</span> f<span>.</span>hash<span>)</span> <span>==</span> MOVED<span>)</span>\n            tab <span>=</span> <span>helpTransfer</span><span>(</span>tab<span>,</span> f<span>)</span><span>;</span>\n        <span>else</span> <span>{</span>\n            <span>V</span> oldVal <span>=</span> <span>null</span><span>;</span>\n            <span>// 使用 synchronized 加锁加入节点</span>\n            <span>synchronized</span> <span>(</span>f<span>)</span> <span>{</span>\n                <span>if</span> <span>(</span><span>tabAt</span><span>(</span>tab<span>,</span> i<span>)</span> <span>==</span> f<span>)</span> <span>{</span>\n                    <span>// 说明是链表</span>\n                    <span>if</span> <span>(</span>fh <span>>=</span> <span>0</span><span>)</span> <span>{</span>\n                        binCount <span>=</span> <span>1</span><span>;</span>\n                        <span>// 循环加入新的或者覆盖节点</span>\n                        <span>for</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> f<span>;</span><span>;</span> <span>++</span>binCount<span>)</span> <span>{</span>\n                            <span>K</span> ek<span>;</span>\n                            <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>\n                                <span>(</span><span>(</span>ek <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span>\n                                 <span>(</span>ek <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>ek<span>)</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n                                oldVal <span>=</span> e<span>.</span>val<span>;</span>\n                                <span>if</span> <span>(</span><span>!</span>onlyIfAbsent<span>)</span>\n                                    e<span>.</span>val <span>=</span> value<span>;</span>\n                                <span>break</span><span>;</span>\n                            <span>}</span>\n                            <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> pred <span>=</span> e<span>;</span>\n                            <span>if</span> <span>(</span><span>(</span>e <span>=</span> e<span>.</span>next<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                                pred<span>.</span>next <span>=</span> <span>new</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span>\n                                                          value<span>,</span> <span>null</span><span>)</span><span>;</span>\n                                <span>break</span><span>;</span>\n                            <span>}</span>\n                        <span>}</span>\n                    <span>}</span>\n                    <span>else</span> <span>if</span> <span>(</span>f <span>instanceof</span> <span>TreeBin</span><span>)</span> <span>{</span>\n                        <span>// 红黑树</span>\n                        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>;</span>\n                        binCount <span>=</span> <span>2</span><span>;</span>\n                        <span>if</span> <span>(</span><span>(</span>p <span>=</span> <span>(</span><span>(</span><span>TreeBin</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>f<span>)</span><span>.</span><span>putTreeVal</span><span>(</span>hash<span>,</span> key<span>,</span>\n                                                       value<span>)</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                            oldVal <span>=</span> p<span>.</span>val<span>;</span>\n                            <span>if</span> <span>(</span><span>!</span>onlyIfAbsent<span>)</span>\n                                p<span>.</span>val <span>=</span> value<span>;</span>\n                        <span>}</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n            <span>if</span> <span>(</span>binCount <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>binCount <span>>=</span> TREEIFY_THRESHOLD<span>)</span>\n                    <span>treeifyBin</span><span>(</span>tab<span>,</span> i<span>)</span><span>;</span>\n                <span>if</span> <span>(</span>oldVal <span>!=</span> <span>null</span><span>)</span>\n                    <span>return</span> oldVal<span>;</span>\n                <span>break</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n    <span>addCount</span><span>(</span><span>1L</span><span>,</span> binCount<span>)</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><ol>\n<li>\n<p>根据 key 计算出 hashcode 。</p>\n</li>\n<li>\n<p>判断是否需要进行初始化。</p>\n</li>\n<li>\n<p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p>\n</li>\n<li>\n<p>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p>\n</li>\n<li>\n<p>如果都不满足，则利用 synchronized 锁写入数据。</p>\n</li>\n<li>\n<p>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</p>\n</li>\n</ol>\n<h3 id=\"_4-get\"> 4. get</h3>\n<p>get 流程比较简单，直接过一遍源码。</p>\n<div><pre><code><span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>,</span> p<span>;</span> <span>int</span> n<span>,</span> eh<span>;</span> <span>K</span> ek<span>;</span>\n    <span>// key 所在的 hash 位置</span>\n    <span>int</span> h <span>=</span> <span>spread</span><span>(</span>key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>></span> <span>0</span> <span>&amp;&amp;</span>\n        <span>(</span>e <span>=</span> <span>tabAt</span><span>(</span>tab<span>,</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> h<span>)</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>// 如果指定位置元素存在，头结点hash值相同</span>\n        <span>if</span> <span>(</span><span>(</span>eh <span>=</span> e<span>.</span>hash<span>)</span> <span>==</span> h<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span><span>(</span>ek <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>ek <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>ek<span>)</span><span>)</span><span>)</span>\n                <span>// key hash 值相等，key值相同，直接返回元素 value</span>\n                <span>return</span> e<span>.</span>val<span>;</span>\n        <span>}</span>\n        <span>else</span> <span>if</span> <span>(</span>eh <span>&lt;</span> <span>0</span><span>)</span>\n            <span>// 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span>\n            <span>return</span> <span>(</span>p <span>=</span> e<span>.</span><span>find</span><span>(</span>h<span>,</span> key<span>)</span><span>)</span> <span>!=</span> <span>null</span> <span>?</span> p<span>.</span>val <span>:</span> <span>null</span><span>;</span>\n        <span>while</span> <span>(</span><span>(</span>e <span>=</span> e<span>.</span>next<span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>// 是链表，遍历查找</span>\n            <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> h <span>&amp;&amp;</span>\n                <span>(</span><span>(</span>ek <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>ek <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>ek<span>)</span><span>)</span><span>)</span><span>)</span>\n                <span>return</span> e<span>.</span>val<span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>总结一下 get 过程：</p>\n<ol>\n<li>根据 hash 值计算位置。</li>\n<li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li>\n<li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li>\n<li>如果是链表，遍历查找之。</li>\n</ol>\n<p>总结：</p>\n<p>总的来说 ConcurrentHashMap 在 Java8 中相对于 Java7 来说变化还是挺大的，</p>\n<h2 id=\"_3-总结\"> 3.  总结</h2>\n<p>Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p>\n<p>Java8 中的 ConcurrentHashMap  使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了  <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p>\n<p>有些同学可能对 Synchronized 的性能存在疑问，其实 Synchronized 锁自从引入锁升级策略后，性能不再是问题，有兴趣的同学可以自己了解下 Synchronized 的<strong>锁升级</strong>。</p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "反射机制详解！",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/basis/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/basis/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/",
      "content_html": "<h2 id=\"何为反射\"> 何为反射？</h2>\n<p>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。</p>\n<p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。</p>\n<p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>\n<h2 id=\"反射的应用场景了解么\"> 反射的应用场景了解么？</h2>\n<p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。</p>\n<p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p>\n<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>\n<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>DebugInvocationHandler</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>\n    <span>/**\n     * 代理类中的真实对象\n     */</span>\n    <span>private</span> <span>final</span> <span>Object</span> target<span>;</span>\n\n    <span>public</span> <span>DebugInvocationHandler</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>target <span>=</span> target<span>;</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InvocationTargetException</span><span>,</span> <span>IllegalAccessException</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before method \"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Object</span> result <span>=</span> method<span>.</span><span>invoke</span><span>(</span>target<span>,</span> args<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after method \"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> result<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>\n<p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>\n<p>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>\n<h2 id=\"谈谈反射机制的优缺点\"> 谈谈反射机制的优缺点</h2>\n<p><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</p>\n<p><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。相关阅读：<a href=\"https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow\" target=\"_blank\" rel=\"noopener noreferrer\">Java Reflection: Why is it so slow?</a></p>\n<h2 id=\"反射实战\"> 反射实战</h2>\n<h3 id=\"获取-class-对象的四种方式\"> 获取 Class 对象的四种方式</h3>\n<p>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:</p>\n<p><strong>1.知道具体类的情况下可以使用：</strong></p>\n<div><pre><code><span>Class</span> alunbarClass <span>=</span> <span>TargetObject</span><span>.</span><span>class</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化</p>\n<p><strong>2.通过 <code>Class.forName()</code>传入类的路径获取：</strong></p>\n<div><pre><code><span>Class</span> alunbarClass1 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"cn.javaguide.TargetObject\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>3.通过对象实例<code>instance.getClass()</code>获取：</strong></p>\n<div><pre><code><span>TargetObject</span> o <span>=</span> <span>new</span> <span>TargetObject</span><span>(</span><span>)</span><span>;</span>\n<span>Class</span> alunbarClass2 <span>=</span> o<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><strong>4.通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取:</strong></p>\n<div><pre><code><span>Class</span> clazz <span>=</span> <span>ClassLoader</span><span>.</span><span>loadClass</span><span>(</span><span>\"cn.javaguide.TargetObject\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一些列步骤，静态块和静态对象不会得到执行</p>\n<h3 id=\"反射的一些基本操作\"> 反射的一些基本操作</h3>\n<p>1.创建一个我们要使用反射操作的类 <code>TargetObject</code>。</p>\n<div><pre><code><span>package</span> <span>cn<span>.</span>javaguide</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>TargetObject</span> <span>{</span>\n    <span>private</span> <span>String</span> value<span>;</span>\n\n    <span>public</span> <span>TargetObject</span><span>(</span><span>)</span> <span>{</span>\n        value <span>=</span> <span>\"JavaGuide\"</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>publicMethod</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"I love \"</span> <span>+</span> s<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>privateMethod</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"value is \"</span> <span>+</span> value<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>2.使用反射操作这个类的方法以及参数</p>\n<div><pre><code><span>package</span> <span>cn<span>.</span>javaguide</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Field</span><span>;</span>\n<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>InvocationTargetException</span><span>;</span>\n<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>ClassNotFoundException</span><span>,</span> <span>NoSuchMethodException</span><span>,</span> <span>IllegalAccessException</span><span>,</span> <span>InstantiationException</span><span>,</span> <span>InvocationTargetException</span><span>,</span> <span>NoSuchFieldException</span> <span>{</span>\n        <span>/**\n         * 获取TargetObject类的Class对象并且创建TargetObject类实例\n         */</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> tagetClass <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"cn.javaguide.TargetObject\"</span><span>)</span><span>;</span>\n        <span>TargetObject</span> targetObject <span>=</span> <span>(</span><span>TargetObject</span><span>)</span> tagetClass<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>/**\n         * 获取所有类中所有定义的方法\n         */</span>\n        <span>Method</span><span>[</span><span>]</span> methods <span>=</span> tagetClass<span>.</span><span>getDeclaredMethods</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>Method</span> method <span>:</span> methods<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>/**\n         * 获取指定方法并调用\n         */</span>\n        <span>Method</span> publicMethod <span>=</span> tagetClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"publicMethod\"</span><span>,</span>\n                <span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>\n\n        publicMethod<span>.</span><span>invoke</span><span>(</span>targetObject<span>,</span> <span>\"JavaGuide\"</span><span>)</span><span>;</span>\n        <span>/**\n         * 获取指定参数并对参数进行修改\n         */</span>\n        <span>Field</span> field <span>=</span> tagetClass<span>.</span><span>getDeclaredField</span><span>(</span><span>\"value\"</span><span>)</span><span>;</span>\n        <span>//为了对类中的参数进行修改我们取消安全检查</span>\n        field<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        field<span>.</span><span>set</span><span>(</span>targetObject<span>,</span> <span>\"JavaGuide\"</span><span>)</span><span>;</span>\n        <span>/**\n         * 调用 private 方法\n         */</span>\n        <span>Method</span> privateMethod <span>=</span> tagetClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"privateMethod\"</span><span>)</span><span>;</span>\n        <span>//为了调用private方法我们取消安全检查</span>\n        privateMethod<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        privateMethod<span>.</span><span>invoke</span><span>(</span>targetObject<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p>输出内容：</p>\n<div><pre><code>publicMethod\nprivateMethod\nI love JavaGuide\nvalue is JavaGuide\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>注意</strong> : 有读者提到上面代码运行会抛出 <code>ClassNotFoundException</code> 异常,具体原因是你没有下面把这段代码的包名替换成自己创建的 <code>TargetObject</code> 所在的包 。</p>\n<div><pre><code><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> tagetClass <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"cn.javaguide.TargetObject\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java基础知识&面试题总结",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/",
      "content_html": "<h2 id=\"基础概念与常识\"> 基础概念与常识</h2>\n<h3 id=\"java-语言有哪些特点\"> Java 语言有哪些特点?</h3>\n<ol>\n<li>简单易学；</li>\n<li>面向对象（封装，继承，多态）；</li>\n<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>\n<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>\n<li>可靠性；</li>\n<li>安全性；</li>\n<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>\n<li>编译与解释并存；</li>\n</ol>\n<blockquote>\n<p><strong>🐛 修正（参见： <a href=\"https://github.com/Snailclimb/JavaGuide/issues/544\" target=\"_blank\" rel=\"noopener noreferrer\">issue#544</a>）</strong> ：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用<code>std::thread</code>和<code>std::async</code>来创建线程。参考链接：http://www.cplusplus.com/reference/thread/thread/?kw=thread</p>\n</blockquote>\n<h3 id=\"jvm-vs-jdk-vs-jre\"> JVM vs JDK vs JRE</h3>\n<h4 id=\"jvm\"> JVM</h4>\n<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>\n<p><strong>什么是字节码?采用字节码的好处是什么?</strong></p>\n<blockquote>\n<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>\n</blockquote>\n<p><strong>Java 程序从源代码到运行一般有下面 3 步：</strong></p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java 程序运行过程.png\" alt=\"Java程序运行过程\" /></p>\n<p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p>\n<blockquote>\n<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>\n</blockquote>\n<p><strong>总结：</strong></p>\n<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>\n<h4 id=\"jdk-和-jre\"> JDK 和 JRE</h4>\n<p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>\n<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>\n<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>\n<h3 id=\"为什么说-java-语言-编译与解释并存\"> 为什么说 Java 语言“编译与解释并存”？</h3>\n<p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读，\n有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p>\n<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>*.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。</p>\n<h3 id=\"oracle-jdk-和-openjdk-的对比\"> Oracle JDK 和 OpenJDK 的对比</h3>\n<p>可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle JDK 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。</p>\n<p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：</p>\n<blockquote>\n<p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p>\n<p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p>\n</blockquote>\n<p><strong>总结：</strong></p>\n<ol>\n<li>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：<a href=\"https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence\" target=\"_blank\" rel=\"noopener noreferrer\">https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence</a> 。</li>\n<li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li>\n<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li>\n<li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li>\n<li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>\n<li>Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li>\n</ol>\n<p>🌈 拓展一下：</p>\n<ul>\n<li>BCL 协议（Oracle Binary Code License Agreement）： 可以使用JDK（支持商用），但是不能进行修改。</li>\n<li>OTN 协议（Oracle Technology Network License Agreement）： 11 及之后新发布的JDK用的都是这个协议，可以自己私下用，但是商用需要付费。</li>\n</ul>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/20210425151835918.png\" alt=\"\" /></p>\n<p>相关阅读👍：<a href=\"https://www.baeldung.com/oracle-jdk-vs-openjdk\" target=\"_blank\" rel=\"noopener noreferrer\">《Differences Between Oracle JDK and OpenJDK》</a></p>\n<h3 id=\"java-和-c-的区别\"> Java 和 C++的区别?</h3>\n<p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！</p>\n<ul>\n<li>都是面向对象的语言，都支持封装、继承和多态</li>\n<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>\n<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>\n<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li>\n<li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li>\n<li>......</li>\n</ul>\n<h3 id=\"import-java-和-javax-有什么区别\"> import java 和 javax 有什么区别？</h3>\n<p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。</p>\n<p>所以，实际上 java 和 javax 没有区别。这都是一个名字。</p>\n<h2 id=\"基本语法\"> 基本语法</h2>\n<h3 id=\"字符型常量和字符串常量的区别\"> 字符型常量和字符串常量的区别?</h3>\n<ol>\n<li>\n<p><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符</p>\n</li>\n<li>\n<p><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</p>\n</li>\n<li>\n<p><strong>占内存大小</strong> ： 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>),</p>\n<blockquote>\n<p>字符封装类 <code>Character</code> 有一个成员常量 <code>Character.SIZE</code> 值为 16,单位是<code>bits</code>,该值除以 8(<code>1byte=8bits</code>)后就可以得到 2 个字节</p>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>java 编程思想第四版：2.2.2 节\n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-15/86735519.jpg\" alt=\"\" /></p>\n</blockquote>\n<h3 id=\"注释\"> 注释</h3>\n<p>Java 中的注释有三种：</p>\n<ol>\n<li>\n<p>单行注释</p>\n</li>\n<li>\n<p>多行注释</p>\n</li>\n<li>\n<p>文档注释。</p>\n</li>\n</ol>\n<p>在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行(编译器在编译代码之前会把代码中的所有注释抹掉,字节码中不保留注释)，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。</p>\n<p>《Clean Code》这本书明确指出：</p>\n<blockquote>\n<p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong></p>\n<p><strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</strong></p>\n<p>举个例子：</p>\n<p>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可</p>\n<div><pre><code><span>// check to see if the employee is eligible for full benefits</span>\n<span>if</span> <span>(</span><span>(</span>employee<span>.</span>flags <span>&amp;</span> HOURLY_FLAG<span>)</span> <span>&amp;&amp;</span> <span>(</span>employee<span>.</span>age <span>></span> <span>65</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>应替换为</p>\n<div><pre><code><span>if</span> <span>(</span>employee<span>.</span><span>isEligibleForFullBenefits</span><span>(</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div></blockquote>\n<h3 id=\"标识符和关键字的区别是什么\"> 标识符和关键字的区别是什么？</h3>\n<p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，标识符就是一个名字。但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。因此，关键字是被赋予特殊含义的标识符。比如，在我们的日常生活中 ，“警察局”这个名字已经被赋予了特殊的含义，所以如果你开一家店，店的名字不能叫“警察局”，“警察局”就是我们日常生活中的关键字。</p>\n<h3 id=\"java-中有哪些常见的关键字\"> Java 中有哪些常见的关键字？</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">分类</th>\n<th>关键字</th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">访问控制</td>\n<td>private</td>\n<td>protected</td>\n<td>public</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">类，方法和变量修饰符</td>\n<td>abstract</td>\n<td>class</td>\n<td>extends</td>\n<td>final</td>\n<td>implements</td>\n<td>interface</td>\n<td>native</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td>new</td>\n<td>static</td>\n<td>strictfp</td>\n<td>synchronized</td>\n<td>transient</td>\n<td>volatile</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">程序控制</td>\n<td>break</td>\n<td>continue</td>\n<td>return</td>\n<td>do</td>\n<td>while</td>\n<td>if</td>\n<td>else</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td>for</td>\n<td>instanceof</td>\n<td>switch</td>\n<td>case</td>\n<td>default</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">错误处理</td>\n<td>try</td>\n<td>catch</td>\n<td>throw</td>\n<td>throws</td>\n<td>finally</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">包相关</td>\n<td>import</td>\n<td>package</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">基本类型</td>\n<td>boolean</td>\n<td>byte</td>\n<td>char</td>\n<td>double</td>\n<td>float</td>\n<td>int</td>\n<td>long</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td>short</td>\n<td>null</td>\n<td>true</td>\n<td>false</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">变量引用</td>\n<td>super</td>\n<td>this</td>\n<td>void</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">保留字</td>\n<td>goto</td>\n<td>const</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"自增自减运算符\"> 自增自减运算符</h3>\n<p>在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（--）。</p>\n<p>++和--运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 <code>b = ++a</code> 时，先自增（自己增加 1），再赋值（赋值给 b）；当 <code>b = a++</code> 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。</p>\n<h3 id=\"continue、break、和-return-的区别是什么\"> continue、break、和 return 的区别是什么？</h3>\n<p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p>\n<ol>\n<li>continue ：指跳出当前的这一次循环，继续下一次循环。</li>\n<li>break ：指跳出整个循环体，继续执行循环下面的语句。</li>\n</ol>\n<p>return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p>\n<ol>\n<li><code>return;</code> ：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>\n<li><code>return value;</code> ：return 一个特定值，用于有返回值函数的方法</li>\n</ol>\n<h3 id=\"java-泛型了解么-什么是类型擦除-介绍一下常用的通配符\"> Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</h3>\n<p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>\n<p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\nlist<span>.</span><span>add</span><span>(</span><span>12</span><span>)</span><span>;</span>\n<span>//这里直接添加会报错</span>\nlist<span>.</span><span>add</span><span>(</span><span>\"a\"</span><span>)</span><span>;</span>\n<span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>List</span><span>></span></span> clazz <span>=</span> list<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>\n<span>Method</span> add <span>=</span> clazz<span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"add\"</span><span>,</span> <span>Object</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>//但是通过反射添加，是可以的</span>\nadd<span>.</span><span>invoke</span><span>(</span>list<span>,</span> <span>\"kl\"</span><span>)</span><span>;</span>\n\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>list<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。</p>\n<p><strong>1.泛型类</strong>：</p>\n<div><pre><code><span>//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span>\n<span>//在实例化泛型类时，必须指定T的具体类型</span>\n<span>public</span> <span>class</span> <span>Generic</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n\n    <span>private</span> <span>T</span> key<span>;</span>\n\n    <span>public</span> <span>Generic</span><span>(</span><span>T</span> key<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>key <span>=</span> key<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>T</span> <span>getKey</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> key<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>如何实例化泛型类：</p>\n<div><pre><code><span>Generic</span><span><span>&lt;</span><span>Integer</span><span>></span></span> genericInteger <span>=</span> <span>new</span> <span>Generic</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>123456</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>2.泛型接口</strong> ：</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Generator</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>T</span> <span>method</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>实现泛型接口，不指定类型：</p>\n<div><pre><code><span>class</span> <span>GeneratorImpl</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>implements</span> <span>Generator</span><span><span>&lt;</span><span>T</span><span>></span></span><span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>T</span> <span>method</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>null</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>实现泛型接口，指定类型：</p>\n<div><pre><code><span>class</span> <span>GeneratorImpl</span> <span>implements</span> <span>Generator</span><span><span>&lt;</span><span>String</span><span>></span></span><span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>method</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"hello\"</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3.泛型方法</strong> ：</p>\n<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>E</span><span>></span></span> <span>void</span> <span>printArray</span><span>(</span><span>E</span><span>[</span><span>]</span> inputArray<span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>E</span> element <span>:</span> inputArray<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>\"%s \"</span><span>,</span> element<span>)</span><span>;</span>\n    <span>}</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>使用：</p>\n<div><pre><code><span>// 创建不同类型数组： Integer, Double 和 Character</span>\n<span>Integer</span><span>[</span><span>]</span> intArray <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span> <span>}</span><span>;</span>\n<span>String</span><span>[</span><span>]</span> stringArray <span>=</span> <span>{</span> <span>\"Hello\"</span><span>,</span> <span>\"World\"</span> <span>}</span><span>;</span>\n<span>printArray</span><span>(</span>intArray<span>)</span><span>;</span>\n<span>printArray</span><span>(</span>stringArray<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>常用的通配符为： T，E，K，V，？</strong></p>\n<ul>\n<li>？ 表示不确定的 java 类型</li>\n<li>T (type) 表示具体的一个 java 类型</li>\n<li>K V (key value) 分别代表 java 键值中的 Key Value</li>\n<li>E (element) 代表 Element</li>\n</ul>\n<h3 id=\"和-equals-的区别\"> ==和 equals 的区别</h3>\n<p>对于基本数据类型来说，==比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。</p>\n<blockquote>\n<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>\n</blockquote>\n<p><strong><code>equals()</code></strong> 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>\n<p><code>Object</code> 类 <code>equals()</code> 方法：</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span> <span>{</span>\n     <span>return</span> <span>(</span><span>this</span> <span>==</span> obj<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>equals()</code> 方法存在两种使用情况：</p>\n<ul>\n<li><strong>类没有覆盖 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>\n<li><strong>类覆盖了 <code>equals()</code>方法</strong> ：一般我们都覆盖 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>\n</ul>\n<p><strong>举个例子：</strong></p>\n<div><pre><code><span>public</span> <span>class</span> test1 <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>String</span> a <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"ab\"</span><span>)</span><span>;</span> <span>// a 为一个引用</span>\n        <span>String</span> b <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"ab\"</span><span>)</span><span>;</span> <span>// b为另一个引用,对象的内容一样</span>\n        <span>String</span> aa <span>=</span> <span>\"ab\"</span><span>;</span> <span>// 放在常量池中</span>\n        <span>String</span> bb <span>=</span> <span>\"ab\"</span><span>;</span> <span>// 从常量池中查找</span>\n        <span>if</span> <span>(</span>aa <span>==</span> bb<span>)</span> <span>// true</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"aa==bb\"</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>a <span>==</span> b<span>)</span> <span>// false，非同一对象</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"a==b\"</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>a<span>.</span><span>equals</span><span>(</span>b<span>)</span><span>)</span> <span>// true</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"aEQb\"</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>42</span> <span>==</span> <span>42.0</span><span>)</span> <span>{</span> <span>// true</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"true\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>说明：</strong></p>\n<ul>\n<li><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</li>\n<li>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</li>\n</ul>\n<p><code>String</code>类<code>equals()</code>方法：</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> anObject<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>this</span> <span>==</span> anObject<span>)</span> <span>{</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span>anObject <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>\n        <span>String</span> anotherString <span>=</span> <span>(</span><span>String</span><span>)</span>anObject<span>;</span>\n        <span>int</span> n <span>=</span> value<span>.</span>length<span>;</span>\n        <span>if</span> <span>(</span>n <span>==</span> anotherString<span>.</span>value<span>.</span>length<span>)</span> <span>{</span>\n            <span>char</span> v1<span>[</span><span>]</span> <span>=</span> value<span>;</span>\n            <span>char</span> v2<span>[</span><span>]</span> <span>=</span> anotherString<span>.</span>value<span>;</span>\n            <span>int</span> i <span>=</span> <span>0</span><span>;</span>\n            <span>while</span> <span>(</span>n<span>--</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>v1<span>[</span>i<span>]</span> <span>!=</span> v2<span>[</span>i<span>]</span><span>)</span>\n                    <span>return</span> <span>false</span><span>;</span>\n                i<span>++</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"hashcode-与-equals\"> hashCode()与 equals()</h3>\n<p>面试官可能会问你：“你重写过 <code>hashcode</code> 和 <code>equals</code>么，为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？”</p>\n<p><strong>1)hashCode()介绍:</strong></p>\n<p><code>hashCode()</code> 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>\n<div><pre><code><span>public</span> <span>native</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>\n<p><strong>2)为什么要有 hashCode？</strong></p>\n<p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 hashCode？</p>\n<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code> 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>\n<p><strong>3)为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p>\n<p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p>\n<blockquote>\n<p><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>\n</blockquote>\n<p><strong>4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></p>\n<p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p>\n<p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>\n<p>我们刚刚也提到了 <code>HashSet</code>,如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</p>\n<p>更多关于 <code>hashcode()</code> 和 <code>equals()</code> 的内容可以查看：<a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java hashCode() 和 equals()的若干问题解答</a></p>\n<h2 id=\"基本数据类型\"> 基本数据类型</h2>\n<h3 id=\"java-中的几种基本数据类型是什么-对应的包装类型是什么-各自占用多少字节呢\"> Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？</h3>\n<p>Java 中有 8 种基本数据类型，分别为：</p>\n<ol>\n<li>6 种数字类型 ：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code></li>\n<li>1 种字符类型：<code>char</code></li>\n<li>1 种布尔型：<code>boolean</code>。</li>\n</ol>\n<p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">基本类型</th>\n<th style=\"text-align:left\">位数</th>\n<th style=\"text-align:left\">字节</th>\n<th style=\"text-align:left\">默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>int</code></td>\n<td style=\"text-align:left\">32</td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>short</code></td>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>long</code></td>\n<td style=\"text-align:left\">64</td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">0L</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>byte</code></td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>char</code></td>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">'u0000'</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>float</code></td>\n<td style=\"text-align:left\">32</td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">0f</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>double</code></td>\n<td style=\"text-align:left\">64</td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">0d</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>boolean</code></td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">false</td>\n</tr>\n</tbody>\n</table>\n<p>另外，对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li>\n<li><code>char a = 'h'</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号。</li>\n</ol>\n<p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p>\n<p>包装类型不赋值就是 <code>Null</code> ，而基本类型有默认值且不是 <code>Null</code>。</p>\n<p>另外，这个问题建议还可以先从 JVM 层面来分析。</p>\n<p>基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。</p>\n<blockquote>\n<p>《深入理解 Java 虚拟机》 ：局部变量表主要存放了编译期可知的基本数据类型 <strong>（boolean、byte、char、short、int、float、long、double）</strong>、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>\n</blockquote>\n<h3 id=\"自动装箱与拆箱\"> 自动装箱与拆箱</h3>\n<ul>\n<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>\n<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>\n</ul>\n<p>举例：</p>\n<div><pre><code><span>Integer</span> i <span>=</span> <span>10</span><span>;</span>  <span>//装箱</span>\n<span>int</span> n <span>=</span> i<span>;</span>   <span>//拆箱</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>上面这两行代码对应的字节码为：</p>\n<div><pre><code>   L1\n\n    LINENUMBER <span>8</span> L1\n\n    ALOAD <span>0</span>\n\n    BIPUSH <span>10</span>\n\n    INVOKESTATIC java<span>/</span>lang<span>/</span><span>Integer</span><span>.</span>valueOf <span>(</span><span>I</span><span>)</span><span>Ljava</span><span>/</span>lang<span>/</span><span>Integer</span><span>;</span>\n\n    PUTFIELD <span>AutoBoxTest</span><span>.</span>i <span>:</span> <span>Ljava</span><span>/</span>lang<span>/</span><span>Integer</span><span>;</span>\n\n   L2\n\n    LINENUMBER <span>9</span> L2\n\n    ALOAD <span>0</span>\n\n    ALOAD <span>0</span>\n\n    GETFIELD <span>AutoBoxTest</span><span>.</span>i <span>:</span> <span>Ljava</span><span>/</span>lang<span>/</span><span>Integer</span><span>;</span>\n\n    INVOKEVIRTUAL java<span>/</span>lang<span>/</span><span>Integer</span><span>.</span>intValue <span>(</span><span>)</span><span>I</span>\n\n    PUTFIELD <span>AutoBoxTest</span><span>.</span>n <span>:</span> <span>I</span>\n\n    RETURN\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>从字节码中，我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p>\n<p>因此，</p>\n<ul>\n<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>\n<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>\n</ul>\n<h3 id=\"_8-种基本类型的包装类和常量池\"> 8 种基本类型的包装类和常量池</h3>\n<p>Java 基本类型的包装类的大部分都实现了常量池技术。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在[0,127]范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> Or <code>False</code>。</p>\n<p><strong>Integer 缓存源码：</strong></p>\n<div><pre><code><span>/**\n\n*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。\n\n*/</span>\n\n<span>public</span> <span>static</span> <span>Integer</span> <span>valueOf</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n\n    <span>if</span> <span>(</span>i <span>>=</span> <span>IntegerCache</span><span>.</span>low <span>&amp;&amp;</span> i <span>&lt;=</span> <span>IntegerCache</span><span>.</span>high<span>)</span>\n\n      <span>return</span> <span>IntegerCache</span><span>.</span>cache<span>[</span>i <span>+</span> <span>(</span><span>-</span><span>IntegerCache</span><span>.</span>low<span>)</span><span>]</span><span>;</span>\n\n    <span>return</span> <span>new</span> <span>Integer</span><span>(</span>i<span>)</span><span>;</span>\n\n<span>}</span>\n\n<span>private</span> <span>static</span> <span>class</span> <span>IntegerCache</span> <span>{</span>\n\n    <span>static</span> <span>final</span> <span>int</span> low <span>=</span> <span>-</span><span>128</span><span>;</span>\n\n    <span>static</span> <span>final</span> <span>int</span> high<span>;</span>\n\n    <span>static</span> <span>final</span> <span>Integer</span> cache<span>[</span><span>]</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p><strong><code>Character</code> 缓存源码:</strong></p>\n<div><pre><code><span>public</span> <span>static</span> <span>Character</span> <span>valueOf</span><span>(</span><span>char</span> c<span>)</span> <span>{</span>\n\n    <span>if</span> <span>(</span>c <span>&lt;=</span> <span>127</span><span>)</span> <span>{</span> <span>// must cache</span>\n\n      <span>return</span> <span>CharacterCache</span><span>.</span>cache<span>[</span><span>(</span><span>int</span><span>)</span>c<span>]</span><span>;</span>\n\n    <span>}</span>\n\n    <span>return</span> <span>new</span> <span>Character</span><span>(</span>c<span>)</span><span>;</span>\n\n<span>}</span>\n\n\n\n<span>private</span> <span>static</span> <span>class</span> <span>CharacterCache</span> <span>{</span>\n\n    <span>private</span> <span>CharacterCache</span><span>(</span><span>)</span><span>{</span><span>}</span>\n\n\n\n    <span>static</span> <span>final</span> <span>Character</span> cache<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>Character</span><span>[</span><span>127</span> <span>+</span> <span>1</span><span>]</span><span>;</span>\n\n    <span>static</span> <span>{</span>\n\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cache<span>.</span>length<span>;</span> i<span>++</span><span>)</span>\n\n            cache<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Character</span><span>(</span><span>(</span><span>char</span><span>)</span>i<span>)</span><span>;</span>\n\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p><strong><code>Boolean</code> 缓存源码：</strong></p>\n<div><pre><code><span>public</span> <span>static</span> <span>Boolean</span> <span>valueOf</span><span>(</span><span>boolean</span> b<span>)</span> <span>{</span>\n\n    <span>return</span> <span>(</span>b <span>?</span> TRUE <span>:</span> FALSE<span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>\n<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p>\n<div><pre><code><span>Integer</span> i1 <span>=</span> <span>33</span><span>;</span>\n\n<span>Integer</span> i2 <span>=</span> <span>33</span><span>;</span>\n\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1 <span>==</span> i2<span>)</span><span>;</span><span>// 输出 true</span>\n\n<span>Float</span> i11 <span>=</span> <span>333f</span><span>;</span>\n\n<span>Float</span> i22 <span>=</span> <span>333f</span><span>;</span>\n\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i11 <span>==</span> i22<span>)</span><span>;</span><span>// 输出 false</span>\n\n<span>Double</span> i3 <span>=</span> <span>1.2</span><span>;</span>\n\n<span>Double</span> i4 <span>=</span> <span>1.2</span><span>;</span>\n\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i3 <span>==</span> i4<span>)</span><span>;</span><span>// 输出 false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>下面我们来看一下问题。下面的代码的输出结果是 <code>true</code> 还是 <code>flase</code> 呢？</p>\n<div><pre><code><span>Integer</span> i1 <span>=</span> <span>40</span><span>;</span>\n\n<span>Integer</span> i2 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>40</span><span>)</span><span>;</span>\n\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1<span>==</span>i2<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是常量池中的对象。而<code>Integer i1 = new Integer(40)</code> 会直接创建新的对象。</p>\n<p>因此，答案是 <code>false</code> 。你答对了吗？</p>\n<p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210422164544846.png\" alt=\"\" /></p>\n<h2 id=\"方法-函数\"> 方法（函数）</h2>\n<h3 id=\"什么是方法的返回值\"> 什么是方法的返回值?</h3>\n<p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！</p>\n<h3 id=\"方法有哪几种类型\"> 方法有哪几种类型？</h3>\n<p><strong>1.无参数无返回值的方法</strong></p>\n<div><pre><code><span>// 无参数无返回值的方法(如果方法没有返回值，不能不写，必须写void，表示没有返回值)</span>\n<span>public</span> <span>void</span> <span>f1</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"无参数无返回值的方法\"</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>2.有参数无返回值的方法</strong></p>\n<div><pre><code><span>/**\n* 有参数无返回值的方法\n* 参数列表由零组到多组“参数类型+形参名”组合而成，多组参数之间以英文逗号（,）隔开，形参类型和形参名之间以英文空格隔开\n*/</span>\n<span>public</span> <span>void</span> <span>f2</span><span>(</span><span>int</span> a<span>,</span> <span>String</span> b<span>,</span> <span>int</span> c<span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>+</span> <span>\"-->\"</span> <span>+</span> b <span>+</span> <span>\"-->\"</span> <span>+</span> c<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>3.有返回值无参数的方法</strong></p>\n<div><pre><code><span>// 有返回值无参数的方法（返回值可以是任意的类型,在函数里面必须有return关键字返回对应的类型）</span>\n<span>public</span> <span>int</span> <span>f3</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"有返回值无参数的方法\"</span><span>)</span><span>;</span>\n    <span>return</span> <span>2</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>4.有返回值有参数的方法</strong></p>\n<div><pre><code><span>// 有返回值有参数的方法</span>\n<span>public</span> <span>int</span> <span>f4</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n    <span>return</span> a <span>*</span> b<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>5.return 在无返回值方法的特殊使用</strong></p>\n<div><pre><code><span>// return在无返回值方法的特殊使用</span>\n<span>public</span> <span>void</span> <span>f5</span><span>(</span><span>int</span> a<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>a <span>></span> <span>10</span><span>)</span> <span>{</span>\n        <span>return</span><span>;</span><span>//表示结束所在方法 （f5方法）的执行,下方的输出语句不会执行</span>\n    <span>}</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"在一个静态方法内调用一个非静态成员为什么是非法的\"> 在一个静态方法内调用一个非静态成员为什么是非法的?</h3>\n<p>这个需要结合 JVM 的相关知识，静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，然后通过类的实例对象去访问。在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>\n<h3 id=\"静态方法和实例方法有何不同\"> 静态方法和实例方法有何不同？</h3>\n<p><strong>1、调用方式</strong></p>\n<p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p>\n<p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p>\n<p>因此，一般建议使用  <code>类名.方法名</code> 的方式来调用静态方法。</p>\n<div><pre><code>\n<span>public</span> <span>class</span> <span>Person</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>{</span> \n      <span>//......</span>\n    <span>}</span>\n \n    <span>public</span> <span>static</span> <span>void</span> <span>staicMethod</span><span>(</span><span>)</span><span>{</span>\n      <span>//......</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Person</span> person <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>\n        <span>// 调用实例方法</span>\n        person<span>.</span><span>method</span><span>(</span><span>)</span><span>;</span> \n        <span>// 调用静态方法</span>\n        <span>Person</span><span>.</span><span>staicMethod</span><span>(</span><span>)</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>2、访问类成员是否存在限制</strong></p>\n<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>\n<h3 id=\"为什么-java-中只有值传递\"> 为什么 Java 中只有值传递？</h3>\n<p>首先，我们回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。</p>\n<p><strong>按值调用(call by value)</strong> 表示方法接收的是调用者提供的值，<strong>按引用调用（call by reference)</strong> 表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。它用来描述各种程序设计语言（不只是 Java）中方法参数传递方式。</p>\n<p><strong>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p>\n<p><strong>下面通过 3 个例子来给大家说明</strong></p>\n<blockquote>\n<p><strong>example 1</strong></p>\n</blockquote>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>int</span> num1 <span>=</span> <span>10</span><span>;</span>\n    <span>int</span> num2 <span>=</span> <span>20</span><span>;</span>\n\n    <span>swap</span><span>(</span>num1<span>,</span> num2<span>)</span><span>;</span>\n\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"num1 = \"</span> <span>+</span> num1<span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"num2 = \"</span> <span>+</span> num2<span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n    <span>int</span> temp <span>=</span> a<span>;</span>\n    a <span>=</span> b<span>;</span>\n    b <span>=</span> temp<span>;</span>\n\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"a = \"</span> <span>+</span> a<span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"b = \"</span> <span>+</span> b<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>结果：</strong></p>\n<div><pre><code>a = 20\nb = 10\nnum1 = 10\nnum2 = 20\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>解析：</strong></p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/22191348.jpg\" alt=\"example 1 \" /></p>\n<p>在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>\n<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p>\n<blockquote>\n<p><strong>example 2</strong></p>\n</blockquote>\n<div><pre><code>\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span> <span>}</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n\t\t<span>change</span><span>(</span>arr<span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>change</span><span>(</span><span>int</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>\n\t\t<span>// 将数组的第一个元素变为0</span>\n\t\tarray<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>\n\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>结果：</strong></p>\n<div><pre><code>1\n0\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><strong>解析：</strong></p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/3825204.jpg\" alt=\"example 2\" /></p>\n<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>\n<p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>\n<p><strong>很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p>\n<blockquote>\n<p><strong>example 3</strong></p>\n</blockquote>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>// TODO Auto-generated method stub</span>\n\t\t<span>Student</span> s1 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>\"小张\"</span><span>)</span><span>;</span>\n\t\t<span>Student</span> s2 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>\"小李\"</span><span>)</span><span>;</span>\n\t\t<span>Test</span><span>.</span><span>swap</span><span>(</span>s1<span>,</span> s2<span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"s1:\"</span> <span>+</span> s1<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"s2:\"</span> <span>+</span> s2<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>Student</span> x<span>,</span> <span>Student</span> y<span>)</span> <span>{</span>\n\t\t<span>Student</span> temp <span>=</span> x<span>;</span>\n\t\tx <span>=</span> y<span>;</span>\n\t\ty <span>=</span> temp<span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"x:\"</span> <span>+</span> x<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"y:\"</span> <span>+</span> y<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><strong>结果：</strong></p>\n<div><pre><code>x:小李\ny:小张\ns1:小张\ns2:小李\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>解析：</strong></p>\n<p>交换之前：</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/88729818.jpg\" alt=\"\" /></p>\n<p>交换之后：</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/34384414.jpg\" alt=\"\" /></p>\n<p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>\n<blockquote>\n<p><strong>总结</strong></p>\n</blockquote>\n<p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按\n值传递的。</p>\n<p>下面再总结一下 Java 中方法参数的使用情况：</p>\n<ul>\n<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li>\n<li>一个方法可以改变一个对象参数的状态。</li>\n<li>一个方法不能让对象参数引用一个新的对象。</li>\n</ul>\n<p><strong>参考：</strong></p>\n<p>《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节</p>\n<h3 id=\"重载和重写的区别\"> 重载和重写的区别</h3>\n<blockquote>\n<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>\n<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>\n</blockquote>\n<h4 id=\"重载\"> 重载</h4>\n<p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>\n<p>下面是《Java 核心技术》对重载这个概念的介绍：</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktopjava核心技术-重载.jpg\" alt=\"\" /></p>\n<p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>\n<h4 id=\"重写\"> 重写</h4>\n<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>\n<ol>\n<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>\n<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>\n<li>构造方法无法被重写</li>\n</ol>\n<p>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</p>\n<p>暖心的 Guide 哥最后再来个图表总结一下！</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">区别点</th>\n<th style=\"text-align:left\">重载方法</th>\n<th style=\"text-align:left\">重写方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">发生范围</td>\n<td style=\"text-align:left\">同一个类</td>\n<td style=\"text-align:left\">子类</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">参数列表</td>\n<td style=\"text-align:left\">必须修改</td>\n<td style=\"text-align:left\">一定不能修改</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">返回类型</td>\n<td style=\"text-align:left\">可修改</td>\n<td style=\"text-align:left\">子类方法返回值类型应比父类方法返回值类型更小或相等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">异常</td>\n<td style=\"text-align:left\">可修改</td>\n<td style=\"text-align:left\">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">访问修饰符</td>\n<td style=\"text-align:left\">可修改</td>\n<td style=\"text-align:left\">一定不能做更严格的限制（可以降低限制）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">发生阶段</td>\n<td style=\"text-align:left\">编译期</td>\n<td style=\"text-align:left\">运行期</td>\n</tr>\n</tbody>\n</table>\n<p><strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》,<a href=\"https://github.com/Snailclimb/JavaGuide/issues/892\" target=\"_blank\" rel=\"noopener noreferrer\">issue#892</a> ）：</p>\n<ul>\n<li>“两同”即方法名相同、形参列表相同；</li>\n<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>\n<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>\n</ul>\n<p>⭐️ 关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Hero</span> <span>{</span>\n    <span>public</span> <span>String</span> <span>name</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"超级英雄\"</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>public</span> <span>class</span> <span>SuperMan</span> <span>extends</span> <span>Hero</span><span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>name</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"超人\"</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>Hero</span> <span>hero</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>Hero</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>SuperSuperMan</span> <span>extends</span> <span>SuperMan</span> <span>{</span>\n    <span>public</span> <span>String</span> <span>name</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"超级超级英雄\"</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>SuperMan</span> <span>hero</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>SuperMan</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id=\"深拷贝-vs-浅拷贝\"> 深拷贝 vs 浅拷贝</h3>\n<ol>\n<li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>\n<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>\n</ol>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/java-deep-and-shallow-copy.jpg\" alt=\"deep and shallow copy\" /></p>\n<h2 id=\"java-面向对象\"> Java 面向对象</h2>\n<h3 id=\"面向对象和面向过程的区别\"> 面向对象和面向过程的区别</h3>\n<ul>\n<li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li>\n<li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li>\n</ul>\n<p>参见 issue : <a href=\"https://github.com/Snailclimb/JavaGuide/issues/431\" target=\"_blank\" rel=\"noopener noreferrer\">面向过程 ：面向过程性能比面向对象高？？</a></p>\n<blockquote>\n<p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。</p>\n<p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p>\n</blockquote>\n<h3 id=\"成员变量与局部变量的区别有哪些\"> 成员变量与局部变量的区别有哪些？</h3>\n<ol>\n<li>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li>\n<li>从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>\n<li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>\n<li>从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>\n</ol>\n<h3 id=\"创建一个对象用什么运算符-对象实体与对象引用有何不同\"> 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3>\n<p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p>\n<p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>\n<h3 id=\"对象的相等与指向他们的引用相等-两者有什么不同\"> 对象的相等与指向他们的引用相等,两者有什么不同?</h3>\n<p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>\n<h3 id=\"一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗-为什么\"> 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h3>\n<p>构造方法主要作用是完成对类对象的初始化工作。</p>\n<p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>\n<h3 id=\"构造方法有哪些特点-是否可被-override\"> 构造方法有哪些特点？是否可被 override?</h3>\n<p>特点：</p>\n<ol>\n<li>名字与类名相同。</li>\n<li>没有返回值，但不能用 void 声明构造函数。</li>\n<li>生成类的对象时自动执行，无需调用。</li>\n</ol>\n<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>\n<h3 id=\"面向对象三大特征\"> 面向对象三大特征</h3>\n<h4 id=\"封装\"> 封装</h4>\n<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Student</span> <span>{</span>\n    <span>private</span> <span>int</span> id<span>;</span><span>//id属性私有化</span>\n    <span>private</span> <span>String</span> name<span>;</span><span>//name属性私有化</span>\n\n    <span>//获取id的方法</span>\n    <span>public</span> <span>int</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> id<span>;</span>\n    <span>}</span>\n\n    <span>//设置id的方法</span>\n    <span>public</span> <span>void</span> <span>setId</span><span>(</span><span>int</span> id<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>id <span>=</span> id<span>;</span>\n    <span>}</span>\n\n    <span>//获取name的方法</span>\n    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n\n    <span>//设置name的方法</span>\n    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h4 id=\"继承\"> 继承</h4>\n<p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>\n<p><strong>关于继承如下 3 点请记住：</strong></p>\n<ol>\n<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>\n<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>\n<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>\n</ol>\n<h4 id=\"多态\"> 多态</h4>\n<p>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</p>\n<p><strong>多态的特点:</strong></p>\n<ul>\n<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>\n<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>\n<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>\n<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>\n</ul>\n<h3 id=\"string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的\"> String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h3>\n<p><strong>可变性</strong></p>\n<p>简单的来说：<code>String</code> 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以<code>String</code> 对象是不可变的。</p>\n<blockquote>\n<p>补充（来自<a href=\"https://github.com/Snailclimb/JavaGuide/issues/675\" target=\"_blank\" rel=\"noopener noreferrer\">issue 675</a>）：在 Java 9 之后，String 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p>\n</blockquote>\n<p>而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p>\n<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 的构造方法都是调用父类构造方法也就是<code>AbstractStringBuilder</code> 实现的，大家可以自行查阅源码。</p>\n<p><code>AbstractStringBuilder.java</code></p>\n<div><pre><code><span>abstract</span> <span>class</span> <span>AbstractStringBuilder</span> <span>implements</span> <span>Appendable</span><span>,</span> <span>CharSequence</span> <span>{</span>\n    <span>/**\n     * The value is used for character storage.\n     */</span>\n    <span>char</span><span>[</span><span>]</span> value<span>;</span>\n\n    <span>/**\n     * The count is the number of characters used.\n     */</span>\n    <span>int</span> count<span>;</span>\n\n    <span>AbstractStringBuilder</span><span>(</span><span>int</span> capacity<span>)</span> <span>{</span>\n        value <span>=</span> <span>new</span> <span>char</span><span>[</span>capacity<span>]</span><span>;</span>\n    <span>}</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>线程安全性</strong></p>\n<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>\n<p><strong>性能</strong></p>\n<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>\n<p><strong>对于三者使用的总结：</strong></p>\n<ol>\n<li>操作少量的数据: 适用 <code>String</code></li>\n<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>\n<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>\n</ol>\n<h3 id=\"object-类的常见方法总结\"> Object 类的常见方法总结</h3>\n<p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>\n<div><pre><code><span>public</span> <span>final</span> <span>native</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getClass</span><span>(</span><span>)</span><span>//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span>\n\n<span>public</span> <span>native</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span>\n<span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span><span>//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span>\n\n<span>protected</span> <span>native</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span><span>//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span>\n\n<span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span><span>//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span>\n\n<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notify</span><span>(</span><span>)</span><span>//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span>\n\n<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notifyAll</span><span>(</span><span>)</span><span>//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span>\n\n<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>)</span> <span>throws</span> <span>InterruptedException</span><span>//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span>\n\n<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>,</span> <span>int</span> nanos<span>)</span> <span>throws</span> <span>InterruptedException</span><span>//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span>\n\n<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span><span>//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span>\n\n<span>protected</span> <span>void</span> <span>finalize</span><span>(</span><span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span> <span>}</span><span>//实例被垃圾回收器回收的时候触发的操作</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id=\"反射\"> 反射</h2>\n<h3 id=\"何为反射\"> 何为反射？</h3>\n<p>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。</p>\n<p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。</p>\n<p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>\n<h3 id=\"反射机制优缺点\"> 反射机制优缺点</h3>\n<ul>\n<li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>\n<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。<a href=\"https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow\" target=\"_blank\" rel=\"noopener noreferrer\">Java Reflection: Why is it so slow?</a></li>\n</ul>\n<h3 id=\"反射的应用场景\"> 反射的应用场景</h3>\n<p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。</p>\n<p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p>\n<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>\n<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>DebugInvocationHandler</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>\n    <span>/**\n     * 代理类中的真实对象\n     */</span>\n    <span>private</span> <span>final</span> <span>Object</span> target<span>;</span>\n\n    <span>public</span> <span>DebugInvocationHandler</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>target <span>=</span> target<span>;</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InvocationTargetException</span><span>,</span> <span>IllegalAccessException</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before method \"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Object</span> result <span>=</span> method<span>.</span><span>invoke</span><span>(</span>target<span>,</span> args<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after method \"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> result<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>\n<p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>\n<p>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>\n<h2 id=\"异常\"> 异常</h2>\n<h3 id=\"java-异常类层次结构图\"> Java 异常类层次结构图</h3>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java异常类层次结构图.png\" alt=\"\" /></p>\n<p style=\"font-size:13px;text-align:right\">图片来自：https://simplesnippets.tech/exception-handling-in-java-part-1/</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java异常类层次结构图2.png\" alt=\"\" /></p>\n<p style=\"font-size:13px;text-align:right\">图片来自：https://chercher.tech/java-programming/exceptions-java</p>\n<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p>\n<p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>\n<ul>\n<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</li>\n<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>\n</ul>\n<p><strong>受检查异常</strong></p>\n<p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/check-exception.png\" alt=\"check-exception\" /></p>\n<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>...。</p>\n<p><strong>不受检查异常</strong></p>\n<p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>\n<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：<code>NullPointerException</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p>\n<h3 id=\"throwable-类常用方法\"> Throwable 类常用方法</h3>\n<ul>\n<li><strong><code>public String getMessage()</code></strong>:返回异常发生时的简要描述</li>\n<li><strong><code>public String toString()</code></strong>:返回异常发生时的详细信息</li>\n<li><strong><code>public String getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>\n<li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>\n</ul>\n<h3 id=\"try-catch-finally\"> try-catch-finally</h3>\n<ul>\n<li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>\n<li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li>\n<li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>\n</ul>\n<p><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p>\n<ol>\n<li>在 <code>try</code> 或 <code>finally</code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</li>\n<li>程序所在的线程死亡。</li>\n<li>关闭 CPU。</li>\n</ol>\n<p>下面这部分内容来自 issue:<a href=\"https://github.com/Snailclimb/JavaGuide/issues/190\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Snailclimb/JavaGuide/issues/190</a>。</p>\n<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>f</span><span>(</span><span>int</span> value<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>return</span> value <span>*</span> value<span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            <span>if</span> <span>(</span>value <span>==</span> <span>2</span><span>)</span> <span>{</span>\n                <span>return</span> <span>0</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p>\n<h3 id=\"使用-try-with-resources-来代替try-catch-finally\"> 使用 <code>try-with-resources</code> 来代替<code>try-catch-finally</code></h3>\n<ol>\n<li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li>\n<li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>\n</ol>\n<p>《Effecitve Java》中明确指出：</p>\n<blockquote>\n<p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p>\n</blockquote>\n<p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p>\n<div><pre><code>        <span>//读取文本文件的内容</span>\n        <span>Scanner</span> scanner <span>=</span> <span>null</span><span>;</span>\n        <span>try</span> <span>{</span>\n            scanner <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>new</span> <span>File</span><span>(</span><span>\"D://read.txt\"</span><span>)</span><span>)</span><span>;</span>\n            <span>while</span> <span>(</span>scanner<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>scanner<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>FileNotFoundException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            <span>if</span> <span>(</span>scanner <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                scanner<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>\n<div><pre><code><span>try</span> <span>(</span><span>Scanner</span> scanner <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>new</span> <span>File</span><span>(</span><span>\"test.txt\"</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n    <span>while</span> <span>(</span>scanner<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>scanner<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span> <span>catch</span> <span>(</span><span>FileNotFoundException</span> fnfe<span>)</span> <span>{</span>\n    fnfe<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p>\n<p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p>\n<div><pre><code><span>try</span> <span>(</span><span>BufferedInputStream</span> bin <span>=</span> <span>new</span> <span>BufferedInputStream</span><span>(</span><span>new</span> <span>FileInputStream</span><span>(</span><span>new</span> <span>File</span><span>(</span><span>\"test.txt\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n             <span>BufferedOutputStream</span> bout <span>=</span> <span>new</span> <span>BufferedOutputStream</span><span>(</span><span>new</span> <span>FileOutputStream</span><span>(</span><span>new</span> <span>File</span><span>(</span><span>\"out.txt\"</span><span>)</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            <span>int</span> b<span>;</span>\n            <span>while</span> <span>(</span><span>(</span>b <span>=</span> bin<span>.</span><span>read</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span>\n                bout<span>.</span><span>write</span><span>(</span>b<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"i-o-流\"> I/O 流</h2>\n<h3 id=\"什么是序列化-什么是反序列化\"> 什么是序列化?什么是反序列化?</h3>\n<p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>\n<p>简单来说：</p>\n<ul>\n<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>\n<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>\n</ul>\n<p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p>\n<p>维基百科是如是介绍序列化的：</p>\n<blockquote>\n<p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p>\n</blockquote>\n<p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/a478c74d-2c48-40ae-9374-87aacf05188c.png\" alt=\"\" /></p>\n<p style=\"text-align:right;font-size:13px;color:gray\">https://www.corejavaguru.com/java/serialization/interview-questions-1</p>\n<h3 id=\"java-序列化中如果有些字段不想进行序列化-怎么办\"> Java 序列化中如果有些字段不想进行序列化，怎么办？</h3>\n<p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>\n<p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p>\n<p>关于 <code>transient</code> 还有几点注意：</p>\n<ul>\n<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>\n<li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>\n<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>\n</ul>\n<h3 id=\"获取用键盘输入常用的两种方法\"> 获取用键盘输入常用的两种方法</h3>\n<p>方法 1：通过 <code>Scanner</code></p>\n<div><pre><code><span>Scanner</span> input <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>\n<span>String</span> s  <span>=</span> input<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>;</span>\ninput<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>方法 2：通过 <code>BufferedReader</code></p>\n<div><pre><code><span>BufferedReader</span> input <span>=</span> <span>new</span> <span>BufferedReader</span><span>(</span><span>new</span> <span>InputStreamReader</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>)</span><span>;</span>\n<span>String</span> s <span>=</span> input<span>.</span><span>readLine</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"java-中-io-流分为几种\"> Java 中 IO 流分为几种?</h3>\n<ul>\n<li>按照流的流向分，可以分为输入流和输出流；</li>\n<li>按照操作单元划分，可以划分为字节流和字符流；</li>\n<li>按照流的角色划分为节点流和处理流。</li>\n</ul>\n<p>Java IO 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>\n<ul>\n<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>\n<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>\n</ul>\n<p>按操作方式分类结构图：</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-操作方式分类.png\" alt=\"IO-操作方式分类\" /></p>\n<p>按操作对象分类结构图：</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-操作对象分类.png\" alt=\"IO-操作对象分类\" /></p>\n<h3 id=\"既然有了字节流-为什么还要有字符流\"> 既然有了字节流,为什么还要有字符流?</h3>\n<p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>\n<p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>\n<h2 id=\"_4-参考\"> 4. 参考</h2>\n<ul>\n<li>https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre</li>\n<li>https://www.educba.com/oracle-vs-openjdk/</li>\n<li>https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk 基础概念与常识</li>\n</ul>\n",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java集合使用注意事项总结",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/collection/java%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E6%80%BB%E7%BB%93/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/collection/java%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E6%80%BB%E7%BB%93/",
      "content_html": "<p>这篇文章我根据《阿里巴巴 Java 开发手册》总结了关于集合使用常见的注意事项以及其具体原理。</p>\n<p>强烈建议小伙伴们多多阅读几遍，避免自己写代码的时候出现这些低级的问题。</p>\n<h2 id=\"集合判空\"> 集合判空</h2>\n<p>《阿里巴巴 Java 开发手册》的描述如下：</p>\n<blockquote>\n<p><strong>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式。</strong></p>\n</blockquote>\n<p>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 O(1)。</p>\n<p>绝大部分我们使用的集合的 <code>size()</code> 方法的时间复杂度也是 O(1)，不过，也有很多复杂度不是 O(1) 的，比如 <code>java.util.concurrent</code> 包下的某些集合（<code>ConcurrentLinkedQueue</code> 、<code>ConcurrentHashMap</code>...）。</p>\n<p>下面是 <code>ConcurrentHashMap</code> 的 <code>size()</code> 方法和 <code>isEmpty()</code> 方法的源码。</p>\n<div><pre><code><span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>\n    <span>long</span> n <span>=</span> <span>sumCount</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> <span>(</span><span>(</span>n <span>&lt;</span> <span>0L</span><span>)</span> <span>?</span> <span>0</span> <span>:</span>\n            <span>(</span>n <span>></span> <span>(</span><span>long</span><span>)</span><span>Integer</span><span>.</span>MAX_VALUE<span>)</span> <span>?</span> <span>Integer</span><span>.</span>MAX_VALUE <span>:</span>\n            <span>(</span><span>int</span><span>)</span>n<span>)</span><span>;</span>\n<span>}</span>\n<span>final</span> <span>long</span> <span>sumCount</span><span>(</span><span>)</span> <span>{</span>\n    <span>CounterCell</span><span>[</span><span>]</span> as <span>=</span> counterCells<span>;</span> <span>CounterCell</span> a<span>;</span>\n    <span>long</span> sum <span>=</span> baseCount<span>;</span>\n    <span>if</span> <span>(</span>as <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> as<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span><span>(</span>a <span>=</span> as<span>[</span>i<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span>\n                sum <span>+=</span> a<span>.</span>value<span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> sum<span>;</span>\n<span>}</span>\n<span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>sumCount</span><span>(</span><span>)</span> <span>&lt;=</span> <span>0L</span><span>;</span> <span>// ignore transient negative values</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id=\"集合转-map\"> 集合转 Map</h2>\n<p>《阿里巴巴 Java 开发手册》的描述如下：</p>\n<blockquote>\n<p><strong>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</strong></p>\n</blockquote>\n<div><pre><code><span>class</span> <span>Person</span> <span>{</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n    <span>private</span> <span>String</span> phoneNumber<span>;</span>\n     <span>// getters and setters</span>\n<span>}</span>\n\n<span>List</span><span><span>&lt;</span><span>Person</span><span>></span></span> bookList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\nbookList<span>.</span><span>add</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>\"jack\"</span><span>,</span><span>\"18163138123\"</span><span>)</span><span>)</span><span>;</span>\nbookList<span>.</span><span>add</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>\"martin\"</span><span>,</span><span>null</span><span>)</span><span>)</span><span>;</span>\n<span>// 空指针异常</span>\nbookList<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toMap</span><span>(</span><span>Person</span><span>::</span><span>getName</span><span>,</span> <span>Person</span><span>::</span><span>getPhoneNumber</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>下面我们来解释一下原因。</p>\n<p>首先，我们来看 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法 ，可以看到其内部调用了 <code>Map</code> 接口的 <code>merge()</code> 方法。</p>\n<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>,</span> <span>K</span><span>,</span> <span>U</span><span>,</span> <span>M</span> <span>extends</span> <span>Map</span><span>&lt;</span><span>K</span><span>,</span> <span>U</span><span>></span><span>></span></span>\n<span>Collector</span><span><span>&lt;</span><span>T</span><span>,</span> <span>?</span><span>,</span> <span>M</span><span>></span></span> <span>toMap</span><span>(</span><span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>?</span> <span>extends</span> <span>K</span><span>></span></span> keyMapper<span>,</span>\n                            <span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>?</span> <span>extends</span> <span>U</span><span>></span></span> valueMapper<span>,</span>\n                            <span>BinaryOperator</span><span><span>&lt;</span><span>U</span><span>></span></span> mergeFunction<span>,</span>\n                            <span>Supplier</span><span><span>&lt;</span><span>M</span><span>></span></span> mapSupplier<span>)</span> <span>{</span>\n    <span>BiConsumer</span><span><span>&lt;</span><span>M</span><span>,</span> <span>T</span><span>></span></span> accumulator\n            <span>=</span> <span>(</span>map<span>,</span> element<span>)</span> <span>-></span> map<span>.</span><span>merge</span><span>(</span>keyMapper<span>.</span><span>apply</span><span>(</span>element<span>)</span><span>,</span>\n                                          valueMapper<span>.</span><span>apply</span><span>(</span>element<span>)</span><span>,</span> mergeFunction<span>)</span><span>;</span>\n    <span>return</span> <span>new</span> <span>CollectorImpl</span><span><span>&lt;</span><span>></span></span><span>(</span>mapSupplier<span>,</span> accumulator<span>,</span> <span>mapMerger</span><span>(</span>mergeFunction<span>)</span><span>,</span> CH_ID<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><code>Map</code> 接口的 <code>merge()</code> 方法如下，这个方法是接口中的默认实现。</p>\n<blockquote>\n<p>如果你还不了解 Java 8 新特性的话，请看这篇文章：<a href=\"https://mp.weixin.qq.com/s/ojyl7B6PiHaTWADqmUq2rw\" target=\"_blank\" rel=\"noopener noreferrer\">《Java8 新特性总结》</a> 。</p>\n</blockquote>\n<div><pre><code><span>default</span> <span>V</span> <span>merge</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>,</span>\n        <span>BiFunction</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>V</span><span>,</span> <span>?</span> <span>super</span> <span>V</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> remappingFunction<span>)</span> <span>{</span>\n    <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>remappingFunction<span>)</span><span>;</span>\n    <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>value<span>)</span><span>;</span>\n    <span>V</span> oldValue <span>=</span> <span>get</span><span>(</span>key<span>)</span><span>;</span>\n    <span>V</span> newValue <span>=</span> <span>(</span>oldValue <span>==</span> <span>null</span><span>)</span> <span>?</span> value <span>:</span>\n               remappingFunction<span>.</span><span>apply</span><span>(</span>oldValue<span>,</span> value<span>)</span><span>;</span>\n    <span>if</span><span>(</span>newValue <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        <span>remove</span><span>(</span>key<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>put</span><span>(</span>key<span>,</span> newValue<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> newValue<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><code>merge()</code> 方法会先调用 <code>Objects.requireNonNull()</code> 方法判断 value 是否为空。</p>\n<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>requireNonNull</span><span>(</span><span>T</span> obj<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>obj <span>==</span> <span>null</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> obj<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"集合遍历\"> 集合遍历</h2>\n<p>《阿里巴巴 Java 开发手册》的描述如下：</p>\n<blockquote>\n<p><strong>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</strong></p>\n</blockquote>\n<p>通过反编译你会发现 foreach 语法糖底层其实还是依赖 <code>Iterator</code> 。不过， <code>remove/add</code> 操作直接调用的是集合自己的方法，而不是 <code>Iterator</code> 的 <code>remove/add</code>方法</p>\n<p>这就导致 <code>Iterator</code> 莫名其妙地发现自己有元素被 <code>remove/add</code> ，然后，它就会抛出一个 <code>ConcurrentModificationException</code> 来提示用户发生了并发修改异常。这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p>\n<blockquote>\n<p><strong>fail-fast 机制</strong> ：多个线程对 fail-fast 集合进行修改的时候，可能会抛出<code>ConcurrentModificationException</code>。 即使是单线程下也有可能会出现这种情况，上面已经提到过。</p>\n</blockquote>\n<p>Java8 开始，可以使用 <code>Collection#removeIf()</code>方法删除满足特定条件的元素,如</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> <span>10</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>\n    list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>\n<span>}</span>\nlist<span>.</span><span>removeIf</span><span>(</span>filter <span>-></span> filter <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span><span>;</span> <span>/* 删除list中的所有偶数 */</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>list<span>)</span><span>;</span> <span>/* [1, 3, 5, 7, 9] */</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>除了上面介绍的直接使用 <code>Iterator</code> 进行遍历操作之外，你还可以：</p>\n<ul>\n<li>使用普通的 for 循环</li>\n<li>使用 fail-safe 的集合类。<code>java.util</code>包下面的所有的集合类都是 fail-fast 的，而<code>java.util.concurrent</code>包下面的所有的类都是 fail-safe 的。</li>\n<li>......</li>\n</ul>\n<h2 id=\"集合去重\"> 集合去重</h2>\n<p>《阿里巴巴 Java 开发手册》的描述如下：</p>\n<blockquote>\n<p><strong>可以利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains()</code> 进行遍历去重或者判断包含操作。</strong></p>\n</blockquote>\n<p>这里我们以 <code>HashSet</code> 和 <code>ArrayList</code> 为例说明。</p>\n<div><pre><code><span>// Set 去重代码示例</span>\n<span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>Set</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>removeDuplicateBySet</span><span>(</span><span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> data<span>)</span> <span>{</span>\n\n    <span>if</span> <span>(</span><span>CollectionUtils</span><span>.</span><span>isEmpty</span><span>(</span>data<span>)</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span>data<span>)</span><span>;</span>\n<span>}</span>\n\n<span>// List 去重代码示例</span>\n<span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>removeDuplicateByList</span><span>(</span><span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> data<span>)</span> <span>{</span>\n\n    <span>if</span> <span>(</span><span>CollectionUtils</span><span>.</span><span>isEmpty</span><span>(</span>data<span>)</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n    <span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> result <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>data<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>T</span> current <span>:</span> data<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>!</span>result<span>.</span><span>contains</span><span>(</span>current<span>)</span><span>)</span> <span>{</span>\n            result<span>.</span><span>add</span><span>(</span>current<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>两者的核心差别在于 <code>contains()</code> 方法的实现。</p>\n<p><code>HashSet</code> 的 <code>contains()</code> 方法底部依赖的 <code>HashMap</code> 的 <code>containsKey()</code> 方法，时间复杂度接近于 O（1）（没有出现哈希冲突的时候为 O（1））。</p>\n<div><pre><code><span>private</span> <span>transient</span> <span>HashMap</span><span><span>&lt;</span><span>E</span><span>,</span><span>Object</span><span>></span></span> map<span>;</span>\n<span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n    <span>return</span> map<span>.</span><span>containsKey</span><span>(</span>o<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>我们有 N 个元素插入进 Set 中，那时间复杂度就接近是 O (n)。</p>\n<p><code>ArrayList</code> 的 <code>contains()</code> 方法是通过遍历所有元素的方法来做的，时间复杂度接近是 O(n)。</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n    <span>return</span> <span>indexOf</span><span>(</span>o<span>)</span> <span>>=</span> <span>0</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>int</span> <span>indexOf</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>\n            <span>if</span> <span>(</span>elementData<span>[</span>i<span>]</span><span>==</span><span>null</span><span>)</span>\n                <span>return</span> i<span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>\n            <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>)</span>\n                <span>return</span> i<span>;</span>\n    <span>}</span>\n    <span>return</span> <span>-</span><span>1</span><span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>我们的 <code>List</code> 有 N 个元素，那时间复杂度就接近是 O (n^2)。</p>\n<h2 id=\"集合转数组\"> 集合转数组</h2>\n<p>《阿里巴巴 Java 开发手册》的描述如下：</p>\n<blockquote>\n<p><strong>使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。</strong></p>\n</blockquote>\n<p><code>toArray(T[] array)</code> 方法的参数是一个泛型数组，如果 <code>toArray</code> 方法中没有传递任何参数的话返回的是 <code>Object</code>类 型数组。</p>\n<div><pre><code><span>String</span> <span>[</span><span>]</span> s<span>=</span> <span>new</span> <span>String</span><span>[</span><span>]</span><span>{</span>\n    <span>\"dog\"</span><span>,</span> <span>\"lazy\"</span><span>,</span> <span>\"a\"</span><span>,</span> <span>\"over\"</span><span>,</span> <span>\"jumps\"</span><span>,</span> <span>\"fox\"</span><span>,</span> <span>\"brown\"</span><span>,</span> <span>\"quick\"</span><span>,</span> <span>\"A\"</span>\n<span>}</span><span>;</span>\n<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span>s<span>)</span><span>;</span>\n<span>Collections</span><span>.</span><span>reverse</span><span>(</span>list<span>)</span><span>;</span>\n<span>//没有指定类型的话会报错</span>\ns<span>=</span>list<span>.</span><span>toArray</span><span>(</span><span>new</span> <span>String</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>由于 JVM 优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。详见：<a href=\"https://shipilev.net/blog/2016/arrays-wisdom-ancients/\" target=\"_blank\" rel=\"noopener noreferrer\">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p>\n<h2 id=\"数组转集合\"> 数组转集合</h2>\n<p>《阿里巴巴 Java 开发手册》的描述如下：</p>\n<blockquote>\n<p><strong>使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</strong></p>\n</blockquote>\n<p>我在之前的一个项目中就遇到一个类似的坑。</p>\n<p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个 <code>List</code> 集合。</p>\n<div><pre><code><span>String</span><span>[</span><span>]</span> myArray <span>=</span> <span>{</span><span>\"Apple\"</span><span>,</span> <span>\"Banana\"</span><span>,</span> <span>\"Orange\"</span><span>}</span><span>;</span>\n<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> myList <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span>myArray<span>)</span><span>;</span>\n<span>//上面两个语句等价于下面一条语句</span>\n<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> myList <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>\"Apple\"</span><span>,</span><span>\"Banana\"</span><span>,</span> <span>\"Orange\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>JDK 源码对于这个方法的说明：</p>\n<div><pre><code><span>/**\n  *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，\n  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。\n  */</span>\n<span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>asList</span><span>(</span><span>T</span><span>.</span><span>.</span><span>.</span> a<span>)</span> <span>{</span>\n    <span>return</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>a<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>下面我们来总结一下使用注意事项。</p>\n<p><strong>1、<code>Arrays.asList()</code>是泛型方法，传递的数组必须是对象数组，而不是基本类型。</strong></p>\n<div><pre><code><span>int</span><span>[</span><span>]</span> myArray <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span><span>;</span>\n<span>List</span> myList <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span>myArray<span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myList<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//1</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myList<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span><span>//数组地址值</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myList<span>.</span><span>get</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span><span>//报错：ArrayIndexOutOfBoundsException</span>\n<span>int</span><span>[</span><span>]</span> array <span>=</span> <span>(</span><span>int</span><span>[</span><span>]</span><span>)</span> myList<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>array<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span><span>//1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 <code>List</code> 的唯一元素就是这个数组，这也就解释了上面的代码。</p>\n<p>我们使用包装类型数组就可以解决这个问题。</p>\n<div><pre><code><span>Integer</span><span>[</span><span>]</span> myArray <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>2、使用集合的修改方法: <code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</strong></p>\n<div><pre><code><span>List</span> myList <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>\nmyList<span>.</span><span>add</span><span>(</span><span>4</span><span>)</span><span>;</span><span>//运行时报错：UnsupportedOperationException</span>\nmyList<span>.</span><span>remove</span><span>(</span><span>1</span><span>)</span><span>;</span><span>//运行时报错：UnsupportedOperationException</span>\nmyList<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span><span>//运行时报错：UnsupportedOperationException</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p>\n<div><pre><code><span>List</span> myList <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myList<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//class java.util.Arrays$ArrayList</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>下图是 <code>java.util.Arrays$ArrayList</code> 的简易源码，我们可以看到这个类重写的方法有哪些。</p>\n<div><pre><code>  <span>private</span> <span>static</span> <span>class</span> <span>ArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>AbstractList</span><span><span>&lt;</span><span>E</span><span>></span></span>\n        <span>implements</span> <span>RandomAccess</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span>\n    <span>{</span>\n        <span>.</span><span>.</span><span>.</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n          <span>.</span><span>.</span><span>.</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>E</span> <span>set</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>\n          <span>.</span><span>.</span><span>.</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>int</span> <span>indexOf</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n          <span>.</span><span>.</span><span>.</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n           <span>.</span><span>.</span><span>.</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>forEach</span><span>(</span><span>Consumer</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>E</span><span>></span></span> action<span>)</span> <span>{</span>\n          <span>.</span><span>.</span><span>.</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>replaceAll</span><span>(</span><span>UnaryOperator</span><span><span>&lt;</span><span>E</span><span>></span></span> operator<span>)</span> <span>{</span>\n          <span>.</span><span>.</span><span>.</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>sort</span><span>(</span><span>Comparator</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>\n          <span>.</span><span>.</span><span>.</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>我们再看一下<code>java.util.AbstractList</code>的 <code>add/remove/clear</code> 方法就知道为什么会抛出 <code>UnsupportedOperationException</code> 了。</p>\n<div><pre><code><span>public</span> <span>E</span> <span>remove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n    <span>throw</span> <span>new</span> <span>UnsupportedOperationException</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>\n    <span>add</span><span>(</span><span>size</span><span>(</span><span>)</span><span>,</span> e<span>)</span><span>;</span>\n    <span>return</span> <span>true</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>\n    <span>throw</span> <span>new</span> <span>UnsupportedOperationException</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>void</span> <span>clear</span><span>(</span><span>)</span> <span>{</span>\n    <span>removeRange</span><span>(</span><span>0</span><span>,</span> <span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n<span>protected</span> <span>void</span> <span>removeRange</span><span>(</span><span>int</span> fromIndex<span>,</span> <span>int</span> toIndex<span>)</span> <span>{</span>\n    <span>ListIterator</span><span><span>&lt;</span><span>E</span><span>></span></span> it <span>=</span> <span>listIterator</span><span>(</span>fromIndex<span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>,</span> n<span>=</span>toIndex<span>-</span>fromIndex<span>;</span> i<span>&lt;</span>n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        it<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>\n        it<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p><strong>那我们如何正确的将数组转换为 <code>ArrayList</code> ?</strong></p>\n<p>1、手动实现工具类</p>\n<div><pre><code><span>//JDK1.5+</span>\n<span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>arrayToList</span><span>(</span><span>final</span> <span>T</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>\n  <span>final</span> <span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> l <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>T</span><span>></span></span><span>(</span>array<span>.</span>length<span>)</span><span>;</span>\n\n  <span>for</span> <span>(</span><span>final</span> <span>T</span> s <span>:</span> array<span>)</span> <span>{</span>\n    l<span>.</span><span>add</span><span>(</span>s<span>)</span><span>;</span>\n  <span>}</span>\n  <span>return</span> l<span>;</span>\n<span>}</span>\n\n\n<span>Integer</span> <span>[</span><span>]</span> myArray <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span> <span>}</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>arrayToList</span><span>(</span>myArray<span>)</span><span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//class java.util.ArrayList</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>2、最简便的方法</p>\n<div><pre><code><span>List</span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>\"a\"</span><span>,</span> <span>\"b\"</span><span>,</span> <span>\"c\"</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>3、使用 Java8 的 <code>Stream</code>(推荐)</p>\n<div><pre><code><span>Integer</span> <span>[</span><span>]</span> myArray <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span> <span>}</span><span>;</span>\n<span>List</span> myList <span>=</span> <span>Arrays</span><span>.</span><span>stream</span><span>(</span>myArray<span>)</span><span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>//基本类型也可以实现转换（依赖boxed的装箱操作）</span>\n<span>int</span> <span>[</span><span>]</span> myArray2 <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span> <span>}</span><span>;</span>\n<span>List</span> myList <span>=</span> <span>Arrays</span><span>.</span><span>stream</span><span>(</span>myArray2<span>)</span><span>.</span><span>boxed</span><span>(</span><span>)</span><span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>4、使用 Guava</p>\n<p>对于不可变集合，你可以使用<a href=\"https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java\" target=\"_blank\" rel=\"noopener noreferrer\"><code>ImmutableList</code></a>类及其<a href=\"https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101\" target=\"_blank\" rel=\"noopener noreferrer\"><code>of()</code></a>与<a href=\"https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225\" target=\"_blank\" rel=\"noopener noreferrer\"><code>copyOf()</code></a>工厂方法：（参数不能为空）</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> il <span>=</span> <span>ImmutableList</span><span>.</span><span>of</span><span>(</span><span>\"string\"</span><span>,</span> <span>\"elements\"</span><span>)</span><span>;</span>  <span>// from varargs</span>\n<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> il <span>=</span> <span>ImmutableList</span><span>.</span><span>copyOf</span><span>(</span>aStringArray<span>)</span><span>;</span>      <span>// from array</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>对于可变集合，你可以使用<a href=\"https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Lists</code></a>类及其<a href=\"https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87\" target=\"_blank\" rel=\"noopener noreferrer\"><code>newArrayList()</code></a>工厂方法：</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> l1 <span>=</span> <span>Lists</span><span>.</span><span>newArrayList</span><span>(</span>anotherListOrCollection<span>)</span><span>;</span>    <span>// from collection</span>\n<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> l2 <span>=</span> <span>Lists</span><span>.</span><span>newArrayList</span><span>(</span>aStringArray<span>)</span><span>;</span>               <span>// from array</span>\n<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> l3 <span>=</span> <span>Lists</span><span>.</span><span>newArrayList</span><span>(</span><span>\"or\"</span><span>,</span> <span>\"string\"</span><span>,</span> <span>\"elements\"</span><span>)</span><span>;</span> <span>// from varargs</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>5、使用 Apache Commons Collections</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n<span>CollectionUtils</span><span>.</span><span>addAll</span><span>(</span>list<span>,</span> str<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>6、 使用 Java9 的 <code>List.of()</code>方法</p>\n<div><pre><code><span>Integer</span><span>[</span><span>]</span> array <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span><span>;</span>\n<span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>List</span><span>.</span><span>of</span><span>(</span>array<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "JavaGuide（Java学习&&面试指南）",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/",
      "content_html": "",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": []
    },
    {
      "title": "HashMap源码+底层数据结构分析",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/collection/hashmap-source-code/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/collection/hashmap-source-code/",
      "content_html": "<blockquote>\n<p>感谢 <a href=\"https://github.com/changfubai\" target=\"_blank\" rel=\"noopener noreferrer\">changfubai</a> 对本文的改进做出的贡献！</p>\n</blockquote>\n<h2 id=\"hashmap-简介\"> HashMap 简介</h2>\n<p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p>\n<p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p>\n<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>\n<p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>\n<h2 id=\"底层数据结构分析\"> 底层数据结构分析</h2>\n<h3 id=\"jdk1-8-之前\"> JDK1.8 之前</h3>\n<p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。</p>\n<p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>\n<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>\n<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>\n<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>\n<div><pre><code>    <span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n      <span>int</span> h<span>;</span>\n      <span>// key.hashCode()：返回散列值也就是hashcode</span>\n      <span>// ^ ：按位异或</span>\n      <span>// >>>:无符号右移，忽略符号位，空位都以0补齐</span>\n      <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>\n<div><pre><code><span>static</span> <span>int</span> <span>hash</span><span>(</span><span>int</span> h<span>)</span> <span>{</span>\n    <span>// This function ensures that hashCodes that differ only by</span>\n    <span>// constant multiples at each bit position have a bounded</span>\n    <span>// number of collisions (approximately 8 at default load factor).</span>\n\n    h <span>^=</span> <span>(</span>h <span>>>></span> <span>20</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>12</span><span>)</span><span>;</span>\n    <span>return</span> h <span>^</span> <span>(</span>h <span>>>></span> <span>7</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>4</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>\n<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/jdk1.8之前的内部结构.png\" alt=\"jdk1.8之前的内部结构\" /></p>\n<h3 id=\"jdk1-8-之后\"> JDK1.8 之后</h3>\n<p>相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。</p>\n<p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。相关源码这里就不贴了，重点关注 <code>treeifyBin()</code>方法即可！</p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/up-bba283228693dae74e78da1ef7a9a04c684.png\" alt=\"\" /></p>\n<p><strong>类的属性：</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>HashMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>AbstractMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>implements</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>,</span> <span>Cloneable</span><span>,</span> <span>Serializable</span> <span>{</span>\n    <span>// 序列号</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>362498820763181265L</span><span>;</span>\n    <span>// 默认的初始容量是16</span>\n    <span>static</span> <span>final</span> <span>int</span> DEFAULT_INITIAL_CAPACITY <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>4</span><span>;</span>\n    <span>// 最大容量</span>\n    <span>static</span> <span>final</span> <span>int</span> MAXIMUM_CAPACITY <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>30</span><span>;</span>\n    <span>// 默认的填充因子</span>\n    <span>static</span> <span>final</span> <span>float</span> DEFAULT_LOAD_FACTOR <span>=</span> <span>0.75f</span><span>;</span>\n    <span>// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>\n    <span>static</span> <span>final</span> <span>int</span> TREEIFY_THRESHOLD <span>=</span> <span>8</span><span>;</span>\n    <span>// 当桶(bucket)上的结点数小于这个值时树转链表</span>\n    <span>static</span> <span>final</span> <span>int</span> UNTREEIFY_THRESHOLD <span>=</span> <span>6</span><span>;</span>\n    <span>// 桶中结构转化为红黑树对应的table的最小大小</span>\n    <span>static</span> <span>final</span> <span>int</span> MIN_TREEIFY_CAPACITY <span>=</span> <span>64</span><span>;</span>\n    <span>// 存储元素的数组，总是2的幂次倍</span>\n    <span>transient</span> <span>Node</span><span><span>&lt;</span>k<span>,</span>v<span>></span></span><span>[</span><span>]</span> table<span>;</span>\n    <span>// 存放具体元素的集</span>\n    <span>transient</span> <span>Set</span><span><span>&lt;</span>map<span>.</span>entry<span>&lt;</span>k<span>,</span>v<span>></span><span>></span></span> entrySet<span>;</span>\n    <span>// 存放元素的个数，注意这个不等于数组的长度。</span>\n    <span>transient</span> <span>int</span> size<span>;</span>\n    <span>// 每次扩容和更改map结构的计数器</span>\n    <span>transient</span> <span>int</span> modCount<span>;</span>\n    <span>// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>\n    <span>int</span> threshold<span>;</span>\n    <span>// 加载因子</span>\n    <span>final</span> <span>float</span> loadFactor<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><ul>\n<li>\n<p><strong>loadFactor 加载因子</strong></p>\n<p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>\n<p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p>\n<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>\n</li>\n<li>\n<p><strong>threshold</strong></p>\n<p><strong>threshold = capacity * loadFactor</strong>，<strong>当 Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>\n</li>\n</ul>\n<p><strong>Node 节点类源码:</strong></p>\n<div><pre><code><span>// 继承自 Map.Entry&lt;K,V></span>\n<span>static</span> <span>class</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>implements</span> <span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>{</span>\n       <span>final</span> <span>int</span> hash<span>;</span><span>// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>\n       <span>final</span> <span>K</span> key<span>;</span><span>//键</span>\n       <span>V</span> value<span>;</span><span>//值</span>\n       <span>// 指向下一个节点</span>\n       <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>;</span>\n       <span>Node</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>hash <span>=</span> hash<span>;</span>\n            <span>this</span><span>.</span>key <span>=</span> key<span>;</span>\n            <span>this</span><span>.</span>value <span>=</span> value<span>;</span>\n            <span>this</span><span>.</span>next <span>=</span> next<span>;</span>\n        <span>}</span>\n        <span>public</span> <span>final</span> <span>K</span> <span>getKey</span><span>(</span><span>)</span>        <span>{</span> <span>return</span> key<span>;</span> <span>}</span>\n        <span>public</span> <span>final</span> <span>V</span> <span>getValue</span><span>(</span><span>)</span>      <span>{</span> <span>return</span> value<span>;</span> <span>}</span>\n        <span>public</span> <span>final</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span> <span>return</span> key <span>+</span> <span>\"=\"</span> <span>+</span> value<span>;</span> <span>}</span>\n        <span>// 重写hashCode()方法</span>\n        <span>public</span> <span>final</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>Objects</span><span>.</span><span>hashCode</span><span>(</span>key<span>)</span> <span>^</span> <span>Objects</span><span>.</span><span>hashCode</span><span>(</span>value<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>public</span> <span>final</span> <span>V</span> <span>setValue</span><span>(</span><span>V</span> newValue<span>)</span> <span>{</span>\n            <span>V</span> oldValue <span>=</span> value<span>;</span>\n            value <span>=</span> newValue<span>;</span>\n            <span>return</span> oldValue<span>;</span>\n        <span>}</span>\n        <span>// 重写 equals() 方法</span>\n        <span>public</span> <span>final</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>o <span>==</span> <span>this</span><span>)</span>\n                <span>return</span> <span>true</span><span>;</span>\n            <span>if</span> <span>(</span>o <span>instanceof</span> <span>Map<span>.</span>Entry</span><span>)</span> <span>{</span>\n                <span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>?</span><span>,</span><span>?</span><span>></span></span> e <span>=</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>?</span><span>,</span><span>?</span><span>></span></span><span>)</span>o<span>;</span>\n                <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>equals</span><span>(</span>key<span>,</span> e<span>.</span><span>getKey</span><span>(</span><span>)</span><span>)</span> <span>&amp;&amp;</span>\n                    <span>Objects</span><span>.</span><span>equals</span><span>(</span>value<span>,</span> e<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>)</span>\n                    <span>return</span> <span>true</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p><strong>树节点类源码:</strong></p>\n<div><pre><code><span>static</span> <span>final</span> <span>class</span> <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>LinkedHashMap<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>{</span>\n        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> parent<span>;</span>  <span>// 父</span>\n        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> left<span>;</span>    <span>// 左</span>\n        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> right<span>;</span>   <span>// 右</span>\n        <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> prev<span>;</span>    <span>// needed to unlink next upon deletion</span>\n        <span>boolean</span> red<span>;</span>           <span>// 判断颜色</span>\n        <span>TreeNode</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> val<span>,</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>)</span> <span>{</span>\n            <span>super</span><span>(</span>hash<span>,</span> key<span>,</span> val<span>,</span> next<span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 返回根节点</span>\n        <span>final</span> <span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>root</span><span>(</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> r <span>=</span> <span>this</span><span>,</span> p<span>;</span><span>;</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span><span>(</span>p <span>=</span> r<span>.</span>parent<span>)</span> <span>==</span> <span>null</span><span>)</span>\n                    <span>return</span> r<span>;</span>\n                r <span>=</span> p<span>;</span>\n       <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"hashmap-源码分析\"> HashMap 源码分析</h2>\n<h3 id=\"构造方法\"> 构造方法</h3>\n<p>HashMap 中有四个构造方法，它们分别如下：</p>\n<div><pre><code>    <span>// 默认构造函数。</span>\n    <span>public</span> <span>HashMap</span><span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>loadFactor <span>=</span> DEFAULT_LOAD_FACTOR<span>;</span> <span>// all   other fields defaulted</span>\n     <span>}</span>\n\n     <span>// 包含另一个“Map”的构造函数</span>\n     <span>public</span> <span>HashMap</span><span>(</span><span>Map</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> m<span>)</span> <span>{</span>\n         <span>this</span><span>.</span>loadFactor <span>=</span> DEFAULT_LOAD_FACTOR<span>;</span>\n         <span>putMapEntries</span><span>(</span>m<span>,</span> <span>false</span><span>)</span><span>;</span><span>//下面会分析到这个方法</span>\n     <span>}</span>\n\n     <span>// 指定“容量大小”的构造函数</span>\n     <span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>\n         <span>this</span><span>(</span>initialCapacity<span>,</span> DEFAULT_LOAD_FACTOR<span>)</span><span>;</span>\n     <span>}</span>\n\n     <span>// 指定“容量大小”和“加载因子”的构造函数</span>\n     <span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>,</span> <span>float</span> loadFactor<span>)</span> <span>{</span>\n         <span>if</span> <span>(</span>initialCapacity <span>&lt;</span> <span>0</span><span>)</span>\n             <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal initial capacity: \"</span> <span>+</span> initialCapacity<span>)</span><span>;</span>\n         <span>if</span> <span>(</span>initialCapacity <span>></span> MAXIMUM_CAPACITY<span>)</span>\n             initialCapacity <span>=</span> MAXIMUM_CAPACITY<span>;</span>\n         <span>if</span> <span>(</span>loadFactor <span>&lt;=</span> <span>0</span> <span>||</span> <span>Float</span><span>.</span><span>isNaN</span><span>(</span>loadFactor<span>)</span><span>)</span>\n             <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal load factor: \"</span> <span>+</span> loadFactor<span>)</span><span>;</span>\n         <span>this</span><span>.</span>loadFactor <span>=</span> loadFactor<span>;</span>\n         <span>this</span><span>.</span>threshold <span>=</span> <span>tableSizeFor</span><span>(</span>initialCapacity<span>)</span><span>;</span>\n     <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><strong>putMapEntries 方法：</strong></p>\n<div><pre><code><span>final</span> <span>void</span> <span>putMapEntries</span><span>(</span><span>Map</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> m<span>,</span> <span>boolean</span> evict<span>)</span> <span>{</span>\n    <span>int</span> s <span>=</span> m<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>s <span>></span> <span>0</span><span>)</span> <span>{</span>\n        <span>// 判断table是否已经初始化</span>\n        <span>if</span> <span>(</span>table <span>==</span> <span>null</span><span>)</span> <span>{</span> <span>// pre-size</span>\n            <span>// 未初始化，s为m的实际元素个数</span>\n            <span>float</span> ft <span>=</span> <span>(</span><span>(</span><span>float</span><span>)</span>s <span>/</span> loadFactor<span>)</span> <span>+</span> <span>1.0F</span><span>;</span>\n            <span>int</span> t <span>=</span> <span>(</span><span>(</span>ft <span>&lt;</span> <span>(</span><span>float</span><span>)</span>MAXIMUM_CAPACITY<span>)</span> <span>?</span>\n                    <span>(</span><span>int</span><span>)</span>ft <span>:</span> MAXIMUM_CAPACITY<span>)</span><span>;</span>\n            <span>// 计算得到的t大于阈值，则初始化阈值</span>\n            <span>if</span> <span>(</span>t <span>></span> threshold<span>)</span>\n                threshold <span>=</span> <span>tableSizeFor</span><span>(</span>t<span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 已初始化，并且m元素个数大于阈值，进行扩容处理</span>\n        <span>else</span> <span>if</span> <span>(</span>s <span>></span> threshold<span>)</span>\n            <span>resize</span><span>(</span><span>)</span><span>;</span>\n        <span>// 将m中的所有元素添加至HashMap中</span>\n        <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> e <span>:</span> m<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>K</span> key <span>=</span> e<span>.</span><span>getKey</span><span>(</span><span>)</span><span>;</span>\n            <span>V</span> value <span>=</span> e<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>\n            <span>putVal</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> value<span>,</span> <span>false</span><span>,</span> evict<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id=\"put-方法\"> put 方法</h3>\n<p>HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p>\n<p><strong>对 putVal 方法添加元素的分析如下：</strong></p>\n<ol>\n<li>如果定位到的数组位置没有元素 就直接插入。</li>\n<li>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li>\n</ol>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/put方法.png\" alt=\" \" /></p>\n<p>说明:上图有两个小问题：</p>\n<ul>\n<li>直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行（<a href=\"https://github.com/Snailclimb/JavaGuide/issues/608\" target=\"_blank\" rel=\"noopener noreferrer\">issue#608</a>）。</li>\n<li>当链表长度大于阈值（默认为 8）并且 HashMap 数组长度超过 64 的时候才会执行链表转红黑树的操作，否则就只是对数组扩容。参考 HashMap 的 <code>treeifyBin()</code> 方法（<a href=\"https://github.com/Snailclimb/JavaGuide/issues/1087\" target=\"_blank\" rel=\"noopener noreferrer\">issue#1087</a>）。</li>\n</ul>\n<div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>\n    <span>return</span> <span>putVal</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> value<span>,</span> <span>false</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>,</span>\n                   <span>boolean</span> evict<span>)</span> <span>{</span>\n    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>;</span> <span>int</span> n<span>,</span> i<span>;</span>\n    <span>// table未初始化或者长度为0，进行扩容</span>\n    <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>==</span> <span>null</span> <span>||</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>==</span> <span>0</span><span>)</span>\n        n <span>=</span> <span>(</span>tab <span>=</span> <span>resize</span><span>(</span><span>)</span><span>)</span><span>.</span>length<span>;</span>\n    <span>// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>\n    <span>if</span> <span>(</span><span>(</span>p <span>=</span> tab<span>[</span>i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>]</span><span>)</span> <span>==</span> <span>null</span><span>)</span>\n        tab<span>[</span>i<span>]</span> <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>\n    <span>// 桶中已经存在元素</span>\n    <span>else</span> <span>{</span>\n        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span> <span>K</span> k<span>;</span>\n        <span>// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>\n        <span>if</span> <span>(</span>p<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>\n            <span>(</span><span>(</span>k <span>=</span> p<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>\n                <span>// 将第一个元素赋值给e，用e来记录</span>\n                e <span>=</span> p<span>;</span>\n        <span>// hash值不相等，即key不相等；为红黑树结点</span>\n        <span>else</span> <span>if</span> <span>(</span>p <span>instanceof</span> <span>TreeNode</span><span>)</span>\n            <span>// 放入树中</span>\n            e <span>=</span> <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>p<span>)</span><span>.</span><span>putTreeVal</span><span>(</span><span>this</span><span>,</span> tab<span>,</span> hash<span>,</span> key<span>,</span> value<span>)</span><span>;</span>\n        <span>// 为链表结点</span>\n        <span>else</span> <span>{</span>\n            <span>// 在链表最末插入结点</span>\n            <span>for</span> <span>(</span><span>int</span> binCount <span>=</span> <span>0</span><span>;</span> <span>;</span> <span>++</span>binCount<span>)</span> <span>{</span>\n                <span>// 到达链表的尾部</span>\n                <span>if</span> <span>(</span><span>(</span>e <span>=</span> p<span>.</span>next<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                    <span>// 在尾部插入新结点</span>\n                    p<span>.</span>next <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>\n                    <span>// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span>\n                    <span>// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span>\n                    <span>// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span>\n                    <span>if</span> <span>(</span>binCount <span>>=</span> TREEIFY_THRESHOLD <span>-</span> <span>1</span><span>)</span> <span>// -1 for 1st</span>\n                        <span>treeifyBin</span><span>(</span>tab<span>,</span> hash<span>)</span><span>;</span>\n                    <span>// 跳出循环</span>\n                    <span>break</span><span>;</span>\n                <span>}</span>\n                <span>// 判断链表中结点的key值与插入的元素的key值是否相等</span>\n                <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>\n                    <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>\n                    <span>// 相等，跳出循环</span>\n                    <span>break</span><span>;</span>\n                <span>// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>\n                p <span>=</span> e<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>// 表示在桶中找到key值、hash值与插入元素相等的结点</span>\n        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>// 记录e的value</span>\n            <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>\n            <span>// onlyIfAbsent为false或者旧值为null</span>\n            <span>if</span> <span>(</span><span>!</span>onlyIfAbsent <span>||</span> oldValue <span>==</span> <span>null</span><span>)</span>\n                <span>//用新值替换旧值</span>\n                e<span>.</span>value <span>=</span> value<span>;</span>\n            <span>// 访问后回调</span>\n            <span>afterNodeAccess</span><span>(</span>e<span>)</span><span>;</span>\n            <span>// 返回旧值</span>\n            <span>return</span> oldValue<span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>// 结构性修改</span>\n    <span>++</span>modCount<span>;</span>\n    <span>// 实际大小大于阈值则扩容</span>\n    <span>if</span> <span>(</span><span>++</span>size <span>></span> threshold<span>)</span>\n        <span>resize</span><span>(</span><span>)</span><span>;</span>\n    <span>// 插入后回调</span>\n    <span>afterNodeInsertion</span><span>(</span>evict<span>)</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br></div></div><p><strong>我们再来对比一下 JDK1.7 put 方法的代码</strong></p>\n<p><strong>对于 put 方法的分析如下：</strong></p>\n<ul>\n<li>① 如果定位到的数组位置没有元素 就直接插入。</li>\n<li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li>\n</ul>\n<div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span>\n    <span>if</span> <span>(</span>table <span>==</span> EMPTY_TABLE<span>)</span> <span>{</span>\n    <span>inflateTable</span><span>(</span>threshold<span>)</span><span>;</span>\n<span>}</span>\n    <span>if</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span>\n        <span>return</span> <span>putForNullKey</span><span>(</span>value<span>)</span><span>;</span>\n    <span>int</span> hash <span>=</span> <span>hash</span><span>(</span>key<span>)</span><span>;</span>\n    <span>int</span> i <span>=</span> <span>indexFor</span><span>(</span>hash<span>,</span> table<span>.</span>length<span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> table<span>[</span>i<span>]</span><span>;</span> e <span>!=</span> <span>null</span><span>;</span> e <span>=</span> e<span>.</span>next<span>)</span> <span>{</span> <span>// 先遍历</span>\n        <span>Object</span> k<span>;</span>\n        <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span> <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span> <span>{</span>\n            <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>\n            e<span>.</span>value <span>=</span> value<span>;</span>\n            e<span>.</span><span>recordAccess</span><span>(</span><span>this</span><span>)</span><span>;</span>\n            <span>return</span> oldValue<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    modCount<span>++</span><span>;</span>\n    <span>addEntry</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> i<span>)</span><span>;</span>  <span>// 再插入</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id=\"get-方法\"> get 方法</h3>\n<div><pre><code><span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span>\n    <span>return</span> <span>(</span>e <span>=</span> <span>getNode</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>)</span><span>)</span> <span>==</span> <span>null</span> <span>?</span> <span>null</span> <span>:</span> e<span>.</span>value<span>;</span>\n<span>}</span>\n\n<span>final</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>getNode</span><span>(</span><span>int</span> hash<span>,</span> <span>Object</span> key<span>)</span> <span>{</span>\n    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> first<span>,</span> e<span>;</span> <span>int</span> n<span>;</span> <span>K</span> k<span>;</span>\n    <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>></span> <span>0</span> <span>&amp;&amp;</span>\n        <span>(</span>first <span>=</span> tab<span>[</span><span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>// 数组元素相等</span>\n        <span>if</span> <span>(</span>first<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span> <span>// always check first node</span>\n            <span>(</span><span>(</span>k <span>=</span> first<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>\n            <span>return</span> first<span>;</span>\n        <span>// 桶中不止一个节点</span>\n        <span>if</span> <span>(</span><span>(</span>e <span>=</span> first<span>.</span>next<span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>// 在树中get</span>\n            <span>if</span> <span>(</span>first <span>instanceof</span> <span>TreeNode</span><span>)</span>\n                <span>return</span> <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>first<span>)</span><span>.</span><span>getTreeNode</span><span>(</span>hash<span>,</span> key<span>)</span><span>;</span>\n            <span>// 在链表中get</span>\n            <span>do</span> <span>{</span>\n                <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>\n                    <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>\n                    <span>return</span> e<span>;</span>\n            <span>}</span> <span>while</span> <span>(</span><span>(</span>e <span>=</span> e<span>.</span>next<span>)</span> <span>!=</span> <span>null</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id=\"resize-方法\"> resize 方法</h3>\n<p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p>\n<div><pre><code><span>final</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> <span>resize</span><span>(</span><span>)</span> <span>{</span>\n    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> oldTab <span>=</span> table<span>;</span>\n    <span>int</span> oldCap <span>=</span> <span>(</span>oldTab <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> oldTab<span>.</span>length<span>;</span>\n    <span>int</span> oldThr <span>=</span> threshold<span>;</span>\n    <span>int</span> newCap<span>,</span> newThr <span>=</span> <span>0</span><span>;</span>\n    <span>if</span> <span>(</span>oldCap <span>></span> <span>0</span><span>)</span> <span>{</span>\n        <span>// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>\n        <span>if</span> <span>(</span>oldCap <span>>=</span> MAXIMUM_CAPACITY<span>)</span> <span>{</span>\n            threshold <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>\n            <span>return</span> oldTab<span>;</span>\n        <span>}</span>\n        <span>// 没超过最大值，就扩充为原来的2倍</span>\n        <span>else</span> <span>if</span> <span>(</span><span>(</span>newCap <span>=</span> oldCap <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;&amp;</span> oldCap <span>>=</span> DEFAULT_INITIAL_CAPACITY<span>)</span>\n            newThr <span>=</span> oldThr <span>&lt;&lt;</span> <span>1</span><span>;</span> <span>// double threshold</span>\n    <span>}</span>\n    <span>else</span> <span>if</span> <span>(</span>oldThr <span>></span> <span>0</span><span>)</span> <span>// initial capacity was placed in threshold</span>\n        newCap <span>=</span> oldThr<span>;</span>\n    <span>else</span> <span>{</span>\n        <span>// signifies using defaults</span>\n        newCap <span>=</span> DEFAULT_INITIAL_CAPACITY<span>;</span>\n        newThr <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span>DEFAULT_LOAD_FACTOR <span>*</span> DEFAULT_INITIAL_CAPACITY<span>)</span><span>;</span>\n    <span>}</span>\n    <span>// 计算新的resize上限</span>\n    <span>if</span> <span>(</span>newThr <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        <span>float</span> ft <span>=</span> <span>(</span><span>float</span><span>)</span>newCap <span>*</span> loadFactor<span>;</span>\n        newThr <span>=</span> <span>(</span>newCap <span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;&amp;</span> ft <span>&lt;</span> <span>(</span><span>float</span><span>)</span>MAXIMUM_CAPACITY <span>?</span> <span>(</span><span>int</span><span>)</span>ft <span>:</span> <span>Integer</span><span>.</span>MAX_VALUE<span>)</span><span>;</span>\n    <span>}</span>\n    threshold <span>=</span> newThr<span>;</span>\n    <span>@SuppressWarnings</span><span>(</span><span>{</span><span>\"rawtypes\"</span><span>,</span><span>\"unchecked\"</span><span>}</span><span>)</span>\n        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> newTab <span>=</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>Node</span><span>[</span>newCap<span>]</span><span>;</span>\n    table <span>=</span> newTab<span>;</span>\n    <span>if</span> <span>(</span>oldTab <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>// 把每个bucket都移动到新的buckets中</span>\n        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> oldCap<span>;</span> <span>++</span>j<span>)</span> <span>{</span>\n            <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span>\n            <span>if</span> <span>(</span><span>(</span>e <span>=</span> oldTab<span>[</span>j<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                oldTab<span>[</span>j<span>]</span> <span>=</span> <span>null</span><span>;</span>\n                <span>if</span> <span>(</span>e<span>.</span>next <span>==</span> <span>null</span><span>)</span>\n                    newTab<span>[</span>e<span>.</span>hash <span>&amp;</span> <span>(</span>newCap <span>-</span> <span>1</span><span>)</span><span>]</span> <span>=</span> e<span>;</span>\n                <span>else</span> <span>if</span> <span>(</span>e <span>instanceof</span> <span>TreeNode</span><span>)</span>\n                    <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>e<span>)</span><span>.</span><span>split</span><span>(</span><span>this</span><span>,</span> newTab<span>,</span> j<span>,</span> oldCap<span>)</span><span>;</span>\n                <span>else</span> <span>{</span>\n                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> loHead <span>=</span> <span>null</span><span>,</span> loTail <span>=</span> <span>null</span><span>;</span>\n                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> hiHead <span>=</span> <span>null</span><span>,</span> hiTail <span>=</span> <span>null</span><span>;</span>\n                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>;</span>\n                    <span>do</span> <span>{</span>\n                        next <span>=</span> e<span>.</span>next<span>;</span>\n                        <span>// 原索引</span>\n                        <span>if</span> <span>(</span><span>(</span>e<span>.</span>hash <span>&amp;</span> oldCap<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                            <span>if</span> <span>(</span>loTail <span>==</span> <span>null</span><span>)</span>\n                                loHead <span>=</span> e<span>;</span>\n                            <span>else</span>\n                                loTail<span>.</span>next <span>=</span> e<span>;</span>\n                            loTail <span>=</span> e<span>;</span>\n                        <span>}</span>\n                        <span>// 原索引+oldCap</span>\n                        <span>else</span> <span>{</span>\n                            <span>if</span> <span>(</span>hiTail <span>==</span> <span>null</span><span>)</span>\n                                hiHead <span>=</span> e<span>;</span>\n                            <span>else</span>\n                                hiTail<span>.</span>next <span>=</span> e<span>;</span>\n                            hiTail <span>=</span> e<span>;</span>\n                        <span>}</span>\n                    <span>}</span> <span>while</span> <span>(</span><span>(</span>e <span>=</span> next<span>)</span> <span>!=</span> <span>null</span><span>)</span><span>;</span>\n                    <span>// 原索引放到bucket里</span>\n                    <span>if</span> <span>(</span>loTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                        loTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>\n                        newTab<span>[</span>j<span>]</span> <span>=</span> loHead<span>;</span>\n                    <span>}</span>\n                    <span>// 原索引+oldCap放到bucket里</span>\n                    <span>if</span> <span>(</span>hiTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                        hiTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>\n                        newTab<span>[</span>j <span>+</span> oldCap<span>]</span> <span>=</span> hiHead<span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> newTab<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br></div></div><h2 id=\"hashmap-常用方法测试\"> HashMap 常用方法测试</h2>\n<div><pre><code><span>package</span> <span>map</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Collection</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>HashMap</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Set</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>HashMapDemo</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>// 键不能重复，值可以重复</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"san\"</span><span>,</span> <span>\"张三\"</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"si\"</span><span>,</span> <span>\"李四\"</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"wu\"</span><span>,</span> <span>\"王五\"</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"wang\"</span><span>,</span> <span>\"老王\"</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"wang\"</span><span>,</span> <span>\"老王2\"</span><span>)</span><span>;</span><span>// 老王被覆盖</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"lao\"</span><span>,</span> <span>\"老王\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"-------直接输出hashmap:-------\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>)</span><span>;</span>\n        <span>/**\n         * 遍历HashMap\n         */</span>\n        <span>// 1.获取Map中的所有键</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"-------foreach获取Map中所有的键:------\"</span><span>)</span><span>;</span>\n        <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> keys <span>=</span> map<span>.</span><span>keySet</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>String</span> key <span>:</span> keys<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>key<span>+</span><span>\"  \"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span><span>//换行</span>\n        <span>// 2.获取Map中所有值</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"-------foreach获取Map中所有的值:------\"</span><span>)</span><span>;</span>\n        <span>Collection</span><span><span>&lt;</span><span>String</span><span>></span></span> values <span>=</span> map<span>.</span><span>values</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>String</span> value <span>:</span> values<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>value<span>+</span><span>\"  \"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span><span>//换行</span>\n        <span>// 3.得到key的值的同时得到key所对应的值</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"-------得到key的值的同时得到key所对应的值:-------\"</span><span>)</span><span>;</span>\n        <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> keys2 <span>=</span> map<span>.</span><span>keySet</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>String</span> key <span>:</span> keys2<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>key <span>+</span> <span>\"：\"</span> <span>+</span> map<span>.</span><span>get</span><span>(</span>key<span>)</span><span>+</span><span>\"   \"</span><span>)</span><span>;</span>\n\n        <span>}</span>\n        <span>/**\n         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。\n         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。\n         */</span>\n        <span>// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span>\n        <span>// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span>\n        <span>// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span>\n        <span>// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span>\n        <span>Set</span><span><span>&lt;</span><span><span>java<span>.</span>util<span>.</span></span>Map<span>.</span>Entry</span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span><span>></span></span> entrys <span>=</span> map<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span><span>java<span>.</span>util<span>.</span></span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> entry <span>:</span> entrys<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span> <span>+</span> <span>\"--\"</span> <span>+</span> entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>/**\n         * HashMap其他常用方法\n         */</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after map.size()：\"</span><span>+</span>map<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after map.isEmpty()：\"</span><span>+</span>map<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>.</span><span>remove</span><span>(</span><span>\"san\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after map.remove()：\"</span><span>+</span>map<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after map.get(si)：\"</span><span>+</span>map<span>.</span><span>get</span><span>(</span><span>\"si\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after map.containsKey(si)：\"</span><span>+</span>map<span>.</span><span>containsKey</span><span>(</span><span>\"si\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after containsValue(李四)：\"</span><span>+</span>map<span>.</span><span>containsValue</span><span>(</span><span>\"李四\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>.</span><span>replace</span><span>(</span><span>\"si\"</span><span>,</span> <span>\"李四2\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after map.replace(si, 李四2):\"</span><span>+</span>map<span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div>",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/jdk1.8之前的内部结构.png",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java集合框架基础知识&面试题总结",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/collection/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/javaguide/java/collection/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/",
      "content_html": "<h1 id=\"_1-剖析面试最常见问题之-java-集合框架\"> 1. 剖析面试最常见问题之 Java 集合框架</h1>\n<h2 id=\"_1-1-集合概述\"> 1.1. 集合概述</h2>\n<h3 id=\"_1-1-1-java-集合概览\"> 1.1.1. Java 集合概览</h3>\n<p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collecton</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p>\n<p>Java 集合框架如下图所示：</p>\n<p><img src=\"./images/java-collection-hierarchy.png\" alt=\"\" /></p>\n<p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了<code>AbstractList</code>, <code>NavigableSet</code>等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。</p>\n<h3 id=\"_1-1-2-说说-list-set-queue-map-四者的区别\"> 1.1.2. 说说 List, Set, Queue, Map 四者的区别？</h3>\n<ul>\n<li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>\n<li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>\n<li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>\n<li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，&quot;x&quot; 代表 key，&quot;y&quot; 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>\n</ul>\n<h3 id=\"_1-1-3-集合框架底层数据结构总结\"> 1.1.3. 集合框架底层数据结构总结</h3>\n<p>先来看一下 <code>Collection</code> 接口下面的集合。</p>\n<h4 id=\"_1-1-3-1-list\"> 1.1.3.1. List</h4>\n<ul>\n<li><code>Arraylist</code>： <code>Object[]</code> 数组</li>\n<li><code>Vector</code>：<code>Object[]</code> 数组</li>\n<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>\n</ul>\n<h4 id=\"_1-1-3-2-set\"> 1.1.3.2. Set</h4>\n<ul>\n<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>\n<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>\n<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li>\n</ul>\n<h4 id=\"_1-1-3-3-queue\"> 1.1.3.3 Queue</h4>\n<ul>\n<li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li>\n<li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li>\n</ul>\n<p>再来看看 <code>Map</code> 接口下面的集合。</p>\n<h4 id=\"_1-1-3-4-map\"> 1.1.3.4. Map</h4>\n<ul>\n<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>\n<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href=\"https://www.imooc.com/article/22931\" target=\"_blank\" rel=\"noopener noreferrer\">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li>\n<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>\n<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>\n</ul>\n<h3 id=\"_1-1-4-如何选用集合\"> 1.1.4. 如何选用集合?</h3>\n<p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p>\n<p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p>\n<h3 id=\"_1-1-5-为什么要使用集合\"> 1.1.5. 为什么要使用集合？</h3>\n<p>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端，\n因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</p>\n<p>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。\n但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</p>\n<h2 id=\"_1-2-collection-子接口之-list\"> 1.2. Collection 子接口之 List</h2>\n<h3 id=\"_1-2-1-arraylist-和-vector-的区别\"> 1.2.1. Arraylist 和 Vector 的区别?</h3>\n<ul>\n<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li>\n<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，线程安全的。</li>\n</ul>\n<h3 id=\"_1-2-2-arraylist-与-linkedlist-区别\"> 1.2.2. Arraylist 与 LinkedList 区别?</h3>\n<ol>\n<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>\n<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>\n<li><strong>插入和删除是否受元素位置的影响：</strong>\n<ul>\n<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>\n<li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），近似 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</li>\n</ul>\n</li>\n<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>\n<li><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>\n</ol>\n<h4 id=\"_1-2-2-1-补充内容-双向链表和双向循环链表\"> 1.2.2.1. 补充内容:双向链表和双向循环链表</h4>\n<p><strong>双向链表：</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p>\n<blockquote>\n<p>另外推荐一篇把双向链表讲清楚的文章：<a href=\"https://juejin.cn/post/6844903648154271757\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903648154271757</a></p>\n</blockquote>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向链表.png\" alt=\"双向链表\" /></p>\n<p><strong>双向循环链表：</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向循环链表.png\" alt=\"双向循环链表\" /></p>\n<h4 id=\"_1-2-2-2-补充内容-randomaccess-接口\"> 1.2.2.2. 补充内容:RandomAccess 接口</h4>\n<div><pre><code><span>public</span> <span>interface</span> <span>RandomAccess</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p>\n<p>在 <code>binarySearch（)</code> 方法中，它要判断传入的 list 是否 <code>RamdomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span>\n    <span>int</span> <span>binarySearch</span><span>(</span><span>List</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span><span>></span></span> list<span>,</span> <span>T</span> key<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>list <span>instanceof</span> <span>RandomAccess</span> <span>||</span> list<span>.</span><span>size</span><span>(</span><span>)</span><span>&lt;</span>BINARYSEARCH_THRESHOLD<span>)</span>\n            <span>return</span> <span>Collections</span><span>.</span><span>indexedBinarySearch</span><span>(</span>list<span>,</span> key<span>)</span><span>;</span>\n        <span>else</span>\n            <span>return</span> <span>Collections</span><span>.</span><span>iteratorBinarySearch</span><span>(</span>list<span>,</span> key<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p>\n<h3 id=\"_1-2-3-说一说-arraylist-的扩容机制吧\"> 1.2.3. 说一说 ArrayList 的扩容机制吧</h3>\n<p>详见笔主的这篇文章:<a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90\" target=\"_blank\" rel=\"noopener noreferrer\">通过源码一步一步分析 ArrayList 扩容机制</a></p>\n<h2 id=\"_1-3-collection-子接口之-set\"> 1.3. Collection 子接口之 Set</h2>\n<h3 id=\"_1-3-1-comparable-和-comparator-的区别\"> 1.3.1. comparable 和 Comparator 的区别</h3>\n<ul>\n<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>\n<li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>\n</ul>\n<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p>\n<h4 id=\"_1-3-1-1-comparator-定制排序\"> 1.3.1.1. Comparator 定制排序</h4>\n<div><pre><code>        <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> arrayList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>5</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>7</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>4</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>9</span><span>)</span><span>;</span>\n        arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>7</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"原始数组:\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n        <span>// void reverse(List list)：反转</span>\n        <span>Collections</span><span>.</span><span>reverse</span><span>(</span>arrayList<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Collections.reverse(arrayList):\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n\n        <span>// void sort(List list),按自然排序的升序排序</span>\n        <span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Collections.sort(arrayList):\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n        <span>// 定制排序的用法</span>\n        <span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>,</span> <span>new</span> <span>Comparator</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n\n            <span>@Override</span>\n            <span>public</span> <span>int</span> <span>compare</span><span>(</span><span>Integer</span> o1<span>,</span> <span>Integer</span> o2<span>)</span> <span>{</span>\n                <span>return</span> o2<span>.</span><span>compareTo</span><span>(</span>o1<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"定制排序后：\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>Output:</p>\n<div><pre><code>原始数组:\n[-1, 3, 3, -5, 7, 4, -9, -7]\nCollections.reverse(arrayList):\n[-7, -9, 4, 7, -5, 3, 3, -1]\nCollections.sort(arrayList):\n[-9, -7, -5, -1, 3, 3, 4, 7]\n定制排序后：\n[7, 4, 3, 3, -1, -5, -7, -9]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id=\"_1-3-1-2-重写-compareto-方法实现按年龄来排序\"> 1.3.1.2. 重写 compareTo 方法实现按年龄来排序</h4>\n<div><pre><code><span>// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span>\n<span>// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span>\n<span>// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span>\n<span>public</span>  <span>class</span> <span>Person</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Person</span><span>></span></span> <span>{</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n    <span>private</span> <span>int</span> age<span>;</span>\n\n    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>\n        <span>super</span><span>(</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> age<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * T重写compareTo方法实现按年龄来排序\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>Person</span> o<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>this</span><span>.</span>age <span>></span> o<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>1</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span><span>this</span><span>.</span>age <span>&lt;</span> o<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>0</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span> pdata <span>=</span> <span>new</span> <span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>\"张三\"</span><span>,</span> <span>30</span><span>)</span><span>,</span> <span>\"zhangsan\"</span><span>)</span><span>;</span>\n        pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>\"李四\"</span><span>,</span> <span>20</span><span>)</span><span>,</span> <span>\"lisi\"</span><span>)</span><span>;</span>\n        pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>\"王五\"</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>\"wangwu\"</span><span>)</span><span>;</span>\n        pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>\"小红\"</span><span>,</span> <span>5</span><span>)</span><span>,</span> <span>\"xiaohong\"</span><span>)</span><span>;</span>\n        <span>// 得到key的值的同时得到key所对应的值</span>\n        <span>Set</span><span><span>&lt;</span><span>Person</span><span>></span></span> keys <span>=</span> pdata<span>.</span><span>keySet</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>Person</span> key <span>:</span> keys<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>key<span>.</span><span>getAge</span><span>(</span><span>)</span> <span>+</span> <span>\"-\"</span> <span>+</span> key<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>Output：</p>\n<div><pre><code>5-小红\n10-王五\n20-李四\n30-张三\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_1-3-2-无序性和不可重复性的含义是什么\"> 1.3.2. 无序性和不可重复性的含义是什么</h3>\n<p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>\n<p>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p>\n<h3 id=\"_1-3-3-比较-hashset、linkedhashset-和-treeset-三者的异同\"> 1.3.3. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3>\n<p><code>HashSet</code> 是 <code>Set</code> 接口的主要实现类 ，<code>HashSet</code> 的底层是 <code>HashMap</code>，线程不安全的，可以存储 null 值；</p>\n<p><code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，能够按照添加的顺序遍历；</p>\n<p><code>TreeSet</code> 底层使用红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p>\n<h2 id=\"_1-4-collection-子接口之-queue\"> 1.4 Collection 子接口之 Queue</h2>\n<h3 id=\"_1-4-1-queue-与-deque-的区别\"> 1.4.1 Queue 与 Deque 的区别</h3>\n<p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>\n<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>\n<table>\n<thead>\n<tr>\n<th><code>Queue</code> 接口</th>\n<th>抛出异常</th>\n<th>返回特殊值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>插入队尾</td>\n<td>add(E e)</td>\n<td>offer(E e)</td>\n</tr>\n<tr>\n<td>删除队首</td>\n<td>remove()</td>\n<td>poll()</td>\n</tr>\n<tr>\n<td>查询队首元素</td>\n<td>element()</td>\n<td>peek()</td>\n</tr>\n</tbody>\n</table>\n<p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>\n<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>\n<table>\n<thead>\n<tr>\n<th><code>Deque</code> 接口</th>\n<th>抛出异常</th>\n<th>返回特殊值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>插入队首</td>\n<td>addFirst(E e)</td>\n<td>offerFirst(E e)</td>\n</tr>\n<tr>\n<td>插入队尾</td>\n<td>addLast(E e)</td>\n<td>offerLast(E e)</td>\n</tr>\n<tr>\n<td>删除队首</td>\n<td>removeFirst()</td>\n<td>pollFirst()</td>\n</tr>\n<tr>\n<td>删除队尾</td>\n<td>removeLast()</td>\n<td>pollLast()</td>\n</tr>\n<tr>\n<td>查询队首元素</td>\n<td>getFirst()</td>\n<td>peekFirst()</td>\n</tr>\n<tr>\n<td>查询队尾元素</td>\n<td>getLast()</td>\n<td>peekLast()</td>\n</tr>\n</tbody>\n</table>\n<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p>\n<h3 id=\"_1-4-2-arraydeque-与-linkedlist-的区别\"> 1.4.2 ArrayDeque 与 LinkedList 的区别</h3>\n<p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>\n<ul>\n<li>\n<p><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</p>\n</li>\n<li>\n<p><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</p>\n</li>\n<li>\n<p><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</p>\n</li>\n<li>\n<p><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p>\n</li>\n</ul>\n<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>\n<h3 id=\"_1-4-3-说一说-priorityqueue\"> 1.4.3 说一说 PriorityQueue</h3>\n<p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>\n<p>这里列举其相关的一些要点：</p>\n<ul>\n<li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>\n<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>\n<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>\n<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>\n</ul>\n<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。</p>\n<h2 id=\"_1-5-map-接口\"> 1.5. Map 接口</h2>\n<h3 id=\"_1-5-1-hashmap-和-hashtable-的区别\"> 1.5.1. HashMap 和 Hashtable 的区别</h3>\n<ol>\n<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li>\n<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li>\n<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li>\n<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>\n<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>\n</ol>\n<p><strong><code>HashMap</code> 中带有初始容量的构造函数：</strong></p>\n<div><pre><code>    <span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>,</span> <span>float</span> loadFactor<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>initialCapacity <span>&lt;</span> <span>0</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal initial capacity: \"</span> <span>+</span>\n                                               initialCapacity<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>initialCapacity <span>></span> MAXIMUM_CAPACITY<span>)</span>\n            initialCapacity <span>=</span> MAXIMUM_CAPACITY<span>;</span>\n        <span>if</span> <span>(</span>loadFactor <span>&lt;=</span> <span>0</span> <span>||</span> <span>Float</span><span>.</span><span>isNaN</span><span>(</span>loadFactor<span>)</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal load factor: \"</span> <span>+</span>\n                                               loadFactor<span>)</span><span>;</span>\n        <span>this</span><span>.</span>loadFactor <span>=</span> loadFactor<span>;</span>\n        <span>this</span><span>.</span>threshold <span>=</span> <span>tableSizeFor</span><span>(</span>initialCapacity<span>)</span><span>;</span>\n    <span>}</span>\n     <span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>\n        <span>this</span><span>(</span>initialCapacity<span>,</span> DEFAULT_LOAD_FACTOR<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>下面这个方法保证了 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>\n<div><pre><code>    <span>/**\n     * Returns a power of two size for the given target capacity.\n     */</span>\n    <span>static</span> <span>final</span> <span>int</span> <span>tableSizeFor</span><span>(</span><span>int</span> cap<span>)</span> <span>{</span>\n        <span>int</span> n <span>=</span> cap <span>-</span> <span>1</span><span>;</span>\n        n <span>|=</span> n <span>>>></span> <span>1</span><span>;</span>\n        n <span>|=</span> n <span>>>></span> <span>2</span><span>;</span>\n        n <span>|=</span> n <span>>>></span> <span>4</span><span>;</span>\n        n <span>|=</span> n <span>>>></span> <span>8</span><span>;</span>\n        n <span>|=</span> n <span>>>></span> <span>16</span><span>;</span>\n        <span>return</span> <span>(</span>n <span>&lt;</span> <span>0</span><span>)</span> <span>?</span> <span>1</span> <span>:</span> <span>(</span>n <span>>=</span> MAXIMUM_CAPACITY<span>)</span> <span>?</span> MAXIMUM_CAPACITY <span>:</span> n <span>+</span> <span>1</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_1-5-2-hashmap-和-hashset-区别\"> 1.5.2. HashMap 和 HashSet 区别</h3>\n<p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>HashMap</code></th>\n<th style=\"text-align:center\"><code>HashSet</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">实现了 <code>Map</code> 接口</td>\n<td style=\"text-align:center\">实现 <code>Set</code> 接口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">存储键值对</td>\n<td style=\"text-align:center\">仅存储对象</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">调用 <code>put()</code>向 map 中添加元素</td>\n<td style=\"text-align:center\">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>\n<td style=\"text-align:center\"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_1-5-3-hashmap-和-treemap-区别\"> 1.5.3. HashMap 和 TreeMap 区别</h3>\n<p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>\n<p><img src=\"./images/TreeMap继承结构.png\" alt=\"\" /></p>\n<p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>\n<p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p>\n<div><pre><code><span>/**\n * @author shuang.kou\n * @createTime 2020年06月15日 17:02:00\n */</span>\n<span>public</span> <span>class</span> <span>Person</span> <span>{</span>\n    <span>private</span> <span>Integer</span> age<span>;</span>\n\n    <span>public</span> <span>Person</span><span>(</span><span>Integer</span> age<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>Integer</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> age<span>;</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span> treeMap <span>=</span> <span>new</span> <span>TreeMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>new</span> <span>Comparator</span><span><span>&lt;</span><span>Person</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>int</span> <span>compare</span><span>(</span><span>Person</span> person1<span>,</span> <span>Person</span> person2<span>)</span> <span>{</span>\n                <span>int</span> num <span>=</span> person1<span>.</span><span>getAge</span><span>(</span><span>)</span> <span>-</span> person2<span>.</span><span>getAge</span><span>(</span><span>)</span><span>;</span>\n                <span>return</span> <span>Integer</span><span>.</span><span>compare</span><span>(</span>num<span>,</span> <span>0</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        treeMap<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>3</span><span>)</span><span>,</span> <span>\"person1\"</span><span>)</span><span>;</span>\n        treeMap<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>18</span><span>)</span><span>,</span> <span>\"person2\"</span><span>)</span><span>;</span>\n        treeMap<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>35</span><span>)</span><span>,</span> <span>\"person3\"</span><span>)</span><span>;</span>\n        treeMap<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>16</span><span>)</span><span>,</span> <span>\"person4\"</span><span>)</span><span>;</span>\n        treeMap<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span>personStringEntry <span>-></span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>personStringEntry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>输出:</p>\n<div><pre><code>person1\nperson4\nperson2\nperson3\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>可以看出，<code>TreeMap</code> 中的元素已经是按照 <code>Person</code> 的 age 字段的升序来排列了。</p>\n<p>上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：</p>\n<div><pre><code><span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span> treeMap <span>=</span> <span>new</span> <span>TreeMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>(</span>person1<span>,</span> person2<span>)</span> <span>-></span> <span>{</span>\n  <span>int</span> num <span>=</span> person1<span>.</span><span>getAge</span><span>(</span><span>)</span> <span>-</span> person2<span>.</span><span>getAge</span><span>(</span><span>)</span><span>;</span>\n  <span>return</span> <span>Integer</span><span>.</span><span>compare</span><span>(</span>num<span>,</span> <span>0</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>综上，相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>\n<h3 id=\"_1-5-4-hashset-如何检查重复\"> 1.5.4. HashSet 如何检查重复</h3>\n<p>以下内容摘自我的 Java 启蒙书《Head first java》第二版：</p>\n<p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>\n<p>在openjdk8中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。直接看一下<code>HashSet</code>中的源码：</p>\n<div><pre><code><span>// Returns: true if this set did not already contain the specified element</span>\n<span>// 返回值：当set中没有包含add的元素时返回真</span>\n<span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>\n        <span>return</span> map<span>.</span><span>put</span><span>(</span>e<span>,</span> PRESENT<span>)</span><span>==</span><span>null</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>而在<code>HashMap</code>的<code>putVal()</code>方法中也能看到如下说明：</p>\n<div><pre><code><span>// Returns : previous value, or null if none</span>\n<span>// 返回值：如果插入位置没有元素返回null，否则返回上一个元素</span>\n<span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>,</span>\n                   <span>boolean</span> evict<span>)</span> <span>{</span>\n<span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>也就是说，在openjdk8中，实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</p>\n<p><strong><code>hashCode()</code>与 <code>equals()</code> 的相关规定：</strong></p>\n<ol>\n<li>如果两个对象相等，则 <code>hashcode</code> 一定也是相同的</li>\n<li>两个对象相等,对两个 <code>equals()</code> 方法返回 true</li>\n<li>两个对象有相同的 <code>hashcode</code> 值，它们也不一定是相等的</li>\n<li>综上，<code>equals()</code> 方法被覆盖过，则 <code>hashCode()</code> 方法也必须被覆盖</li>\n<li><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>\n</ol>\n<p><strong>==与 equals 的区别</strong></p>\n<p>对于基本类型来说，== 比较的是值是否相等；</p>\n<p>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；</p>\n<p>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p>\n<h3 id=\"_1-5-5-hashmap-的底层实现\"> 1.5.5. HashMap 的底层实现</h3>\n<h4 id=\"_1-5-5-1-jdk1-8-之前\"> 1.5.5.1. JDK1.8 之前</h4>\n<p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>\n<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>\n<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>\n<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>\n<div><pre><code>    <span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n      <span>int</span> h<span>;</span>\n      <span>// key.hashCode()：返回散列值也就是hashcode</span>\n      <span>// ^ ：按位异或</span>\n      <span>// >>>:无符号右移，忽略符号位，空位都以0补齐</span>\n      <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>\n<div><pre><code><span>static</span> <span>int</span> <span>hash</span><span>(</span><span>int</span> h<span>)</span> <span>{</span>\n    <span>// This function ensures that hashCodes that differ only by</span>\n    <span>// constant multiples at each bit position have a bounded</span>\n    <span>// number of collisions (approximately 8 at default load factor).</span>\n\n    h <span>^=</span> <span>(</span>h <span>>>></span> <span>20</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>12</span><span>)</span><span>;</span>\n    <span>return</span> h <span>^</span> <span>(</span>h <span>>>></span> <span>7</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>4</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>\n<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\n<p><img src=\"./images/jdk1.8之前的内部结构-HashMap.png\" alt=\"jdk1.8之前的内部结构-HashMap\" /></p>\n<h4 id=\"_1-5-5-2-jdk1-8-之后\"> 1.5.5.2. JDK1.8 之后</h4>\n<p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>\n<p><img src=\"./images/jdk1.8之后的内部结构-HashMap.png\" alt=\"jdk1.8之后的内部结构-HashMap\" /></p>\n<blockquote>\n<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>\n</blockquote>\n<h3 id=\"_1-5-6-hashmap-的长度为什么是-2-的幂次方\"> 1.5.6. HashMap 的长度为什么是 2 的幂次方</h3>\n<p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p>\n<p><strong>这个算法应该如何设计呢？</strong></p>\n<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p>\n<h3 id=\"_1-5-7-hashmap-多线程操作导致死循环问题\"> 1.5.7. HashMap 多线程操作导致死循环问题</h3>\n<p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>\n<p>详情请查看：<a href=\"https://coolshell.cn/articles/9606.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://coolshell.cn/articles/9606.html</a></p>\n<h3 id=\"_1-5-8-hashmap-有哪几种常见的遍历方式\"> 1.5.8. HashMap 有哪几种常见的遍历方式?</h3>\n<p><a href=\"https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw\" target=\"_blank\" rel=\"noopener noreferrer\">HashMap 的 7 种遍历方式与性能分析！</a></p>\n<h3 id=\"_1-5-9-concurrenthashmap-和-hashtable-的区别\"> 1.5.9. ConcurrentHashMap 和 Hashtable 的区别</h3>\n<p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>\n<ul>\n<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>\n<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>\n</ul>\n<p><strong>两者的对比图：</strong></p>\n<p><strong>Hashtable:</strong></p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HashTable全表锁.png\" alt=\"Hashtable全表锁\" /></p>\n<p style=\"text-align:right;font-size:13px;color:gray\">https://www.cnblogs.com/chengxiao/p/6842045.html></p>\n<p><strong>JDK1.7 的 ConcurrentHashMap：</strong></p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ConcurrentHashMap分段锁.jpg\" alt=\"JDK1.7的ConcurrentHashMap\" /></p>\n<p style=\"text-align:right;font-size:13px;color:gray\">https://www.cnblogs.com/chengxiao/p/6842045.html></p>\n<p><strong>JDK1.8 的 ConcurrentHashMap：</strong></p>\n<p><img src=\"./images/java8_concurrenthashmap.png\" alt=\"Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）\" /></p>\n<p>JDK1.8 的 <code>ConcurrentHashMap</code> 不再是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong><code>TreeNode</code></strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>\n<h3 id=\"_1-5-10-concurrenthashmap-线程安全的具体实现方式-底层具体实现\"> 1.5.10. ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</h3>\n<h4 id=\"_1-5-10-1-jdk1-7-上面有示意图\"> 1.5.10.1. JDK1.7（上面有示意图）</h4>\n<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>\n<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p>\n<p>Segment 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>\n<div><pre><code><span>static</span> <span>class</span> <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>ReentrantLock</span> <span>implements</span> <span>Serializable</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p>\n<h4 id=\"_1-5-10-2-jdk1-8-上面有示意图\"> 1.5.10.2. JDK1.8 （上面有示意图）</h4>\n<p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p>\n<p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>\n<h2 id=\"_1-6-collections-工具类\"> 1.6. Collections 工具类</h2>\n<p>Collections 工具类常用方法:</p>\n<ol>\n<li>排序</li>\n<li>查找,替换操作</li>\n<li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li>\n</ol>\n<h3 id=\"_1-6-1-排序操作\"> 1.6.1. 排序操作</h3>\n<div><pre><code><span>void</span> <span>reverse</span><span>(</span><span>List</span> list<span>)</span><span>//反转</span>\n<span>void</span> <span>shuffle</span><span>(</span><span>List</span> list<span>)</span><span>//随机排序</span>\n<span>void</span> <span>sort</span><span>(</span><span>List</span> list<span>)</span><span>//按自然排序的升序排序</span>\n<span>void</span> <span>sort</span><span>(</span><span>List</span> list<span>,</span> <span>Comparator</span> c<span>)</span><span>//定制排序，由Comparator控制排序逻辑</span>\n<span>void</span> <span>swap</span><span>(</span><span>List</span> list<span>,</span> <span>int</span> i <span>,</span> <span>int</span> j<span>)</span><span>//交换两个索引位置的元素</span>\n<span>void</span> <span>rotate</span><span>(</span><span>List</span> list<span>,</span> <span>int</span> distance<span>)</span><span>//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_1-6-2-查找-替换操作\"> 1.6.2. 查找,替换操作</h3>\n<div><pre><code><span>int</span> <span>binarySearch</span><span>(</span><span>List</span> list<span>,</span> <span>Object</span> key<span>)</span><span>//对List进行二分查找，返回索引，注意List必须是有序的</span>\n<span>int</span> <span>max</span><span>(</span><span>Collection</span> coll<span>)</span><span>//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span>\n<span>int</span> <span>max</span><span>(</span><span>Collection</span> coll<span>,</span> <span>Comparator</span> c<span>)</span><span>//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span>\n<span>void</span> <span>fill</span><span>(</span><span>List</span> list<span>,</span> <span>Object</span> obj<span>)</span><span>//用指定的元素代替指定list中的所有元素</span>\n<span>int</span> <span>frequency</span><span>(</span><span>Collection</span> c<span>,</span> <span>Object</span> o<span>)</span><span>//统计元素出现次数</span>\n<span>int</span> <span>indexOfSubList</span><span>(</span><span>List</span> list<span>,</span> <span>List</span> target<span>)</span><span>//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span>\n<span>boolean</span> <span>replaceAll</span><span>(</span><span>List</span> list<span>,</span> <span>Object</span> oldVal<span>,</span> <span>Object</span> newVal<span>)</span><span>//用新元素替换旧元素</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"_1-6-3-同步控制\"> 1.6.3. 同步控制</h3>\n<p><code>Collections</code> 提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>\n<p>我们知道 <code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。<code>Collections</code> 提供了多个静态方法可以把他们包装成线程同步的集合。</p>\n<p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p>\n<p>方法如下：</p>\n<div><pre><code><span>synchronizedCollection</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>T</span><span>></span></span>  c<span>)</span> <span>//返回指定 collection 支持的同步（线程安全的）collection。</span>\n<span>synchronizedList</span><span>(</span><span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> list<span>)</span><span>//返回指定列表支持的同步（线程安全的）List。</span>\n<span>synchronizedMap</span><span>(</span><span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> m<span>)</span> <span>//返回由指定映射支持的同步（线程安全的）Map。</span>\n<span>synchronizedSet</span><span>(</span><span>Set</span><span><span>&lt;</span><span>T</span><span>></span></span> s<span>)</span> <span>//返回指定 set 支持的同步（线程安全的）set。</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>《Java 面试突击》:</strong> Java 程序员面试必备的《Java 面试突击》V3.0 PDF 版本扫码关注下面的公众号，在后台回复 <strong>&quot;面试突击&quot;</strong> 即可免费领取！</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/format,png.jpeg\" alt=\"我的公众号\" /></p>\n",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Blog Home",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/",
      "content_html": "",
      "date_published": "2021-11-06T13:20:37.000Z",
      "date_modified": "2021-11-06T13:20:37.000Z",
      "authors": [
        {
          "name": "Guide哥"
        }
      ],
      "tags": []
    }
  ]
}