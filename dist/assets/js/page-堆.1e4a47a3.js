(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{560:function(t,v,_){t.exports=_.p+"assets/img/堆1.53af4b18.png"},561:function(t,v,_){t.exports=_.p+"assets/img/堆2.11ff28d5.png"},562:function(t,v,_){t.exports=_.p+"assets/img/堆的存储.64fe16ee.png"},563:function(t,v,_){t.exports=_.p+"assets/img/堆-插入元素1.dac906be.png"},564:function(t,v,_){t.exports=_.p+"assets/img/堆-插入元素2.fbf83526.png"},565:function(t,v,_){t.exports=_.p+"assets/img/堆-插入元素3.8aa071a7.png"},566:function(t,v,_){t.exports=_.p+"assets/img/删除堆顶元素1.70dad123.png"},567:function(t,v,_){t.exports=_.p+"assets/img/删除堆顶元素2.2e8d80a0.png"},568:function(t,v,_){t.exports=_.p+"assets/img/删除堆顶元素3.16f3a670.png"},569:function(t,v,_){t.exports=_.p+"assets/img/删除堆顶元素4.b75a51fb.png"},570:function(t,v,_){t.exports=_.p+"assets/img/删除堆顶元素5.db106914.png"},571:function(t,v,_){t.exports=_.p+"assets/img/删除堆顶元素6.5aa21b30.png"},572:function(t,v,_){t.exports=_.p+"assets/img/建堆1.375e13f4.png"},573:function(t,v,_){t.exports=_.p+"assets/img/建堆2.c7ee5944.png"},574:function(t,v,_){t.exports=_.p+"assets/img/建堆3.8f01d3df.png"},575:function(t,v,_){t.exports=_.p+"assets/img/建堆4.f46396ae.png"},576:function(t,v,_){t.exports=_.p+"assets/img/堆排序1.d5e9a540.png"},577:function(t,v,_){t.exports=_.p+"assets/img/堆排序2.c6d2ce29.png"},578:function(t,v,_){t.exports=_.p+"assets/img/堆排序3.f01745d1.png"},579:function(t,v,_){t.exports=_.p+"assets/img/堆排序4.0ff7cea2.png"},580:function(t,v,_){t.exports=_.p+"assets/img/堆排序5.b877e205.png"},581:function(t,v,_){t.exports=_.p+"assets/img/堆排序6.b73ec730.png"},668:function(t,v,_){"use strict";_.r(v);var s=_(1),a=Object(s.a)({},(function(){var t=this,v=t.$createElement,s=t._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"堆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[t._v("#")]),t._v(" 堆")]),t._v(" "),s("h2",{attrs:{id:"什么是堆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是堆"}},[t._v("#")]),t._v(" 什么是堆")]),t._v(" "),s("p",[t._v("堆是一种满足以下条件的树：")]),t._v(" "),s("p",[t._v("堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。")]),t._v(" "),s("blockquote",[s("p",[t._v("大家可以把堆(最大堆)理解为一个公司,这个公司很公平,谁能力强谁就当老大,不存在弱的人当老大,老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。")])]),t._v(" "),s("p",[s("strong",[t._v("!!!特别提示：")])]),t._v(" "),s("ul",[s("li",[t._v("很多博客说堆是完全二叉树，其实并非如此，"),s("strong",[t._v("堆不一定是完全二叉树")]),t._v("，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。")]),t._v(" "),s("li",[t._v("（"),s("strong",[t._v("二叉")]),t._v("）堆是一个数组，它可以被看成是一个 "),s("strong",[t._v("近似的完全二叉树")]),t._v("。——《算法导论》第三版")])]),t._v(" "),s("p",[t._v("大家可以尝试判断下面给出的图是否是堆？")]),t._v(" "),s("p",[s("img",{attrs:{src:_(560),alt:""}})]),t._v(" "),s("p",[t._v("第1个和第2个是堆。第1个是最大堆，每个节点都比子树中所有节点大。第2个是最小堆，每个节点都比子树中所有节点小。")]),t._v(" "),s("p",[t._v("第3个不是，第三个中，根结点1比2和15小，而15却比3大，19比5大，不满足堆的性质。")]),t._v(" "),s("h2",{attrs:{id:"堆的用途"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆的用途"}},[t._v("#")]),t._v(" 堆的用途")]),t._v(" "),s("p",[t._v("当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。")]),t._v(" "),s("p",[t._v("有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 "),s("code",[t._v("O(nlog(n))")]),t._v("，查找最大值或者最小值时间复杂度都是 "),s("code",[t._v("O(1)")]),t._v("，但是，涉及到更新（插入或删除）数据时，时间复杂度为 "),s("code",[t._v("O(n)")]),t._v("，即使是使用复杂度为 "),s("code",[t._v("O(log(n))")]),t._v(" 的二分法找到要插入或者删除的数据，在移动数据时也需要 "),s("code",[t._v("O(n)")]),t._v(" 的时间复杂度。")]),t._v(" "),s("p",[s("strong",[t._v("相对于有序数组而言，堆的主要优势在于更新数据效率较高。")]),t._v(" 堆的初始化时间复杂度为 "),s("code",[t._v("O(nlog(n))")]),t._v("，堆可以做到"),s("code",[t._v("O(1)")]),t._v("时间复杂度取出最大值或者最小值，"),s("code",[t._v("O(log(n))")]),t._v("时间复杂度插入或者删除数据，具体操作在后续章节详细介绍。")]),t._v(" "),s("h2",{attrs:{id:"堆的分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆的分类"}},[t._v("#")]),t._v(" 堆的分类")]),t._v(" "),s("p",[t._v("堆分为 "),s("strong",[t._v("最大堆")]),t._v(" 和 "),s("strong",[t._v("最小堆")]),t._v("。二者的区别在于节点的排序方式。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("最大堆")]),t._v(" ：堆中的每一个节点的值都大于等于子树中所有节点的值")]),t._v(" "),s("li",[s("strong",[t._v("最小堆")]),t._v(" ：堆中的每一个节点的值都小于等于子树中所有节点的值")])]),t._v(" "),s("p",[t._v("如下图所示，图1是最大堆，图2是最小堆")]),t._v(" "),s("p",[s("img",{attrs:{src:_(561),alt:""}})]),t._v(" "),s("h2",{attrs:{id:"堆的存储"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆的存储"}},[t._v("#")]),t._v(" 堆的存储")]),t._v(" "),s("p",[t._v("之前介绍树的时候说过，由于完全二叉树的优秀性质，利用数组存储二叉树即节省空间，又方便索引（若根结点的序号为1，那么对于树中任意节点i，其左子节点序号为 "),s("code",[t._v("2*i")]),t._v("，右子节点序号为 "),s("code",[t._v("2*i+1")]),t._v("）。")]),t._v(" "),s("p",[t._v("为了方便存储和索引，（二叉）堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：")]),t._v(" "),s("p",[s("img",{attrs:{src:_(562),alt:"堆的存储"}})]),t._v(" "),s("h2",{attrs:{id:"堆的操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆的操作"}},[t._v("#")]),t._v(" 堆的操作")]),t._v(" "),s("p",[t._v("堆的更新操作主要包括两种 :  "),s("strong",[t._v("插入元素")]),t._v(" 和 "),s("strong",[t._v("删除堆顶元素")]),t._v("。操作过程需要着重掌握和理解。")]),t._v(" "),s("blockquote",[s("p",[t._v("在进入正题之前，再重申一遍，堆是一个公平的公司，有能力的人自然会走到与他能力所匹配的位置")])]),t._v(" "),s("h3",{attrs:{id:"插入元素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#插入元素"}},[t._v("#")]),t._v(" 插入元素")]),t._v(" "),s("blockquote",[s("p",[t._v("插入元素，作为一个新入职的员工，初来乍到，这个员工需要从基层做起")])]),t._v(" "),s("p",[s("strong",[t._v("1.将要插入的元素放到最后")])]),t._v(" "),s("p",[s("img",{attrs:{src:_(563),alt:"堆-插入元素-1"}})]),t._v(" "),s("blockquote",[s("p",[t._v("有能力的人会逐渐升职加薪，是金子总会发光的！！！")])]),t._v(" "),s("p",[s("strong",[t._v("2.从底向上，如果父结点比该元素大，则该节点和父结点交换，直到无法交换")])]),t._v(" "),s("p",[s("img",{attrs:{src:_(564),alt:"堆-插入元素2"}})]),t._v(" "),s("p",[s("img",{attrs:{src:_(565),alt:"堆-插入元素3"}})]),t._v(" "),s("h3",{attrs:{id:"删除堆顶元素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#删除堆顶元素"}},[t._v("#")]),t._v(" 删除堆顶元素")]),t._v(" "),s("p",[t._v("根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。")]),t._v(" "),s("p",[t._v('删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为"'),s("strong",[t._v("堆化")]),t._v('"，堆化的方法分为两种：')]),t._v(" "),s("ul",[s("li",[t._v("一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。")]),t._v(" "),s("li",[t._v("另一种是自顶向下堆化，元素由最顶部向下移动。在讲解删除堆顶元素的方法时，我将阐述这两种操作的过程，大家可以体会一下二者的不同。")])]),t._v(" "),s("h4",{attrs:{id:"自底向上堆化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自底向上堆化"}},[t._v("#")]),t._v(" 自底向上堆化")]),t._v(" "),s("blockquote",[s("p",[t._v("在堆这个公司中，会出现老大离职的现象，老大离职之后，他的位置就空出来了")])]),t._v(" "),s("p",[t._v("首先删除堆顶元素，使得数组中下标为1的位置空出。")]),t._v(" "),s("p",[s("img",{attrs:{src:_(566),alt:"删除堆顶元素1"}})]),t._v(" "),s("blockquote",[s("p",[t._v("那么他的位置由谁来接替呢，当然是他的直接下属了，谁能力强就让谁上呗")])]),t._v(" "),s("p",[t._v("比较根结点的左子节点和右子节点，也就是下标为2,3的数组元素，将较大的元素填充到根结点(下标为1)的位置。")]),t._v(" "),s("p",[s("img",{attrs:{src:_(567),alt:"删除堆顶元素2"}})]),t._v(" "),s("blockquote",[s("p",[t._v("这个时候又空出一个位置了，老规矩，谁有能力谁上")])]),t._v(" "),s("p",[t._v("一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部")]),t._v(" "),s("p",[s("img",{attrs:{src:_(568),alt:"删除堆顶元素3"}})]),t._v(" "),s("p",[t._v("这个时候已经完成了自底向上的堆化，没有元素可以填补空缺了，但是，我们可以看到数组中出现了“气泡”，这会导致存储空间的浪费。接下来我们试试自顶向下堆化。")]),t._v(" "),s("h4",{attrs:{id:"自顶向下堆化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自顶向下堆化"}},[t._v("#")]),t._v(" 自顶向下堆化")]),t._v(" "),s("p",[t._v("自顶向下的堆化用一个词形容就是“石沉大海”，那么第一件事情，就是把石头抬起来，从海面扔下去。这个石头就是堆的最后一个元素，我们将最后一个元素移动到堆顶。")]),t._v(" "),s("p",[s("img",{attrs:{src:_(569),alt:"删除堆顶元素4"}})]),t._v(" "),s("p",[t._v("然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。")]),t._v(" "),s("p",[s("img",{attrs:{src:_(570),alt:"删除堆顶元素5"}})]),t._v(" "),s("p",[s("img",{attrs:{src:_(571),alt:"删除堆顶元素6"}})]),t._v(" "),s("h3",{attrs:{id:"堆的操作总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆的操作总结"}},[t._v("#")]),t._v(" 堆的操作总结")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("插入元素")]),t._v(" ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮")]),t._v(" "),s("li",[s("strong",[t._v("删除堆顶元素")]),t._v(" ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。")])]),t._v(" "),s("h2",{attrs:{id:"堆排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆排序"}},[t._v("#")]),t._v(" 堆排序")]),t._v(" "),s("p",[t._v("堆排序的过程分为两步：")]),t._v(" "),s("ul",[s("li",[t._v("第一步是建堆，将一个无序的数组建立为一个堆")]),t._v(" "),s("li",[t._v("第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。")])]),t._v(" "),s("h3",{attrs:{id:"建堆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#建堆"}},[t._v("#")]),t._v(" 建堆")]),t._v(" "),s("p",[t._v("如果你已经足够了解堆化的过程，那么建堆的过程掌握起来就比较容易了。建堆的过程就是一个对所有非叶节点的自顶向下堆化过程。")]),t._v(" "),s("p",[t._v("首先要了解哪些是非叶节点，最后一个节点的父结点及它之前的元素，都是非叶节点。也就是说，如果节点个数为n，那么我们需要对n/2到1的节点进行自顶向下（沉底）堆化。")]),t._v(" "),s("p",[t._v("具体过程如下图：")]),t._v(" "),s("p",[s("img",{attrs:{src:_(572),alt:"建堆1"}})]),t._v(" "),s("p",[t._v("将初始的无序数组抽象为一棵树，图中的节点个数为6，所以4,5,6节点为叶节点，1,2,3节点为非叶节点，所以要对1-3号节点进行自顶向下（沉底）堆化，注意，顺序是从后往前堆化，从3号节点开始，一直到1号节点。\n3号节点堆化结果：")]),t._v(" "),s("p",[s("img",{attrs:{src:_(573),alt:"建堆1"}})]),t._v(" "),s("p",[t._v("2号节点堆化结果：")]),t._v(" "),s("p",[s("img",{attrs:{src:_(574),alt:"建堆1"}})]),t._v(" "),s("p",[t._v("1号节点堆化结果：")]),t._v(" "),s("p",[s("img",{attrs:{src:_(575),alt:"建堆1"}})]),t._v(" "),s("p",[t._v("至此，数组所对应的树已经成为了一个最大堆，建堆完成！")]),t._v(" "),s("h3",{attrs:{id:"排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#排序"}},[t._v("#")]),t._v(" 排序")]),t._v(" "),s("p",[t._v("由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。")]),t._v(" "),s("p",[t._v("现在思考两个问题：")]),t._v(" "),s("ul",[s("li",[t._v("删除堆顶元素后需要执行自顶向下（沉底）堆化还是自底向上（上浮）堆化？")]),t._v(" "),s("li",[t._v("取出的堆顶元素存在哪，新建一个数组存？")])]),t._v(" "),s("p",[t._v("先回答第一个问题，我们需要执行自顶向下（沉底）堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将取出的元素放在末尾。")]),t._v(" "),s("p",[t._v("机智的小伙伴已经发现了，这其实是做了一次交换操作，将堆顶和末尾元素调换位置，从而将取出堆顶元素和堆化的第一步(将末尾元素放至根结点位置)进行合并。")]),t._v(" "),s("p",[t._v("详细过程如下图所示：")]),t._v(" "),s("p",[t._v("取出第一个元素并堆化：")]),t._v(" "),s("p",[s("img",{attrs:{src:_(576),alt:"堆排序1"}})]),t._v(" "),s("p",[t._v("取出第二个元素并堆化：")]),t._v(" "),s("p",[s("img",{attrs:{src:_(577),alt:"堆排序2"}})]),t._v(" "),s("p",[t._v("取出第三个元素并堆化：")]),t._v(" "),s("p",[s("img",{attrs:{src:_(578),alt:"堆排序3"}})]),t._v(" "),s("p",[t._v("取出第四个元素并堆化：")]),t._v(" "),s("p",[s("img",{attrs:{src:_(579),alt:"堆排序4"}})]),t._v(" "),s("p",[t._v("取出第五个元素并堆化：")]),t._v(" "),s("p",[s("img",{attrs:{src:_(580),alt:"堆排序5"}})]),t._v(" "),s("p",[t._v("取出第六个元素并堆化：")]),t._v(" "),s("p",[s("img",{attrs:{src:_(581),alt:"堆排序6"}})]),t._v(" "),s("p",[t._v("堆排序完成！")])])}),[],!1,null,null,null);v.default=a.exports}}]);